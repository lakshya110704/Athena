Documentation for the npm registry, website, and command-line interface
Documentation for the npm registry, website, and command-line interface
Documentation for the npm registry, website, and command-line interface
Documentation for the npm registry, website, and command-line interface
Resend OTP in:  seconds 

                    Didn't receive the OTP?
                    Resend OTP 

Resend OTP in: 30 seconds 

                      Didn't receive the OTP?
                      Resend OTP 


            npm loves you.  Here is some info about how well it's doing. (You can also follow these updates at @npmstatus on Twitter!)
          
No incidents or maintenance related to this downtime.
No incidents reported today.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
No incidents reported.
You need to be signed in to get help with npm.
Choose one of these categories to continue.
Press inquiries should be addressed to press@npmjs.com
npm is the world's largest software registry. Open source developers from every continent use npm to share and borrow packages, and many organizations use npm to manage private development as well.
npm consists of three distinct components:
Use the website to discover packages, set up profiles, and manage other aspects of your npm experience. For example, you can set up organizations to manage access to public or private packages.
The CLI runs from a terminal, and is how most developers interact with npm.
The registry is a large public database of JavaScript software and the meta-information surrounding it.
To get started with npm, you can create an account, which will be available at http://www.npmjs.com/~yourusername.
After you set up an npm account, the next step is to use the command line interface (CLI) to install npm. We look forward to seeing what you create!
If you choose to share your packages publicly, there is no cost. To use and share private packages, you need to upgrade your account. To share with others, create organizations, called npm organizations, and invite others to work with you, privately (for a fee) or publicly (for free).
You can also use a private npm package registry like GitHub Packages or the open source Verdaccio project. This lets you develop packages internally that are not shared publicly.
To learn more about npm as a product, upcoming new features, and interesting uses of npm be sure to follow @npmjs on Twitter.
For mentoring, tutorials, and learning, visit node school. Consider attending or hosting a nodeschool event (usually free!) at a site near you, or use the self-help tools you can find on the site.
While relevant CLI commands are covered throughout this user documentation, the CLI includes command line help, its own documentation section, and instant help (man pages).
If you do not already have an npm user account, you can create an account in order to share and download Javascript packages on the public registry.
Go to the npm signup page
In the user signup form, type in the fields:
Read the End User License Agreement and Privacy Policy, and indicate that you agree to them.
Click Create An Account.
Note: After signing up for an npm account, you will receive an account verification email. You must verify your email address in order to publish packages to the registry.
Use the npm login command to test logging in to your new account.
Note: If you misspell your existing account username when you log in with the npm login command, you will create a new account with the misspelled name. For help with accidentally-created accounts, contact npm Support.
On the command line, type the following command:
When prompted, enter your username, password, and email address.
If you have two-factor authentication enabled, when prompted, enter a one-time password.
To test that you have successfully logged in, type:
Your npm username should be displayed.
Secure your npm account with a strong and unique password using a password manager.
You must choose or generate a password for your npm account that:
To keep your account secure, we recommend you follow these best practices:
When you type a password to sign in, create an account, or change your password, npm will check if the password you entered is considered weak according to datasets like HaveIBeenPwned. The password may be identified as weak even if you have never used that password before.
npm only inspects the password at the time you type it, and never stores the password you entered in plaintext. For more information, see HaveIBeenPwned.
For your security, npm may require additional verification to allow you to log in to your account. If you do not have two-factor authentication enabled, you may be asked to verify yourself with a one-time password sent to the email address configured for your account.
You'll be prompted for a one-time password that was sent to your email.
Check your email account for an email from npm containing your one-time password (the subject will begin "OTP for logging in to your account").
Enter the digits from your email in your one-time password field.
To avoid this additional login step, with a one-time password sent to you via e-mail, you can configure two-factor authentication with a device (2FA) instead.
If you are unable to access the email linked to your npm account, you can submit a support ticket to reset this email address.
Under the "Login Verification" form, click Try recovering your account.
Two-factor authentication (2FA) protects against unauthorized access to your account by confirming your identity using:
When you enable 2FA, you will be prompted for a second form of authentication before performing certain actions on your account or packages to which you have write access. Depending on your 2FA configuration you will be either prompted to authenticate with a security-key or a time-based one-time password (TOTP).
Note: Two-factor authentication provides the best possible security for your account against attackers. We strongly recommend enabling 2FA on your account as soon as possible after you sign up.
Two-factor authentication on npm can be enabled for authorization and writes, or authorization only.
By default, 2FA is enabled for authorization and writes. We will request a second form of authentication for certain authorized actions, as well as write actions.
If you enable 2FA for authorization only. We will request a second form of authentication only for certain authorized actions.
You can enable two-factor authentication (2FA) on your npm user account to protect against unauthorized access to your account and packages, either by using a security-key or time-based one-time password (TOTP) from a mobile app.
Before you enable 2FA on your npm user account, you must:
For more information on supported 2FA methods, see "About two-factor authentication".
Note: npm does not accept SMS (text-to-phone) as a 2FA method.
On the account settings page, under "Two-Factor Authentication", click Enable 2FA.
When prompted provide your current account password and then click Confirm password to continue.
On the 2FA method page, select the method you would like to enable and click Continue. For more information on supported 2FA methods, see "About two-factor authentication".
Configure the 2FA method of your choice:
On the recovery code page, copy the recovery codes to your computer or other safe location that is not your second factor device. We recommend using a password manager.
Recovery codes are the only way to ensure you can recover your account if you lose access to your second factor device. Each code can be used only once. You can view and regenerate your recovery code from your 2FA settings page. For secondary account recovery options, see "Configuring account recovery options."
Click Go back to settings after confirming that you have saved your codes.
Check the Authorization and writes section for more information on different operations that requires 2FA when this mode is enabled.
Note: As a recommended setting, 2FA for write operations are automatically enabled when setting up 2FA. The following steps explain how to disable it.
On the account settings page, under "Two-Factor Authentication", click Modify 2FA.
From the "Manage Two-Factor Authentication" navigate to "Additional Options" section
Clear the checkbox for "Require two-factor authentication for write actions" and click "Update Preferences"
If you have 2FA enabled, you can remove it from your account settings page.
Note: You cannot remove 2FA if you are a member of an organization that enforces 2FA. You can view the list of organizations memberships from your profile page under the "Organizations" tab.
On the account settings page, under "Two-Factor Authentication", click Modify 2FA.
Scroll to the bottom of the "Manage Two-Factor Authentication" page and click Disable 2FA.
Agree to the prompt from the browser.
Although security-key with WebAuthn can be used for authentication from both the web and the command line, it can only be configured from the web. When enabling 2FA from the command line, currently the only available option is to use an TOTP mobile app.
Note: Settings you configure on the command line will also apply to your profile settings on the npm website.
If you are logged out on the command line, log in using npm login command.
On the command line, type the npm profile command along with the option for the 2FA mode you want to enable:
To enable 2FA for authorization and writes, type:
To enable 2FA for authorization only, type:
To add npm to your authenticator application, using the device with the app, you can either:
When prompted to add an OTP code from your authenticator, on the command line, enter a one-time password generated by your authenticator app.
If you have enabled 2FA auth-and-writes, you will need to send the TOTP from the command line for certain commands to work. To do this, append --otp=123456 (where 123456 is the code generated by your authenticator) at the end of the command. Here are a few examples:
If you are logged out on the command line, log in using npm login command.
On the command line, type the following command:
When prompted, enter your npm password:
When prompted for a one-time password, enter a password from your authenticator app:
When you enable 2FA on your npm user account, we strongly recommend you link your GitHub and/or Twitter accounts to your npm user account. In the event you lose access to your 2FA device and recovery codes, these linked accounts can be used to verify your identity and expedite the recovery of your npm account.
To link your GitHub account, on the account settings page, under "Linked Accounts & Recovery Option", click Link with GitHub.
On the authorization page, verify all information looks correct. Then click Authorize npm account link.
To link your Twitter account, on the account settings page, under "Linked Accounts & Recovery Option", click Link with Twitter.
On the authorization page, verify all information looks correct. Then click Authorize app.
The Twitter or GitHub account is now linked to your npm account. To remove the link to either account, you can click the Remove button next to the account you want to remove from your npm account.
If you are entering what seems to be a valid TOTP but you see an error, be sure that you are using the correct authenticator account. If you have multiple authenticator accounts, using an TOTP from the wrong account will cause an error.
Also, when you reset two-factor authentication after it has been disabled, the authenticator might create a second account with the same name. Please see the authenticator documentation to delete the old account.
On the command line, type the npm login command.
When prompted, provide your username, password, and email address.
If you have configured a security-key, open the provided URL shown in the command line. Alternatively, if you have configured a mobile authenticator skip to step 6.
Click on Use security key and follow the browser specific steps to authenticate.
Copy the generated token
Enter the one-time password into the CLI prompt.
npm 8.14.0 and higher support login flow through the browsers. This will become the default behavior for the npm public registry in npm 9.
On the command line, type the npm login --auth-type=web command.
When prompted hit "ENTER" to open your browser to start the login flow or click the provided URL show in the command line.
Click on Use security key and follow the browser specific steps to authenticate.
Note: If you have configured to use TOTP, you will see an TOTP prompt instead
On the command line, type the npm login --auth-type=web command.
When prompted hit "ENTER" to open your browser to start the login flow or click the provided URL show in the command line.
Click on Use security key and follow the browser specific steps to authenticate.
Note: If you have configured to use TOTP, you will see an TOTP prompt instead
When you have two-factor access enabled on your account, and you lose access to your 2FA device, you may be able to recover your account using the following methods.
If you have misplaced the device that provided second-factor authentication, you can use the recovery codes generated when you enabled 2FA to access your account.
Locate the recovery codes generated that you have saved.
Note: If you have configured to use TOTP, you will see an TOTP prompt instead
Enter an unused recovery code in the "Use a Recovery Code" prompt.
You are now logged into npm.
(Optional) To disable 2FA, see "Disabling 2FA".
Locate the recovery codes generated when you enabled 2FA on your account.
If you are logged out on the command line, log in using npm login command with your username and npm password.
Enter an unused recovery code when you see this prompt:
Once you are logged in, use the below and enter your npm password if prompted.
Enter another unused recovery code when you see this prompt:
npm will confirm that two-factor authentication has been disabled.
Follow the steps outlined in "Configuring two-factor authentication" to re-enable 2FA and generate new recovery codes.
Note: Using the recovery codes to re-enable 2FA may create a new authenticator account with the same npm account name.
If you are using a time-based one-time password (TOTP) mobile app and want to delete the old authenticator account, follow the steps for the authenticator.
Note: Once you regenerate a set of code, all previous recovery codes become invalid. Each code can be used only once.
On the account settings page, under "Two-Factor Authentication", click Modify 2FA.
Click "Manage Recovery Codes" to view your recovery codes.
Click "Regenerate Code" to generate a new set of codes.
If you have misplaced both your 2FA device and your recovery codes, you can contact our support team to attempt to recover your account. Provide as much information as possible to help us expedite the request faster.
Under the "Use a Recovery Code" form, click Try recovering your account.
If you have access to your registered email, enter the one-time password sent to your email in the One-Time Password field, then click Verify Email Address. If you do not have access to your registered email, select Skip email verification at the bottom of the form.
You can manage settings for your user account profile from the web or command line.
From the web, you can change the following user profile settings:
On the account settings page, you will find a button to link your GitHub account. Click that.
If you are not currently logged in to GitHub you will be prompted to go through the authentication flow.
After successfully logging in, or if you already had an active browser sessions, you will be prompted to "authorize npm account link", click the button.
You will be redirected to npm and the link will show as successful in your settings.
On the account settings page, you will find a button to link your Twitter account. Click that.
If you are not currently logged in to Twitter you will be prompted to go through the authentication flow. Click "Log in"
After successfully logging in, or if you already had an active browser sessions, you will be prompted to "Authorize app", click the button.
You will be redirected to npm and the link will show as successful in your settings.
On the account settings page, you will find a button to remove your GitHub account. Click that.
Note: Clicking remove will only remove the link from your npm account. You need to revoke permissions from your GitHub app authorization settings to permanently remove the integration from your GitHub account
On the account settings page, you will find a button to remove your GitHub account. Click that.
Note: Clicking remove will only remove the link from your npm account. You need to revoke permissions from your Twitter connect apps management page to permanently remove the integration from your Twitter account
Note: Your npm client must be version 5.5.1 or higher to change your account settings from the CLI. To update to the latest version of npm, on the command line, run npm install npm@latest -g
To view your user profile settings from the CLI, on the command line, run the following command:
From the CLI, you can change the following properties for your user account:
On the command line, type the following command, replacing property with the name of the property, and value with the new value:
When prompted, provide your current password.
If you have enabled two-factor authentication on your account, when prompted, enter a one-time password.
For more details, see the profile command line documentation.
When prompted, provide your current password.
When prompted, type a new password.
To protect your account, when you reset your password from the command line, it must:
Enabling two-factor authentication on your account helps protect against unauthorized access to your account and packages.
To enable, configure, and disable two-factor authentication from the command line, see "Configuring two-factor authentication".
It is not currently possible to change your npm username. You'll need to create a new account and migrate the data to the new account manually.
From the web, you can delete your npm user account.
On this page, you will find a button to delete your account. Click that.
You will now be presented with an overview of how many npm packages will be deleted and deprecated as part of your account deletion. If you agree with this, then enter your username and click "Delete this account".
You will be immediately logged out, and will not be able to log back in.
In some cases, you will be presented with an error if we were unable to automatically delete your account. For example. if you are the sole owner of an organization you will need to add an additional owner before your account can be deleted. You will be presented clear instructions of what you will need to do in order to delete your account.
If you are in doubt about deleting your account, contact npm Support.
You can export and review the metadata that npm stores about your personal account. The export is an archive containing the following information.
After a request is placed our support team will review it and initiate an export on your behalf. Once the export process is complete you will receive an email with a link to an archive of your personal data. You must be authenticated to npmjs.com to download this archive.
The download link will be available for 7 days, after which the exported data and the link is purged.
Note: This article only applies to users of the public npm registry.
If you need to install and publish private packages, you can upgrade to a paid user account plan. Our paid user account plan costs $7 per month. For more information, see the "npm account" column on our pricing page.
Your paid plan and billing cycle will start when you submit your credit card information, and you will be charged for the first month immediately.
Under "change plan", click Upgrade Plan ($7/User).
Under "Want to upgrade?", click Enable Private Publishing for $7/mo.
Click Pay $7.00.
Note: This article only applies to users of the public npm registry.
You can view, download, and email receipts for the complete billing history of your npm user account.
Click Send.
Note: This article only applies to users of the public npm registry.
You can update the credit card used to pay for your paid user account plan. Updating your credit card will not change your billing cycle date, and the new credit card will be charged on the next billing cycle.
You can update the email address used for receipts, and add extra information to the receipt for your paid user account plan, such as your business name, VAT identification number, or address of record. Updated billing information will appear on all receipts immediately.
Note: The billing email is used for receipts only and is not required to match the email address of the person whose card is used to pay for the paid user account plan.
Note: This article only applies to users of the public npm registry.
If you have a paid user account, but no longer need private packages, you can downgrade your paid organization to a free organization. When you downgrade from a paid to a free organization, you will lose the ability to install and publish private packages at the end of your last paid billing cycle. Your private packages will not be made publicly visible when you downgrade to a free plan.
The npm command line interface (CLI) is released on a regular cadence. We recommend installing the release that supports your workflow:
The latest release of npm is the most recent stable version. When you install Node.js, npm is automatically installed. However, npm is released more frequently than Node.js, so to install the latest stable version of npm, on the command line, run:
To publish and install packages to and from the public npm registry or a private npm registry, you must install Node.js and the npm command line interface using either a Node version manager or a Node installer. We strongly recommend using a Node version manager like nvm to install Node.js and npm. We do not recommend using a Node installer, since the Node installation process installs npm in a directory with local permissions and can cause permissions errors when you run npm packages globally.
Note: to download the latest version of npm, on the command line, run the following command:
To see if you already have Node.js and npm installed and check the installed version, run the following commands:
Node version managers allow you to install and switch between multiple versions of Node.js and npm on your system so you can test your applications on multiple versions of npm to ensure they work for users on different versions.
If you are unable to use a Node version manager, you can use a Node installer to install both Node.js and npm on your system.
If you use Linux, we recommend that you use a NodeSource installer.
If you're using OS X or Windows, use one of the installers from the Node.js download page. Be sure to install the version labeled LTS. Other versions have not yet been tested with npm.
If you're using Linux or another operating system, use one of the following installers:
Or see this page to install npm for Linux in the way many Linux developers prefer.
For more information on installing Node.js on a variety of operating systems, see this page.
When a package fails to install or publish, the npm CLI will generate an npm-debug.log file. This log file can help you figure out what went wrong.
If you need to generate a npm-debug.log file, you can run one of these commands.
For installing packages:
For publishing packages:
You can find the npm-debug.log file in your .npm directory. To find your .npm directory, use npm config get cache.
If you use a CI environment, your logs are likely located elsewhere. For example, in Travis CI, you can find them in the /home/travis/build directory.
If your npm is broken:
You have an outdated npm. Please update to the latest stable npm.
Please see the discussions in "Downloading and installing Node.js and npm" and "Resolving EACCES permissions errors when installing packages globally" for ways to avoid and resolve permissions errors.
The error Error: ENOENT, stat 'C:\Users\<user>\AppData\Roaming\npm' on Windows 7 is a consequence of joyent/node#8141, and is an issue with the Node installer for Windows. The workaround is to ensure that C:\Users\<user>\AppData\Roaming\npm exists and is writable with your normal user account.
You are trying to install on a drive that either has no space, or has no permission to write.
You need to install git. Or, you may need to add your git information to your npm profile. You can do this from the command line or the website. For more information, see "Managing your profile settings".
@drmyersii went through what sounds like a lot of painful trial and error to come up with a working solution involving Windows long paths and some custom Vagrant configuration:
This is the commit that I implemented it in, but I'll go ahead and post the main snippet of code here:
In the code above, I am appending \\?\ to the current directory absolute path. This will actually force the Windows API to allow an increase in the MAX_PATH variable (normally capped at 260). Read more about max path. This is happening during the sharedfolder creation which is intentionally handled by VBoxManage and not Vagrant's "synced_folder" method. The last bit is pretty self-explanatory; we create the new shared folder and then make sure it's mounted each time the machine is accessed or touched since Vagrant likes to reload its mounts/shared folders on each load.
@LaurentGoderre fixed this with some Git trickery:
I fixed this issue for several of my colleagues by running the following two commands:
One thing we noticed is that the .gitconfig used is not always the one expected so if you are on a machine that modified the home path to a shared drive, you need to ensure that your .gitconfig is the same on both your shared drive and in c:\users\[your user]\
You are trying to talk SSL to an unencrypted endpoint. More often than not, this is due to a proxy configuration error (see also this helpful, if dated, guide). In this case, you do not want to disable strict-ssl – you may need to set up a CA / CA file for use with your proxy, but it's much better to take the time to figure that out than disabling SSL protection.
This problem will happen if you're running Node 0.6. Please upgrade to node 0.8 or above. See this post for details.
You could also try these workarounds: npm config set ca "" or npm config set strict-ssl false
npm no longer supports its self-signed certificates
Either:
If this does not fix the problem, then you may have an SSL-intercepting proxy. (For example, https://github.com/npm/npm/issues/7439#issuecomment-76024878)
Unsolved. See https://github.com/npm/npm/issues/9282
npm is written to use resources efficiently on install, and part of this is that it tries to do as many things concurrently as is practical. Sometimes this results in race conditions and other synchronization issues. As of npm 2.0.0, a very large number of these issues were addressed. If you see ENOENT lstat, ENOENT chmod, ENOTEMPTY unlink, or something similar in your log output, try updating npm to the latest version. If the problem persists, look at npm/npm#6043 and see if somebody has already discussed your issue.
Take a look at issue #5920. We're working on fixing this one, but it's a fairly subtle race condition and it's taking us a little time. You might try moving your npm-shrinkwrap.json file out of the way until we have this fixed. This has been fixed in versions of npm newer than npm@2.1.5, so update to npm@latest.
Sometimes npm login fails for no obvious reason. The first thing to do is to log in at https://www.npmjs.com/login and check that your e-mail address on npmjs.com matches the email address you are giving to npm login.
If that's not the problem, or if you are seeing the message "may not mix password_sha and pbkdf2", then
and it generally seems to work.
See https://github.com/npm/npm/issues/6641#issuecomment-72984009 for the history of this issue.
Check if you have two temp directories set in your .npmrc:
Look for lines defining the tmp config variable. If you find more than one, remove all but one of them.
See https://github.com/npm/npm/issues/7590 for more about this unusual problem.
See the section about Windows here.
If you're experiencing issues while using a version of node which is unsupported or unstable (odd numbered versions e.g. 0.7.x, 0.9.x, 0.11.x), it's very possible your issue will be fixed by simply using the LTS version of node.
For some Linux distributions (Debian/Ubuntu and RedHat/CentOS), the latest node version provided by the distribution may lag behind the stable version. Here are instructions from NodeSource on getting the latest node.
Install the latest msi from https://nodejs.org/en/download
Install the latest package from https://nodejs.org/en/download
or if you are using homebrew
Node.js has lots of versions, and its development is very active. As a good practice to manage the various versions, we recommend that you use a version manager for your Node.js installation. There are many great options, here are a few:
(You may need to prefix these commands with sudo, especially on Linux, or OS X if you installed Node using its default installer.)
You can upgrade to the latest version of npm using:
By default, npm is installed alongside node in
C:\Program Files (x86)\nodejs
npm's globally installed packages (including, potentially, npm itself) are stored separately in a user-specific directory (which is currently
C:\Users\<username>\AppData\Roaming\npm).
Because the installer puts
C:\Program Files (x86)\nodejs
before
C:\Users\<username>\AppData\Roaming\npm
on your PATH, it will always use the version of npm installed with node instead of the version of npm you installed using npm -g install npm@<version>.
To get around this, you can do one of the following:
Option 1: edit your Windows installation's PATH to put %appdata%\npm before %ProgramFiles%\nodejs. Remember that you'll need to restart cmd.exe (and potentially restart Windows) when you make changes to PATH or how npm is installed.
Option 2: remove both of
Option 3: Navigate to %ProgramFiles%\nodejs\node_modules\npm and copy the npmrcfile to another folder or the desktop. Then open cmd.exe as an administrator and run the following commands:
If you installed npm with the node.js installer, after doing one of the previous steps, do the following.
Option 1 or 2
Option 3
(See also the point below if you're running Windows 7 and don't have the directory %appdata%\npm.)
The Node installer installs, directly into the npm folder, a special piece of Windows-specific configuration that tells npm where to install global packages. When npm is used to install itself, it is supposed to copy this special builtin configuration into the new install. There was a bug in some versions of npm that kept this from working, so you may need to go in and fix that up by hand. Run the following command to see where npm will install global packages to verify it is correct.
If it isn't set to <X>:\Users\<user>\AppData\Roaming\npm, you can run the below command to correct it:
Incidentally, if you would prefer that packages not be installed to your roaming profile (because you have a quota on your shared network, or it makes logging in or out from a domain sluggish), you can put it in your local app data instead:
...as well as copying %APPDATA%\npm to %LOCALAPPDATA%\npm (and updating your %PATH%, of course).
Everyone who works on npm knows that this process is complicated and fraught, and we're working on making it simpler. Stay tuned.
The public npm registry is a database of JavaScript packages, each comprised of software and metadata. Open source developers and developers at companies use the npm registry to contribute packages to the entire community or members of their organizations, and download packages to use in their own projects.
To get started with the registry, sign up for an npm account and check out the "Getting started" and CLI documentation.
The npm registry contains packages, many of which are also Node modules, or contain Node modules. Read on to understand how they differ and how they interact.
A package is a file or directory that is described by a package.json file. A package must contain a package.json file in order to be published to the npm registry. For more information on creating a package.json file, see "Creating a package.json file".
Packages can be unscoped or scoped to a user or organization, and scoped packages can be private or public. For more information, see
A package is any of the following:
Git URLs used for npm packages can be formatted in the following ways:
The commit-ish can be any tag, sha, or branch that can be supplied as an argument to git checkout. The default commit-ish is HEAD.
A module is any file or directory in the node_modules directory that can be loaded by the Node.js require() function.
To be loaded by the Node.js require() function, a module must be one of the following:
Note: Since modules are not required to have a package.json file, not all modules are packages. Only modules that have a package.json file are also packages.
In the context of a Node program, the module is also the thing that was loaded from a file. For example, in the following program:
var req = require('request')
we might say that "The variable req refers to the request module".
Note: You must be using npm version 2 or greater to use scopes. To upgrade to the latest version of npm, on the command line, run npm install npm@latest -g
When you sign up for an npm user account or create an organization, you are granted a scope that matches your user or organization name. You can use this scope as a namespace for related packages.
A scope allows you to create a package with the same name as a package created by another user or organization without conflict.
When listed as a dependent in a package.json file, scoped packages are preceded by their scope name. The scope name is everything between the @ and the slash:
To create and publish public scoped packages, see "Creating and publishing scoped public packages".
To create and publish private scoped packages, see "Creating and publishing private packages".
For more information on package scope and visibility, see "Package scope, access level, and visibility".
As an npm user or organization member, you can create and publish public packages that anyone can download and use in their own projects.
To use private packages, you must
With npm private packages, you can use the npm registry to host code that is only visible to you and chosen collaborators, allowing you to manage and use private code alongside public code in your projects.
Private packages always have a scope, and scoped packages are private by default.
Visibility of npm packages depends on the scope (namespace) in which the package is contained, and the access level (private or public) set for the package.
Note: To create organization-scoped packages, you must first create an organization. For more information, see "Creating an organization".
Note: Only user accounts can create and manage unscoped packages. Organizations can only manage scoped packages.
You can add a package.json file to your package to make it easy for others to manage and install. Packages published to the registry must contain a package.json file.
A package.json file:
Note: To make your package easier to find on the npm website, we recommend including a custom description in your package.json file.
A package.json file must contain "name" and "version" fields.
The "name" field contains your package's name, and must be lowercase and one word, and may contain hyphens and underscores.
The "version" field must be in the form x.x.x and follow the semantic versioning guidelines.
If you want to include package author information in "author" field, use the following format (email and website are both optional):
You can create a package.json file by running a CLI questionnaire or creating a default package.json file.
To create a package.json file with values that you supply, use the npm init command.
On the command line, navigate to the root directory of your package.
Run the following command:
Answer the questions in the command line questionnaire.
If you expect to create many package.json files, you can customize the questions asked and fields created during the init process so all the package.json files contain a standard set of information.
In your home directory, create a file called .npm-init.js.
To add custom questions, using a text editor, add questions with the prompt function:
To add custom fields, using a text editor, add desired fields to the .npm-init.js file:
To learn more about creating advanced npm init customizations, see the init-package-json GitHub repository.
To create a default package.json using information extracted from the current directory, use the npm init command with the --yes or -y flag. For a list of default values, see "Default values extracted from the current directory".
On the command line, navigate to the root directory of your package.
Run the following command:
You can set default config options for the init command. For example, to set the default author email, author name, and license, on the command line, run the following commands:
Node.js modules are a type of package that can be published to npm.
For more information on package.json files, see "Creating a package.json file".
In the file, add a function as a property of the exports object. This will make the function available to other code:
Publish your package to npm:
On the command line, create a new test directory outside of your project directory.
Switch to the new directory:
In the test directory, install your module:
In the test directory, create a test.js file which requires your module and calls your module as a method.
On the command line, run node test.js. The message sent to the console.log should appear.
To help others find your packages on npm and have a good experience using your code in their projects, we recommend including a README file in your package directory. Your README file may include directions for installing, configuring, and using the code in your package, as well as any other information a user may find helpful. The README file will be shown on the package page.
An npm package README file must be in the root-level directory of the package.
Note: The file extension .md indicates a Markdown file. For more information about Markdown, see the GitHub Guide "Mastering Markdown".
The README file will only be updated on the package page when you publish a new version of your package. To update your README file:
In a text editor, update the contents of the README.md file.
Save the README.md file.
On the command line, in the package root directory, run the following commands:
As an npm user, you can create unscoped packages to use in your own projects and publish them to the npm public registry for others to use in theirs. Unscoped packages are always public and are referred to by the package name only:
For more information on package scope, access, and visibility, see "Package scope, access level, and visibility".
Note: Before you can publish public unscoped npm packages, you must sign up for an npm user account.
On the command line, create a directory for your package:
Navigate to the root directory of your package:
If you are using git to manage your package code, in the package root directory, run the following commands, replacing git-remote-url with the git remote URL for your package:
In the package root directory, run the npm init command.
Respond to the prompts to generate a package.json file. For help naming your package, see "Package name guidelines".
Create a README file that explains what your package code is and how to use it.
In your preferred text editor, write the code for your package.
Publishing sensitive information to the registry can harm your users, compromise your development infrastructure, be expensive to fix, and put you at risk of legal action. We strongly recommend removing sensitive information, such as private keys, passwords, personally identifiable information (PII), and credit card data before publishing your package to the registry.
For less sensitive information, such as testing data, use a .npmignore or .gitignore file to prevent publishing to the registry. For more information, see this article.
To reduce the chances of publishing bugs, we recommend testing your package before publishing it to the npm registry. To test your package, run npm install with the full path to your package directory:
On the command line, navigate to the root directory of your package.
To publish your public package to the npm registry, run:
Note: If you use GitHub Actions to publish your packages, you can generate provenance information for each package you publish. For more information, see "Generating provenance statements."
To see your public package page, visit https://npmjs.com/package/*package-name*, replacing *package-name* with the name of your package. Public packages will say public below the package name on the npm website.
For more information on the publish command, see the CLI documentation.
To share your code publicly in a user or organization namespace, you can publish public user-scoped or organization-scoped packages to the npm registry.
For more information on scopes, see "About scopes".
Note: Before you can publish user-scoped npm packages, you must sign up for an npm user account.
Additionally, to publish organization-scoped packages, you must create an npm user account, then create an npm organization.
If you are using npmrc to manage accounts on multiple registries, on the command line, switch to the appropriate profile:
On the command line, create a directory for your package:
Navigate to the root directory of your package:
If you are using git to manage your package code, in the package root directory, run the following commands, replacing git-remote-url with the git remote URL for your package:
In the package root directory, run the npm init command and pass the scope to the scope flag:
For an organization-scoped package, replace my-org with the name of your organization:
For a user-scoped package, replace my-username with your username:
Respond to the prompts to generate a package.json file. For help naming your package, see "Package name guidelines".
Create a README file that explains what your package code is and how to use it.
In your preferred text editor, write the code for your package.
Publishing sensitive information to the registry can harm your users, compromise your development infrastructure, be expensive to fix, and put you at risk of legal action. We strongly recommend removing sensitive information, such as private keys, passwords, personally identifiable information (PII), and credit card data before publishing your package to the registry.
For less sensitive information, such as testing data, use a .npmignore or .gitignore file to prevent publishing to the registry. For more information, see this article.
To reduce the chances of publishing bugs, we recommend testing your package before publishing it to the npm registry. To test your package, run npm install with the full path to your package directory:
By default, scoped packages are published with private visibility. To publish a scoped package with public visibility, use npm publish --access public.
On the command line, navigate to the root directory of your package.
To publish your scoped public package to the npm registry, run:
Note: If you use GitHub Actions to publish your packages, you can generate provenance information for each package you publish. For more information, see "Generating provenance statements."
To see your public package page, visit https://npmjs.com/package/\*package-name\*, replacing *package-name* with the name of your package. Public packages will say public below the package name on the npm website.
For more information on the publish command, see the CLI documentation.
To share your code with a limited set of users or teams, you can publish private user-scoped or organization-scoped packages to the npm registry.
For more information on scopes and private packages, see "About scopes" and "About private packages".
Note: Before you can publish private user-scoped npm packages, you must sign up for a paid npm user account.
Additionally, to publish private organization-scoped packages, you must create an npm user account, then  create a paid npm organization.
If you are using npmrc to manage accounts on multiple registries, on the command line, switch to the appropriate profile:
On the command line, create a directory for your package:
Navigate to the root directory of your package:
If you are using git to manage your package code, in the package root directory, run the following commands, replacing git-remote-url with the git remote URL for your package:
In the package root directory, run the npm init command and pass the scope to the scope flag:
For an organization-scoped package, replace my-org with the name of your organization:
For a user-scoped package, replace my-username with your username:
Respond to the prompts to generate a package.json file. For help naming your package, see "Package name guidelines".
Create a README file that explains what your package code is and how to use it.
In your preferred text editor, write the code for your package.
Publishing sensitive information to the registry can harm your users, compromise your development infrastructure, be expensive to fix, and put you at risk of legal action. We strongly recommend removing sensitive information, such as private keys, passwords, personally identifiable information (PII), and credit card data before publishing your package to the registry. Even if your package is private, sensitive information can be exposed if the package is made public or downloaded to a computer that can be accessed by more users than intended.
For less sensitive information, such as testing data, use a .npmignore or .gitignore file to prevent publishing to the registry. For more information, see this article.
To reduce the chances of publishing bugs, we recommend testing your package before publishing it to the npm registry. To test your package, run npm install with the full path to your package directory:
By default, scoped packages are published with private visibility.
On the command line, navigate to the root directory of your package.
To publish your private package to the npm registry, run:
To see your private package page, visit https://npmjs.com/package/*package-name*, replacing *package-name* with the name of your package. Private packages will say private below the package name on the npm website.
For more information on the publish command, see the CLI documentation.
When choosing a name for your package, choose a name that
Additionally, when choosing a name for an unscoped package, also choose a name that
To specify the packages your project depends on, you must list them as "dependencies" or "devDependencies" in your package's package.json file. When you (or another user) run npm install, npm will download dependencies and devDependencies that are listed in package.json that meet the semantic version requirements listed for each. To see which versions of a package will be installed, use the semver calculator.
You can add dependencies to a package.json file from the command line or by manually editing the package.json file.
To add dependencies and devDependencies to a package.json file from the command line, you can install them in the root directory of your package using the --save-prod flag for dependencies (the default behavior of npm install) or the --save-dev flag for devDependencies.
To add an entry to the "dependencies" attribute of a package.json file, on the command line, run the following command:
To add an entry to the "devDependencies" attribute of a package.json file, on the command line, run the following command:
To add dependencies to a package.json file, in a text editor, add an attribute called "dependencies" that references the name and semantic version of each dependency:
To add devDependencies to a package.json file, in a text editor, add an attribute called "devDependencies" that references the name and semantic version of each devDependency:
To keep the JavaScript ecosystem healthy, reliable, and secure, every time you make significant updates to an npm package you own, we recommend publishing a new version of the package with an updated version number in the package.json file that follows the semantic versioning spec. Following the semantic versioning spec helps other developers who depend on your code understand the extent of changes in a given version, and adjust their own code if necessary.
Note: If you introduce a change that breaks a package dependency, we strongly recommend incrementing the version major number; see below for details.
To help developers who rely on your code, we recommend starting your package version at 1.0.0 and incrementing as follows:
You can specify which update types your package can accept from dependencies in your package's package.json file.
For example, to specify acceptable version ranges up to 1.0.4, use the following syntax:
For more information on semantic versioning syntax, see the npm semver calculator.
Distribution tags (dist-tags) are human-readable labels that you can use to organize and label different versions of packages you publish. dist-tags supplement semantic versioning. In addition to being more human-readable than semantic version numbering, tags allow publishers to distribute their packages more effectively.
For more information, see the dist-tag CLI documentation.
Note: Since dist-tags share a namespace with semantic versions, avoid dist-tags that conflict with existing version numbers. We recommend avoiding dist-tags that start with a number or the letter "v".
By default, running npm publish will tag your package with the latest dist-tag. To use another dist-tag, use the --tag flag when publishing.
On the command line, navigate to the root directory of your package.
Run the following command, replacing <tag> with the tag you want to use:
To publish a package with the "beta" dist-tag, on the command line, run the following command in the root directory of your package:
On the command line, navigate to the root directory of your package.
Run the following command, replacing <package_name> with the name of your package, <version> with your package version number, and <tag> with the distribution tag:
To add the "stable" tag to the 1.4.0 version of the "example-package" package, you would run the following command:
You can change the visibility of a scoped package from the website or command line.
You must be the owner of the user account or organization that owns the package in order to change package visibility.
For more information about package visibility, see "Package scope, access level, and visibility".
Note: You cannot change the visibility of an unscoped package. Only scoped packages with a paid subscription may be private.
Note: Making a package private requires a paid user account or organization. To sign up for a paid user or organization, go to https://www.npmjs.com/settings/account-name/billing, replacing account-name with the name of your npm user account or organization.
If you want to restrict access and visibility for a public package you own, you can make the package private. When you make a package private, its access will be updated immediately and it will be removed from the website within a few minutes of the change.
To make a public package private on the command line, run the following command, replacing <package-name> with the name of your package:
For more information, see the npm access documentation.
Note: When you make a private package public, the package will be visible to and downloadable by all npm users.
To make a private package public on the command line, run the following command, replacing <package-name> with the name of your package:
For more information, see the npm access CLI documentation.
As an npm user with a paid user account, you can add another npm user with a paid account as a collaborator on a private package you own.
Note: The user you want to add as a collaborator on your private package must have a paid user account. To sign up for a paid account, they can visit https://www.npmjs.com/settings/username/billing, replacing username with their npm username.
When you add a member to your package, they are sent an email inviting them to the package. The new member has to accept the invitation to gain access to the package.
To add a collaborator to a package on the command line, run the following command, replacing <user> with the npm username of your collaborator, and <your-package-name> with the name of the private package:
To grant an npm user access to private organization packages, you must have an organization owner add them to your organization, then add them to a team that has access to the private package. For more information, see "Adding members to your organization".
When you make significant changes to a published package, we recommend updating the version number to communicate the extent of the changes to others who rely on your code.
Note: If you have linked a git repository to a package, updating the package version number will also add a tag with the updated release number to the linked git repository.
To change the version number in package.json, on the command line, in the package root directory, run the following command, replacing <update_type> with one of the semantic versioning release types (patch, major, or minor):
Run npm publish.
Go to your package page (https://npmjs.com/package/<package>) to check that the package version has been updated.
For more information on npm version, see the CLI documentation.
If you no longer wish to maintain a package, or if you would like to encourage users to update to a new or different version, you can deprecate it. Deprecating a package or version will print a message to the terminal when a user installs it.
A deprecation warning or message can say anything. You may wish to include a message encouraging users to update to a specific version, or an alternate, supported package.
Note: We strongly recommend deprecating packages or package versions instead of unpublishing them, because unpublishing removes a package from the registry entirely, meaning anyone who relied on it will no longer be able to use it, with no warning.
Deprecating an entire package will remove it from search results on the npm website and a deprecation message will also be displayed on the package page.
Deprecating a package is an alternative to deleting a package if your package does not meet the unpublishing requirements.
Navigate to the package page for the package you want to deprecate, replacing <your-package-name> with the name of your package: https://www.npmjs.com/package/<your-package-name>.
Click Settings.
Under "deprecate package", click Deprecate package.
If you are sure that you want to continue, enter your package name and click Deprecate package.
To deprecate an entire package, run the following command, replacing <package-name> with the name of your package, and "<message>" with your deprecation message:
If you have enabled two-factor authentication, add a one-time password to the command, --otp=123456 (where 123456 is the code from your authenticator app).
When you deprecate a version of a package, a red message will be displayed on that version's package page, similar to deprecating an entire package.
To deprecate a package version, run the following command, replacing <package-name> with the name of your package, <version> with your version number, and "<message>" with your deprecation message:
The CLI will also accept version ranges for <version>.
If you have two-factor auth, add a one-time password to the command, --otp=123456 (where 123456 is the code from your authenticator).
To undeprecate a package, replace "<message>" with "" (an empty string) in one of the above commands.
For example, to undeprecate a package version, run the following command, replacing <package-name> with the name of your package, and <version> with your version number:
If you have two-factor auth, add a one-time password to the command, --otp=123456 (where 123456 is the code from your authenticator).
If you are no longer maintaining a package, but other users depend on it, and you'd like to remove it from your user profile, you can transfer it to the @npm user account, which is owned by the npm registry.
Note: Once you transfer a package to the npm account, you will no longer be able to update it.
To transfer a package to the npm user account, run the following two commands in order, replacing <user> with your npm user name, and <package-name> with the package you want to transfer:
If you have two-factor auth, add a one-time password to the command, --otp=123456 (where 123456 is the code from your authenticator).
As a package owner or maintainer, you can transfer ownership of a package you no longer wish to maintain to another trusted npm user using either the npm website or the command line.
For more information on how npm support handles package name disputes between users, you can refer to npm's package name dispute policy.
Note: You cannot transfer a scoped package to another user account or organization, because a package's scope is the user account or organization name. You will need to create a new package in the new scope.
To transfer a package you own or maintain to another user, follow these steps:
Navigate to the package page for the package you want to transfer, replacing <your-package-name> with the name of your package: https://www.npmjs.com/package/<your-package-name>.
On the package Admin tab, under "Maintainers", enter the npm username of the new maintainer.
Click "Invite."
To remove yourself as a maintainer, under the maintainers list, click the "x" next to your username.
To transfer a package to another npm user using the CLI, run the npm owner add command replacing <their-username> with the other user's npm username. An email invitation is sent to the other user. After the user has accepted the invitation, run the npm owner rm command replacing <your-username> with your npm username:
If you have two-factor authentication enabled for writes, add a one-time password to the command, --otp=123456 (where 123456 is the code from your authenticator application).
As a package owner or collaborator, if your package has no dependents, you can permanently remove it from the npm registry by using the CLI. You can unpublish within 72 hours of the initial publish; beyond 72 hours, you can still unpublish your package if it meets certain criteria.
These criteria are set to avoid damaging the JavaScript package ecosystem. If you cannot unpublish your package, you can deprecate it instead.
Note: Removing all the collaborators or teams from the package will not unpublish it.
If you want to completely remove all versions of a package from the registry, you can unpublish it completely. This will delete it from the registry and it will be unable to be installed.
To unpublish a package, you must meet the requirements of the package unpublishing rules.
Navigate to the package page for the package you want to unpublish, replacing <your-package-name> with the name of your package: https://www.npmjs.com/package/<your-package-name>.
Click Settings.
Under "delete package", click Delete package.
Note: If you cannot delete the package because it does not meet the unpublishing requirements, then the delete package option will not be available. Instead, you will be prompted to deprecate the package.
If you are sure that you want to continue, enter your package name and click Delete package.
To unpublish an entire package, run the following command, replacing <package-name> with the name of your package:
If you have two-factor authentication enabled for writes, you will need to add a one-time password to the unpublish command, --otp=123456 (where 123456 is the code from your authenticator app).
If you need help unpublishing your package, please contact npm Support. If you are an Enterprise customer, please contact Enterprise Support.
Note: If you unpublish an entire package, you may not publish any new versions of that package until 24 hours have passed.
If you want to remove a single version of a package, you can unpublish one version without affecting the others. This will delete only that version from the registry and it will be unable to be installed. This option is only available via the npm CLI.
To unpublish a single version of a package, run the following command, replacing <package-name> with the name of your package, and <version> with your version number:
Unpublishing a package permanently removes the package from the registry so it is no longer available for other users to install. Once a package is unpublished, republishing under the same name is blocked for 24 hours. If you've unpublished a package by mistake, we'd recommend publishing again under a different name, or for unpublished versions, bumping the version number and publishing again.
You might want to unpublish a package because you:
Note: package-name@version is unique, and cannot be reused by unpublishing and re-publishing it. We recommend publishing a minor version update instead.
If you are no longer interested in maintaining a package, but want it to remain available for users to install, or if your package has dependents, we'd recommend deprecating it. To learn about how to deprecate a package, see "Deprecating and undeprecating packages or package versions".
You can use the npm search bar to find packages to use in your projects. npm search uses npms and the npms analyzer; for more information on both, see https://npms.io/about.
In the search bar, type a search term and press Enter. As you type, possible choices will appear.
To list packages ranked according to package search rank criteria, in the left sidebar, under "Sort packages", click the criterion. For example, to sort packages by popularity, click "Popularity".
In the package search results list, click the name of the package.
Often, there are dozens or even hundreds of packages with similar names and/or similar purposes. To help you decide the best ones to explore, each package has been ranked according to four criteria using the npms analyzer:
Popularity indicates how many times the package has been downloaded. This is a strong indicator of packages that others have found to be useful.
Quality includes considerations such as the presence of a README file, stability, tests, up-to-date dependencies, custom website, and code complexity.
Maintenance ranks packages according to the attention they are given by developers. More frequently maintained packages are more likely to work well with the current or upcoming versions of the npm CLI, for example.
Optimal combines the other three criteria (popularity, quality, maintenance) into one score in a meaningful way.
When packages have been published with provenance, you can:
You can use this information to audit packages and determine whether or not you want to consume them. For more information about npm provenance, see "About npm provenance."
To view provenance information for a package in the npm registry:
In the npm registry, navigate to a package.
On the package's page, in the Version field to the right of the README, look for a green check mark. If there is a green check mark, this means the package was published with provenance.
Click on the check mark, then click View more details.
View the following information for the package:
Note: Whenever you access a package's provenance information on npmjs.com, the linked source commit and repository are checked by npm. If the linked source commit or repository cannot be found, an error message will appear at the top of the page and alongside the provenance information. This is to inform you that the provenance for this package can no longer be established, which may occur when a repository is deleted or made private.
When you download a package from the registry, you can verify the provenance of a package with the following CLI command:
This command checks the registry signatures and provenance attestations. If a package has missing or invalid signatures or attestations, it returns an error. This could indicate that a package has been tampered with.
Note: In order to run the audit command to verify package provenance, you must:
You can install a package locally if you want to depend on the package from your own module, using something like Node.js require. This is npm install's default behavior.
Unscoped packages are always public, which means they can be searched for, downloaded, and installed by anyone. To install a public package, on the command line, run
This will create the node_modules directory in your current directory (if one doesn't exist yet) and will download the package to that directory.
Note: If there is no package.json file in the local directory, the latest version of the package is installed.
If there is a package.json file, npm installs the latest version that satisfies the semver rule declared in package.json.
Scoped public packages can be downloaded and installed by anyone, as long as the scope name is referenced during installation:
Private packages can only be downloaded and installed by those who have been granted read access to the package. Since private packages are always scoped, you must reference the scope name during installation:
To confirm that npm install worked correctly, in your module directory, check that a node_modules directory exists and that it contains a directory for the package(s) you installed:
If there is a package.json file in the directory in which npm install is run, npm installs the latest version of the package that satisfies the semantic versioning rule declared in package.json.
If there is no package.json file, the latest version of the package is installed.
Like npm publish, npm install <package_name> will use the latest tag by default.
To override this behavior, use npm install <package_name>@<tag>. For example, to install the example-package at the version tagged with beta, you would run the following command:
Tip: If you are using npm 5.2 or higher, we recommend using npx to run packages globally.
Installing a package globally allows you to use the code in the package as a set of tools on your local computer.
To download and install packages globally, on the command line, run the following command:
If you get an EACCES permissions error, you may need to reinstall npm with a version manager or manually change npm's default directory. For more information, see "Resolving EACCES permissions errors when installing packages globally".
If you see an EACCES error when you try to install a package globally, you can either:
Reinstall npm with a node version manager (recommended),
or
Manually change npm's default directory
This is the best way to avoid permissions issues. To reinstall npm with a node version manager, follow the steps in "Downloading and installing Node.js and npm". You do not need to remove your current version of npm or Node.js before installing a node version manager.
Note: This section does not apply to Microsoft Windows.
To minimize the chance of permissions errors, you can configure npm to use a different directory. In this example, you will create and use hidden directory in your home directory.
Back up your computer.
On the command line, in your home directory, create a directory for global installations:
Configure npm to use the new directory path:
In your preferred text editor, open or create a ~/.profile file and add this line:
On the command line, update your system variables:
To test your new configuration, install a package globally without using sudo:
Instead of steps 3-5, you can use the corresponding ENV variable (e.g. if you don't want to modify ~/.profile):
npx: an alternative to running global commands
If you are using npm version 5.2 or greater, you may want to consider npx as an alternative way to run global commands, especially if you only need a command occasionally. For more information, see this article about npx.
Updating local and global packages you downloaded from the registry helps keep your code and tools stable, usable, and secure.
We recommend regularly updating the local packages your project depends on to improve your code as improvements to its dependencies are made.
Navigate to the root directory of your project and ensure it contains a package.json file:
In your project root directory, run the update command:
To test the update, run the outdated command. There should not be any output.
Note: If you are using npm version 2.6.0 or less, run this script to update all outdated global packages.
However, please consider upgrading to the latest version of npm:
To see which global packages need to be updated, on the command line, run:
To update a single global package, on the command line, run:
To update all global packages, on the command line, run:
Once you have installed a package in node_modules, you can use it in your code.
If you are creating a Node.js module, you can use a package in your module by passing it as an argument to the require function.
In package.json, list the package under dependencies. You can optionally include a semantic version.
To use a scoped package, simply include the scope wherever you use the package name.
In package.json:
If you have not properly installed a package, you will receive an error when you try to use it in your code. For example, if you reference the lodash package without installing it, you would see the following error:
If you install a package, and it prints a deprecation message, we recommend following the instructions, if possible.
That might mean updating to a new version, or updating your package dependencies.
A deprecation message doesn't always mean the package or version is unusable; it may mean the package is unmaintained and will no longer be updated by the publisher.
If you no longer need to use a package in your code, we recommend uninstalling it and removing it from your project's dependencies.
To remove a package from your node_modules directory, on the command line, use the uninstall command. Include the scope if the package is scoped.
This uninstalls a package, completely removing everything npm installed on its behalf.
It also removes the package from the dependencies, devDependencies, optionalDependencies, and peerDependencies objects in your package.json.
Further, if you have an npm-shrinkwrap.json or package-lock.json, npm will update those files as well.
Using the --no-save will tell npm not to remove the package from your package.json, npm-shrinkwrap.json, or package-lock.json files.
--save or -S will tell npm to remove the package from your package.json, npm-shrinkwrap.json, and package-lock.json files. This is the default, but you may need to use this if you have for instance save=false in your .npmrc file.
To confirm that npm uninstall worked correctly, check that the node_modules directory no longer contains a directory for the uninstalled package(s).
To uninstall an unscoped global package, on the command line, use the uninstall command with the -g flag. Include the scope if the package is scoped.
For example, to uninstall a package called jshint, run:
Audit reports contain tables of information about security vulnerabilities in your project's dependencies to help you fix the vulnerability or troubleshoot further.
The severity of the vulnerability, determined by the impact and exploitability of the vulnerability in its most common use case.
The description of the vulnerability. For example, "Denial of service".
The name of the package that contains the vulnerability.
The semantic version range that describes which versions contain a fix for the vulnerability.
The module that the package with the vulnerability depends on.
The path to the code that contains the vulnerability.
A link to the security report.
A security audit is an assessment of package dependencies for security vulnerabilities. Security audits help you protect your package's users by enabling you to find and fix known vulnerabilities in dependencies that could cause data loss, service outages, unauthorized access to sensitive information, or other issues.
Note: The npm audit command is available in npm@6. To upgrade, run npm install npm@latest -g.
The npm audit command submits a description of the dependencies configured in your package to your default registry and asks for a report of known vulnerabilities. npm audit checks direct dependencies, devDependencies, bundledDependencies, and optionalDependencies, but does not check peerDependencies.
npm audit automatically runs when you install a package with npm install. You can also run npm audit manually on your locally installed packages to conduct a security audit of the package and produce a report of dependency vulnerabilities and, if available, suggested patches.
npm audit requires packages to have package.json and package-lock.json files.
Running npm audit will produce a report of security vulnerabilities with the affected package name, vulnerability severity and description, path, and other information, and, if available, commands to apply patches to resolve vulnerabilities. For more information on the fields in the audit report, see "About audit reports"
If security vulnerabilities are found and updates are available, you can either:
If the recommended action is a potential breaking change (semantic version major change), it will be followed by a SEMVER WARNING that says "SEMVER WARNING: Recommended action is a potentially breaking change". If the package with the vulnerability has changed its API, you may need to make additional changes to your package's code.
If security vulnerabilities are found, but no patches are available, the audit report will provide information about the vulnerability so you can investigate further.
To address the vulnerability, you can
Review the security advisory in the "More info" field for mitigating factors that may allow you to continue using the package with the vulnerability in limited cases. For example, the vulnerability may only exist when the code is used on specific operating systems, or when a specific function is called.
If a fix exists but packages that depend on the package with the vulnerability have not been updated to include the fixed version, you may want to open a pull or merge request on the dependent package repository to use the fixed version.
If a fix does not exist, you may want to suggest changes that address the vulnerability to the package maintainer in a pull or merge request on the package repository.
If you do not want to fix the vulnerability or update the dependent package yourself, open an issue in the package or dependent package issue tracker.
If no security vulnerabilities are found, this means that packages with known vulnerabilities were not found in your package dependency tree. Since the advisory database can be updated at any time, we recommend regularly running npm audit manually, or adding npm audit to your continuous integration process.
To turn off npm audit when installing a single package, use the --no-audit flag:
For more information, see the npm-install command.
To turn off npm audit when installing all packages, set the audit setting to false in your user and global npmrc config files:
For more information, see the npm-config management command and the npm-config audit setting.
You can generate provenance statements for the packages you publish. This allows you to publicly establish where a package was built and who published a package, which can increase supply-chain security for your packages.
npm provenance includes two types of attestations:
The provenance attestation is established by publicly providing a link to a package's source code and build instructions from the build environment. This allows developers to verify where and how your package was built before they download it.
Publish attestations are generated by the registry when a package is published by an authorized user. When an npm package is published with provenance, it is signed by Sigstore public good servers and logged in a public transparency ledger, where users can view this information.
Sigstore is a collection of tools and services aimed at making it easy to use short-lived, ephemeral certificates to sign software. Its three main components are a CLI tool, a certificate authority, and a time-stamping transparency log.
The certificate authority federates with any OIDC provider that includes verifiable build information. It acts as an intermediary between build systems and package registries by verifying the integrity of the OIDC token, issues a signing certificate that contains that build information, and then logging the signing certificate to an immutable ledger.
The transparency log service provides a public, verifiable, tamper-evident ledger of signed attestations. This ensures transparency of the public service, as well as providing a way to detect attempts to tamper with a package if a package registry were to be compromised.
Before you can publish your packages with provenance, you must:
Review the Linux Foundation Immutable Record notice, which applies to the public transparency log.
Install the latest version of the npm CLI (ensure you are on 9.5.0+ as older versions don't support npm provenance). For more information, see "Try the latest stable version of npm."
Ensure your package.json is configured with a public repository that matches where you are publishing with provenance from.
Set up automation with a supported CI/CD provider to publish your packages to the npm registry. The following providers are supported:
In order to establish provenance, you must use a supported cloud CI/CD provider and a cloud-hosted runner to publish your packages. GitHub Actions is a supported CI/CD platform that allows you to automate software development tasks. For more information, see GitHub Actions in the GitHub documentation.
To update your GitHub Actions workflow to publish your packages with provenance, you must:
Give permission to mint an ID-token:
Run on a GitHub-hosted runner:
Add the --provenance flag to your publish command:
If you are publishing a package for the first time you will also need to explicitly set access to public:
This example workflow publishes a package to the npm registry with provenance.
This example job publishes a package to the npm registry with provenance when a git tag is pushed. Don’t forget to define the NPM_TOKEN variable in your GitLab project settings.
If you publish your packages with tools that do not directly invoke the npm publish command, you can do one of the following in your GitHub Actions workflow to publish your packages with provenance.
Note: At this time, yarn is not a supported tool for publishing your packages with provenance.
In order to establish provenance, you must use a supported cloud CI/CD provider and a cloud-hosted runner to publish your packages. GitLab CI/CD is a supported CI/CD platform that allows you to automate software development tasks. For more information, see Generating provenance in GitLab CI/CD in the GitLab documentation.
Packages published to the public npm registry are signed to make it possible to detect if the package content has been tampered with.
Signing and verifying published packages protects against an attacker controlling a registry mirror or proxy where they attempt to intercept and tamper with the package tarball content.
Note: PGP-based registry signatures were deprecated on April 25th 2023 and replaced by ECDSA registry signatures.
The public npm registry is migrating away from the existing PGP signatures to ECDSA signatures that are more compact and can be verified without extra dependencies in the npm CLI.
Signature verification was previously a multi-step process involving the Keybase CLI, as well as manually retrieving and parsing the signature from the package metadata.
Read more about migrating and verifying signatures using the npm CLI.
The npm CLI supports registry signatures and signing keys provided by any registry if the following conventions are followed:
1. Signatures are provided in the package's packument in each published version within the dist object:
See this example of a signed package from the public npm registry.
To generate the signature, sign the package name, version and tarball sha integrity: ${package.name}@${package.version}:${package.dist.integrity}.
The current best practice is to use a Key Management System that does the signing operation on a Hardware Security Module (HSM) in order to not directly handle the private key part, which reduces the attack surface.
The keyid must match one of the public signing keys below.
2. Public signing keys are provided at registry-host.tld/-/npm/v1/keys in the following format:
Keys response:
See this example key's response from the public npm registry.
To ensure the integrity of packages you download from the public npm registry, or any registry that supports signatures, you can verify the registry signatures of downloaded packages using the npm CLI.
Registry signatures can be verified using the following audit command:
Example response if all installed versions have valid registry signatures:
The CLI will error if packages don't have signatures and if the package registry supports signatures. This could mean an attacker might be trying to circumvent signature verification. You can check if the registry supports signatures by requesting the public signing keys from registry-host.tld/-/npm/v1/keys.
Example response if some versions have missing registry signatures:
To protect your packages, as a package publisher, you can require everyone who has write access to a package to have two-factor authentication (2FA) enabled. This will require that users provide 2FA credentials in addition to their login token when they publish the package. For more information, see "Configuring two-factor authentication".
You may also choose to allow publishing with either two-factor authentication or with automation tokens. This lets you configure automation tokens in a CI/CD workflow, but requires two-factor authentication from interactive publishes.
Navigate to the package on which you want to require a second factor to publish or modify settings.
Click Settings.
Under "Publishing access", select the requirements to publish a package.
Dont require two-factor authentication
With this option, a maintainer can publish a package or change the package settings whether they have two-factor authentication enabled or not. This is the least secure setting.
Require two-factor authentication or automation tokens or granular access token
With this option, maintainers must have two-factor authentication enabled for their account. If they publish a package interactively, using the npm publish command, they will be required to enter 2FA credentials when they perform the publish. However, maintainers may also create an automation token or a granular access token and use that to publish. A second factor is not required when using a token, making it useful for continuous integration and continuous deployment workflows.
Require two-factor authentication and disallow tokens
With this option, a maintainer must have two-factor authentication enabled for their account, and they must publish interactively. Maintainers will be required to enter 2FA credentials when they perform the publish. Automation tokens and granular access tokens cannot be used to publish packages.
Click Update Package Settings.
If you find malware in an npm package (either yours or someone else's), you can report it to the npm Security team to help keep the Javascript ecosystem safe.
Note: Vulnerabilities in npm packages should be reported directly to the package maintainers. We strongly advise doing this privately. You can find contact information about package maintainers with npm owner ls <package-name>. If the source code is hosted on GitHub please refer to the repository's Security Policy.
Malware is a major concern for npm Security and we have removed hundreds of malicious packages from the registry. For every malware report we receive, npm Security takes the following actions:
As part of our process we determine whether the user account who uploaded the package should be banned. We also cooperate with 3rd parties when applicable.
Note: You must be using npm version 5.5.1 or greater to use access tokens.
An access token is an alternative to using your username and password for authenticating to npm when using the API or the npm command-line interface (CLI). An access token is a hexadecimal string that you can use to authenticate, and which gives you the right to install and/or publish your modules.
There are two types of access tokens available:
You can create access tokens to give other tools (such as continuous integration testing environments) access to your npm packages. For example, GitHub Actions provides the ability to store secrets, such as access tokens, that you can then use to authenticate. When your workflow runs, it will be able to complete npm tasks as you, including installing private packages you can access.
You can work with tokens from the web or the CLI, whichever is easiest. What you do in each environment will be reflected in the other environment.
npm token commands let you:
For more information on creating and viewing access tokens on the web and CLI, see "Creating and viewing access tokens".
Legacy tokens are created with the same permissions as the user who created them. The npm CLI automatically generates and uses a publish token when you run npm login.
There are three different types of legacy tokens:
Legacy tokens do not have an expiration date. It is important to be aware of your tokens and keep them protected for account security. For more information, see "Securing your token."
Granular access tokens allow you to restrict access provided to the token based on what you want to use the token for. With granular access tokens, you can:
You can create up to 1000 granular access tokens on your npm account. You can set how long your token is valid for, at least one day in the future. Each token can access up to 50 organizations, and up to either 50 packages, 50 scopes, or a combination of 50 packages and scopes. Access tokens are tied to users’ permission; hence it cannot have more permission than the user at any point in time. If a user has their access revoked from a package or an org., their granular access token also will have its access revoked from those packages or org.
When you give a token access to an organization, the token can only be used for managing organization settings and teams or users associated with the organization. It does not give the token the right to publish packages managed by the organization.
You can create and view access tokens from the website and command line interface (CLI).
Note: For greater security, we recommend using granular access tokens instead of legacy read-only tokens or legacy automation tokens.
In the upper right corner of the page, click your profile picture, then click Access Tokens.
Click Generate New Token, then select legacy token from the dropdown menu.
(Optional) Name your token.
Select the type of access token:
Read-only: A read-only token can only be used to download packages from the registry. It will have permission to read any private package that you have access to. This is recommended for automation and workflows where you are installing packages, but not publishing new ones.
Automation: An automation token can download packages and publish new ones, but if you have two-factor authentication (2FA) configured on your account, it will not be enforced. You can use an automation token in continuous integration workflows and other automation systems to publish a package even when you cannot enter a one-time passcode.
Publish: A publish token can perform any action on your behalf, including downloading packages, publishing packages, and changing user settings or package settings. If you have two-factor authentication configured on your account, you will be required to enter a one-time passcode when using a publish token. This is recommended for interactive workflows such as a CLI.
Click Generate Token.
Copy the token from the top of page.
In the upper right corner of the page, click your profile picture, then click Access Tokens.
Click Generate New Token, then click Granular Access Token.
In the Token name field, enter a name for your token.
(Optional) In the Description field, enter a description for your token.
In the Expiration field, enter a token expiration period. The date must be at least 1 day in the future.
(Optional) In the Allowed IP Ranges field, enter IP address ranges to restrict your access token to. You must use CIDR notation to enter IP address ranges. To add more than one allowed IP range, click Add IP Range and enter an IP range in the new text field.
(Optional) In the Packages and scopes section, configure your token's access to packages and scopes.
(Optional) In the Organizations section, configure your token's access to organizations.
Note: When you give a token access to an organization, the token can only be used for managing organization settings and teams or users associated with the organization. It does not give the token the right to publish packages managed by the organization.
Review the token summary, then click Generate Token.
Copy the token from the top of page.
You can create tokens with read-only permissions or read and publish permissions with the CLI.
Note: You cannot create legacy automation tokens or granular access tokens from the CLI. You must use the website to generate these types of tokens. For more information, see "Creating legacy tokens on the website" and "Creating granular access tokens on the website."
In addition, you can specify that the token is only valid for a specific IPv4 address range, using CIDR notation. The token will only be valid when used from the specified IP addresses.
If the CIDR string you enter is invalid or in an inappropriate format, you will get an error similar to the one below:
Make sure you are using a valid IPv4 range and try creating the token again.
Note: Full tokens are never displayed, only the first and last four characters will be shown. You can only view a full token immediately after creation.
To view all tokens associated with your account, in the upper right corner of the page, click your profile picture, then click Access Tokens.
To view all tokens associated with your account, on the command line, run the following command:
To keep your account and packages secure, we strongly recommend revoking (deleting) tokens you no longer need or that have been compromised. You can revoke any token you have created.
To see a list of your tokens, on the command line, run:
In the tokens table, find and copy the ID of the token you want to delete.
On the command line, run the following command, replacing 123456 with the ID of the token you want to delete:
npm will report Removed 1 token
To confirm that the token has been removed, run:
Note: You must use the token ID to delete a token, not the truncated version of the token. In some cases, there may be a delay of up to an hour before a token is successfully revoked.
You can use access tokens to test private npm packages with continuous integration (CI) systems, or deploy them using continuous deployment (CD) systems.
Create a new access token that will be used only to access npm packages from a CI/CD server.
When generating an access token for use in a continuous integration environment, we recommend using a granular access token with limited access to provide greater security.
If you use a legacy token instead, by default, npm token create will generate a token with both read and write permissions. We recommend creating a read-only token:
For more information on creating access tokens, including CIDR-whitelisted tokens, see "Creating an access token".
Since continuous deployment environments usually involve the creation of a deploy artifact, you may wish to create an automation token on the website. This will allow you to publish even if you have two-factor authentication enabled on your account.
If your workflow produces a package, but you publish it manually after validation, then you will want to create a token with read and write permissions, which are granted with the standard token creation command:
For increased security, you may use a CIDR-whitelisted token that can only be used from a certain IP address range. You can use a CIDR whitelist with a read and publish token or a read-only token:
Example:
For more information, see "Creating and viewing authentication tokens".
Set your token as an environment variable, or a secret, in your CI/CD server.
For example, in GitHub Actions, you would add your token as a secret. Then you can make the secret available to workflows.
If you named the secret NPM_TOKEN, then you would want to create an environment variable named NPM_TOKEN from that secret.
Consult your CI/CD server's documentation for more details.
Use a project-specific .npmrc file with a variable for your token to securely authenticate your CI/CD server with npm.
In the root directory of your project, create a custom .npmrc file with the following contents:
Note: that you are specifying a literal value of ${NPM_TOKEN}. The npm cli will replace this value with the contents of the NPM_TOKEN environment variable. Do not put a token in this file.
Check in the .npmrc file.
Your token may have permission to read private packages, publish new packages on your behalf, or change user or package settings. Protect your token.
Do not add your token to version control or store it insecurely. Store it in a password manager, your cloud provider's secure storage, or your CI/CD provider's secure storage.
When possible, use granular access tokens with the minimum permissions necessary, and set short expiration dates for your tokens. For more information, see "About access tokens."
To install private npm packages in a Docker container, you will need to use Docker build secrets.
You cannot install private npm packages in a Docker container using only runtime variables. Consider the following Dockerfile:
Which will use the official Node.js image, copy the package.json into our container, installs dependencies, copies the source files and runs the start command as specified in the package.json.
In order to install private packages, you may think that we could just add a line before we run npm install, using the ENV parameter:
However, this doesn't work as you would expect, because you want the npm install to occur when you run docker build, and in this instance, ENV variables aren't used, they are set for runtime only.
Instead of run-time variables, you must use Docker build secrets.
The Dockerfile that takes advantage of this has a few more lines in it than the earlier example that allows us to use your global .npmrc and the access token created when running npm login command (if you haven't run it already - do so before moving on).
This will configure your Dockerfile to receive .npmrc file via build secrets, that will leave no trace after npm dependency installation is done.
To build the image using the above Dockerfile and the npm authentication token, you can run the following command. Note the . at the end to give docker build the current directory as an argument.
This will build the Docker image with the access token coming from your global .npmrc file received via build secrets, so you can run npm install inside your container as the current logged-in user.
Note: You may need to specify a working directory different from the default / otherwise some frameworks like Angular will fail.
Any npm user can create an organization to manage contributor access to packages governed by the organization.
Note: You need an npm user account to create an organization. To create a user account, visit the account signup page".
On the organization creation page, in the Name field, type a name for your organization. Your organization name will also be your organization scope.
Under the Name field, choose either the "Unlimited private packages" paid plan or the "Unlimited public packages" free plan and click Buy or Create.
(Optional) On the organization invitation page, type the npm username or email address of a person you would like to add to your organization as a member and select a team to invite them to, then click Invite.
Click Continue.
If you have an npm user account, you can convert your user account to an organization. When you convert your user account to an organization, we will:
Note: Once your old user account has been converted to an organization, you will no longer be able to sign in to npm with your old user account.
Below the account creation form, click Convert.
Review the account conversion steps and click Continue.
On the new user account creation page, in the "Username" field, type the name of your new user account, then click Submit.
On the plan selection page, select either the "Unlimited private packages" paid plan or the "Unlimited public packages" free plan, then click Buy or Create.
If you selected to use the unlimited private packages plan, in the payment dialog, provide the email, name, address, and credit card information for the card that will be used to pay for the organization.
Organization owners can require organization members to enable two-factor authentication for their personal accounts, making it harder for malicious actors to access an organization's packages and settings
Two-factor authentication (2FA) is an extra layer of security used when logging into websites or apps. You can require all members in your organization to enable two-factor authentication on npm. For more information about two-factor authentication, see "Configuring two-factor authentication.".
Note:
Before you can require organization members to use two-factor authentication, you must enable two-factor authentication for your account on npm. For more information, see "Configuring two-factor authentication.".
Before you require use of two-factor authentication, we recommend notifying organization members and asking them to set up 2FA for their accounts. You can see if members already use 2Fa in the organizations members page.
Click the Enable 2FA Enforcement button.
If prompted, read the information about members who will be removed from the organization. Type your organization's name to confirm the change, then click Remove members & require two-factor authentication.
If any members are removed from the organization, we recommend sending them an invitation that can reinstate their former privileges and access to your organization. They must enable two-factor authentication before they can accept your invitation.
If any members are removed from the organization when you enable required use of two-factor authentication, they'll receive an email notifying them that they've been removed. They should then enable 2FA for their personal account, and contact an organization owner to request access to your organization.
Organizations cannot be renamed from the website or command line interface.
To rename an organization, as an organization owner, you must manually migrate your existing organization members, teams, and packages to a new organization, then contact npm Support to have the outdated packages unpublished and the previous organization deleted.
An organization administrator can delete the organization; packages in the organization will also be deleted if they fulfill the requirements to unpublish packages. Packages that cannot be deleted can be deprecated instead.
In the left sidebar, click the name of the organization that you want to delete.
Under "delete organization", click Delete.
You will be given an overview of the packages in your organization and what will happen to them when your organization is deleted. Packages that can be unpublished will be deleted.
If you are sure that you want to continue, enter your organization name and click Delete this organization.
Note: This article only applies to users of the public npm registry.
As an organization owner, you can upgrade your free organization plan to the npm Teams product. npm Teams is a paid plan to give organization members the ability to install and publish private packages. For more information about npm Teams and our organization pricing plans, see the "npm Teams" section of our pricing page.
If you have an organization with a private packages plan, your organization will cost you seven (7) dollars a month per user. The $7 charge is a flat fee for any member of the organization even if the teams the member belongs do not have access to private packages
Newly added members to an organization are always billed during the next billing cycle. For more information, see "Adding members to your organization".
Note: Your paid plan and billing cycle will start when you submit your credit card information, and you will be charged for the first month immediately.
In the left sidebar, click the name of the organization you want to upgrade.
Under "change plan", click Upgrade Plan ($7/User).
Under "Want to upgrade?", click Enable Private Publishing for $7/mo.
Click Pay for the monthly amount. The monthly amount will be the number of members in your organization multiplied by $7.
Note: This article only applies to users of the public npm registry.
As an organization owner, you can view, download, and email receipts for the complete billing history of your organization.
In the left sidebar, click the name of the organization whose billing receipts you want to view.
To view a single receipt, find the row of the receipt you want to view, then, on the right side of the row, click the view icon.
In the left sidebar, click the name of the organization whose billing receipts you want to download.
In the left sidebar, click the name of the organization whose billing receipts you want to email.
Click Send.
Note: This article only applies to users of the public npm registry.
As an owner of an npm Teams subscription, a paid organization plan, you can update the credit card used to pay for your plan. Updating your credit card will not change your billing cycle date, and the new credit card will be charged on the next billing cycle.
In the left sidebar, click the name of the organization whose credit card information you want to change.
As an organization owner, you can update the email address used for receipts, and add extra information to the receipt for your paid organization plan, such as your business name, VAT identification number, or address of record. Updated billing information will appear on all receipts immediately.
Note: The billing email is used for receipts only and is not required to match the email address of the person whose card is used to pay for the organization.
In the left sidebar, click the name of the organization whose billing receipt information you want to change.
Note: This article only applies to users of the public npm registry.
If you are a subscriber to the npm Teams product (you have a paid organization) and you are an owner of the organization, then you can downgrade from npm Teams to a free organization. When you downgrade from a paid to a free organization, you and your organization members will lose the ability to install and publish private packages at the end of your last paid billing cycle. Your private packages will not be made publicly visible when you downgrade to a free plan.
Note: If you would like to pay for fewer seats, you can remove members from your organization by following the steps in "Removing members from your organization".
In the left sidebar, click the name of the organization you want to downgrade.
As an organization owner, you can add other npm users to your organization to give them read or read and write access to public and private packages within your organization's scope, as well as public unscoped packages governed by your organization.
When you add a member to your organization, they are sent an email inviting them to the organization.
Once the new member accepts the invitation, they are:
If you have a paid organization, as part of an npm Teams plan, you will be billed $7 per month for each new member.
Click the Invite Members button.
In the "Username or email" field, type the username or email address of the person you wish to invite. Optionally you can select a specific team to invite the member to.
Click Invite.
As an organization owner, if you've made a mistake in inviting someone to your organization, you can revoke the organization invitation.
Click the Invite Members button.
Under the "Invitations" field, click the X next to the name of the user invitation you would like to revoke.
If you receive an invitation to an organization, you have to accept the invitation over email to be added to the organization.
You have the option to use a different email address than the one that received the invitation to join the organization.
Click the verification link in the organization invitation email.
You will be prompted to log into your npm user account. If you don't have an npm user account, you can sign up for one.
If you are invited to an organization that you do not want to join, you can let the invitation expire. Organization invitations expire after one week.
There are three roles in an organization:
As an organization owner, you can change the role of any member of your organization to add or remove permissions on the organization for that member.
In the list of organization members, find the member whose role you want to change.
In the member row, to select the new role of the organization member, click member, admin, or owner.
As an organization owner, you can remove members from your organization if they are no longer collaborating on packages owned or governed by your organization.
If you remove a member from an npm Teams subscription (a paid organization), then they will lose access to your organization's private packages, and the credit card on file for your organization will not be charged for them on the next billing cycle.
Note: Members are not notified when you remove them from your organization.
In the list of organization members, find the member you want to remove.
At the end of the member row, click X.
The "developers" team is automatically created when you create an organization. By default, the developers team has read/write access to all new packages created under the organization's scope.
If you create a new package under your organization's scope and you do not want members of the developers team to have read/write access to that package, an owner or admin can remove the developers team's access to that package. For more information, see "Managing team access to organization packages".
If an owner adds a new member to an organization and does not want that member to be on the developers team, an owner can remove them.
Note: The developers team can no longer be removed from an organization for the following reasons:
As an organization owner or team admin, you can create teams to manage access to sets of packages governed by your organization.
Note: Team names cannot be changed. To "rename" a team, you must delete the team and recreate it.
In the "Name" and "Description" fields, type a team name and helpful description. Team names must be lower case and cannot contain spaces or punctuation.
Click Create Team.
Note: New teams do not have members or package access by default. Once you create a team, add packages and members from the "Teams" tab.
As an organization owner or team admin, you can add organization members to teams to give them access to a specific set of packages governed by the organization.
Note: An npm user must be a member of your organization before you can add them to a team. To add a member to your organization, see "Adding members to your organization".
Beside the team you want to add members to, click Members.
In the "Username" field, type the npm username of the organization member you would like to add to your team.
Click + Add User.
Note: organization members are not notified when they are added to a team. We recommend telling the organization member you have added them to a team.
If you would like to manage the membership of your team from the command line interface (CLI), you can use:
For more information, see the CLI documentation on teams.
As an organization owner or team admin, you can remove organization members from teams if they no longer need access to packages accessible to the team.
In the list of team members, find the member you want to remove.
In the member row, to remove the member from the team, click X.
Note: Removing a member from a team, even if it is the only team they are a member of, will not remove them from the organization. To remove a member from the organization, see "Removing members from your organization".
As an organization owner or team admin, you can add or remove package access to or from teams in your organization.
Beside the team to which you want to add package access, click Packages.
On the "Add Packages" page, in the "Package" field, type the name of the package and select from the dropdown menu.
Click + Add Existing Package.
Beside the package name, click read or read/write to set the team permissions for the package.
As an organization owner or team admin, you can use the CLI access command to add package access to a team on the command line:
For more information, see "npm-access".
Beside the team from which you want to remove package access, click Packages.
Beside the name of the package from which you want to remove access, click x.
As an organization owner or team admin, you can also use the CLI access command to revoke package access from a team on the command line:
For more information, see "npm-access".
Beside the team from which you want to remove package access, click Packages.
Beside the package name, click read or read/write to set the team permissions for the package.
As an organization owner or team admin, you can change package access for a team from the command line:
For more information, see the npm-access CLI documentation.
As an organization owner or team admin, you can remove teams that no longer need access to a set of packages governed by your organization. Removing the team will not remove the team members or packages from your organization.
Beside the name of the team you want to remove, click X.
Note: You cannot remove the developers team, learn more about the developers team.
Every organization is granted an organization scope, a unique namespace for packages owned by the organization that matches the organization name. For example, an organization named "wombat" would have the scope @wombat.
You can use scopes to:
Packages in a scope must follow the same naming guidelines as unscoped packages.
While you are granted a scope by default when you create an organization, you can also use organizations to manage unscoped packages, or packages under a different scope (such as a user scope).
As an organization member, you can configure your npm client to:
Before configuring your npm client, you must install npm.
If you will be publishing packages with your organization's scope often, you can add your organization's scope to your global .npmrc configuration file.
Note: Setting the organization scope using the steps below will only set the scope for new packages; for existing packages, you will need to update the name field in package.json.
On the command line, run the following command, replacing <org-name> with the name of your organization:
For packages you do not want to publish with your organization's scope, you must manually edit the package's package.json to remove the organization scope from the name field.
On the command line, navigate to the package directory.
Run the following command, replacing <org-name> with the name of your organization:
By default, publishing a scoped package with npm publish will publish the package as private. If you are a member of an organization on the free organization plan, or are on the paid organization plan but want to publish a scoped package as public, you must pass the --access public flag:
You can set a single package to pass --access public to every npm publish command that you issue for that package.
On the command line, navigate to the package directory.
Run the following command:
You can set all packages to pass --access public to every npm publish command that you issue for that package.
Warning: Setting packages access to public in your global .npmrc will affect all packages you create, including packages in your personal account scope, as well as packages scoped to your organization.
On the command line, run the following command:
As an organization member, you can create and publish public and private packages within the organization's scope.
On the command line, make a directory with the name of the package you would like to create.
Navigate to the newly-created package directory.
To create an organization scoped package, on the command line, run:
To verify the package is using your organization scope, in a text editor, open the package's package.json file and check that the name is @your_org_name/<pkg_name>, replacing your_org_name with the name of your organization.
By default, npm publish will publish a scoped package as private.
By default, any scoped package is published as private. However, if you have an organization that does not have the Private Packages feature, npm publish will fail unless you pass the access flag.
On the command line, navigate to the package directory.
Run npm publish.
Private packages will say private below the package name on the npm website.
To publish an organization scoped package as public, use npm publish --access public.
On the command line, navigate to the package directory.
Run npm publish --access public.
Public packages will say public below the package name on the npm website.
npm, Inc. offers software and services under a few different licenses and terms of use.
License terms and notices for the npm command-line program can be found in the LICENSE file of the project's source code at https://www.github.com/npm/cli.
Free usage of https://www.npmjs.com, and the npm public registry are covered by the npm Open Source Terms at https://docs.npmjs.com/policies/open-source-terms. These terms include several important policies, including:
What npm considers acceptable package content.
npm's Code of Conduct, which includes our policy on harassment.
npm's Privacy Policy, which limits use and sharing of information about you collected by npm Services.
npm's policy on copyright including how to report violations thereof.
npm's Dispute Policy which addresses how to resolve disputes over the control of a package name, user name, or organization name in the Public Registry. This includes our policy on users "squatting" on these names.
Use of npm's trademarks is governed by our Trademark Policy. If you have concerns about your own trademark's use on npm please see our Disputes Policy.
npm's paid products, including the npm Solo and Orgs plans, are covered by the npm Paid Services Terms at https://docs.npmjs.com/policies/private-terms.
The npm Solo Payment Plan and the npm Orgs Payment Plan govern payment for these services.
 These npm Open Source terms of use (these Terms) govern access to and use of https://www.npmjs.com (the Website) as well as the "npm Public Registry" at https://registry.npmjs.org (the Public Registry). npm, Inc. (npm) operates each of those services. These terms refer to all of them together as npm Open Source.
npm last updated these npm Open Source Terms on March 10, 2022. You can review prior versions at https://github.com/npm/documentation/blob/main/content/policies/open-source-terms.mdx.
These Terms include a number of important provisions that affect your rights and responsibilities, such as the disclaimers in "Disclaimers", limits on npm's liability to you in "Limits on Liability", and an agreement to arbitrate disputes individually in "Arbitration".
npm offers additional, paid services (Paid Services) that are subject to additional terms:
npm Open Source and any Paid Services you may agree to use are together called npm Services throughout these Terms.
You may only access or use npm Services by agreeing to these Terms. If npm adds any additional functionality to npm Services, you must agree to these Terms to use that new functionality, too. You show your agreement with npm on these Terms by creating a user account (your Account) or by accessing or using npm Services without creating an account. The agreement between you and npm is a legally binding contract (this Agreement).
npm may change these Terms and the additional terms for Paid Services in the future. npm will post changes on the Website with a new "last updated" date. If you have an Account, npm will notify you of changes by email to the address provided for your Account, by a message on the Website, or both. If you do not have an account, npm may notify you of changes by a general announcement via the Website, but it is up to you to check for changes to these Terms. After receiving notice of changes to these Terms, you must accept those changes to continue using npm Services. You accept changes to these Terms by continuing to use npm Services. npm may change, suspend, or discontinue npm Services at any time without notice or liability to you.
npm respects your privacy and limits use and sharing of information about you collected by npm Services. The privacy policy at https://docs.npmjs.com/policies/privacy(the Privacy Policy) describes these policies. npm will abide by the Privacy Policy and honor the privacy settings that you choose via npm Services.
npm respects the exclusive rights of copyright holders and responds to notifications about alleged infringement via npm Services per the copyright policy at https://docs.npmjs.com/dmca (the Copyright Policy).
npm resolves disputes about package names, user names, and organization names in the Public Registry per the policy at https://docs.npmjs.com/disputes (Dispute Policy). This includes "package squatting".
Use of all npm Services is governed by the code of conduct at https://docs.npmjs.com/conduct (Code of Conduct).
npm permits use of npm trademarks per the policy at https://docs.npmjs.com/trademark.
Subject to these Terms, npm grants you permission to use npm Open Source. That permission is not exclusive to you, and you cannot transfer it to anyone else.
Your permission to use npm Open Source entitles you to do the following:
You may search for, download, publish, and manage packages of computer code (Packages) in the Public Registry, and otherwise interact with the Public Registry, via the command-line tool published by npm at https://www.github.com/npm/cli (the CLI).
You may search for, download, publish, and manage Packages using software other than CLI via application programming interfaces that npm publicly documents or makes available for public use (Public APIs).
You may search for and manage Packages in the Public Registry, and otherwise interact with the Public Registry, via the Website.
You may update and manage your Account via the Website.
You may visit, create an account for, and participate in, discussions on npm.community.
Your permission to use npm Open Source, as well as any permission you may have to use Paid Services, are subject to the following conditions:
You must be at least 13 years of age to use npm Services.
You may not use npm Services after npm says you may not, such as by disabling your Account.
You must use npm Services only in accordance with "Acceptable Use".
You may access and use data about the security of Packages, such as vulnerability reports, audit status reports, and supplementary security documentation, only for your own personal or internal business purposes. You may not provide others access to, copies of, or use of npm data about the security of Packages, directly or as part of other products or services.
You will abide by the Code of Conduct and the Dispute Policy.
You will not submit material to npm as a package or in any other form that violates npm's Acceptable Content, described below.
You will not disclose information that you do not have the right to disclose, such as confidential information of others.
You will not copy or share any personally identifiable information of any other person without their specific permission.
You will not violate any applicable law.
You will not use or attempt to use another person's Account without their specific permission.
You will not buy, sell, or otherwise trade in user names, organization names, names for Packages, or any other names reserved on npm Services, for money or other compensation.
You will not use npm Services' ability to send e-mail to send advertisements, chain letters, or other solicitations.
You will not automate access to, use, or monitor the Website, such as with a web crawler, browser plug-in or add-on, or other computer program that is not a web browser. You may replicate data from the Public Registry using the Public APIs per this Agreement.
You will not use npm Services to send email to distribution lists, newsgroups, or group mail aliases.
You will not falsely imply that you are affiliated with or endorsed by npm.
You will not operate illegal schemes, such as pyramid schemes, via npm Services.
You will not deep-hyperlink to images or other non-hypertext content served by npm Services.
You will not remove any marking indicating proprietary ownership from any material got via npm Services.
You will not display any portion of the Website via an HTML IFRAME.
You will not disable, avoid, or circumvent any security or access restrictions of npm Services, or access parts of npm Services not intended for access by you.
You will not strain infrastructure of npm Services with an unreasonable volume of requests, or requests designed to impose an unreasonable load on IT systems underlying npm Services. This rule is intentionally loose, to give npm the flexibility it needs to keep npm Services working for the user community as a whole. But to draw one clear line, under no circumstances are five million requests to npm Services in a single month-long period by any single individual, organization, or group of affiliated companies remotely reasonable. If you have a special need to make lots and lots of requests, our sales team can help.
You will not encourage or assist any other person in violation of "Acceptable Use".
Administrators at npm reserve the right to delete content hosted on the npm Services that they deem unacceptable. Unacceptable content can take the form of a package, a README file, a user or organization name, or any other content submitted to npm Services. A few examples of unacceptable content:
Content that is illegal, offensive, or otherwise harmful. This includes content that is harassing, inappropriate, or abusive.
Content in violation of law, infringing the intellectual property rights of others, violating the privacy or other rights of others, or in violation of any agreement with a third party. This includes code that violates a public license for others' work.
Content containing malicious computer code, such as computer viruses, computer worms, rootkits, back doors, or spyware. This includes content submitted for research purposes. Tools designed and documented explicitly to assist in security research are acceptable, but exploits and malware that use the npm registry as a deployment or delivery vector are not.
Packages that are not functionally compatible with the npm command-line client. For example, a "package" cannot simply be a PNG or JPEG image, a movie file, or a text document uploaded directly to the registry. Using the Public Registry as a general purpose database is not allowed.
Content that exists only to "reserve" a name, whether a package name, user name, or organization name. The Dispute Policy governs how npm handles such cases of "squatting".
To find out how to report violations of Acceptable Content, refer to the Code of Conduct.
The npm Public Registry is about Packages. All manner of useful Packages are welcome, from hobby projects to competitive products, enterprise infrastructure and tooling to the latest fun hack or work of software art.
At the same time, the npm Public Registry, the Website, and important conventions like README go beyond just code. Developers use all of those channels to communicate more broadly about code, who is developing it, why, and how.
That communication is important, and welcome, so long as it respects that the npm Public Registry, the website, and npm Open Source more generally remain neutral. You are free to use npm Open Source for commercial projects, to advance your career, and for other business purposes. But you may not leverage content or system conventions to make the npm Public Registry, Website, or CLI put business before code.
These kinds of commercial content are generally acceptable in README files and other documentation:
Credits, acknowledgments, attributions, and other recognitions of contributions to Packages.
Information on how to pay, donate to, and otherwise support Package development, Package developers, and Package steward organizations.
Logos from, and links to, organizations developing, stewarding, or sponsoring Package development.
Information on paid products and services related to Packages, such as enhanced versions, add-ons, commercial license terms, training, integration, or support.
These kinds of commercial content generally aren't acceptable:
README, package.json, or other content displaying advertisements.
Packages that display ads at runtime, on installation, or at other stages of the software development lifecycle, such as via npm scripts. Packages with code that can be used to display ads are fine. Packages that themselves display ads are not.
Packages that function primarily as ads, with only placeholder or negligible code, data, and other technical content.
These examples are just examples. npm will continue to apply its judgment when deciding what content is acceptable. npm will continue to expect you to apply your own judgment when choosing what you share and how.
npm may investigate and prosecute violations of this Agreement to the fullest legal extent. npm may notify and cooperate with law enforcement authorities in prosecuting violations of this Agreement.
You must create and log into an Account to access features of some npm Services, including npm Open Source.
To create an Account, you must provide certain information about yourself, as required by the account creation form on the Website or the CLI. If you create an Account, you will provide, at a minimum, a valid email address. You will keep that email address up-to-date. You will not impersonate any other individual. You may delete your Account at any time by contacting support.
You will be responsible for all action taken using your account, whether authorized by you or not, until you either close your account or give npm notice that the security of your Account has been compromised. You will notify npm immediately if you suspect the security of your Account has been compromised. You will select a secure password for your Account. You will keep your password secret.
npm may restrict, suspend, or terminate your Account according to the Copyright Policy, if npm reasonably believes that you are in breach of these Terms, or if npm reasonably believes that you have misused npm Services.
Nothing in this Agreement gives npm any ownership rights in intellectual property that you share with npm Services, such as your Account information or any Packages you share with npm Services (Your Content). Nothing in this Agreement gives you any ownership rights in npm intellectual property provided via npm Services, like software, documentation, trademarks, service marks, logotypes, or other distinguishing graphics.
Between you and npm, you remain solely responsible for Your Content. You will not wrongly imply that Your Content is sponsored or approved by npm. npm will not be obligated to store, maintain, or provide copies of your content, except per the Privacy Policy.
npm may remove Your Content from npm Services without notice if npm suspects Your Content was submitted or used in violation of "Acceptable Use", as well as per the Copyright Policy.
Your Content belongs to you. You decide whether and how to license it. But at a minimum, you license npm to provide Your Content to users of npm Services when you share Your Content. That special license allows npm to copy, publish, and analyze Your Content, and to share its analyses with others. npm may run computer code in Your Content to analyze it, but npm's special license alone does not give npm the right to run code for its functionality in npm products or services.
When Your Content is removed from npm Services, whether by you or npm, npm's special license ends when the last copy disappears from npm's backups, caches, and other systems. Other licenses, such as open source licenses, may continue after Your Content is removed. Those licenses may give others, or npm itself, the right to share Your Content with npm Services again.
Others who receive Your Content via npm Services may violate the terms on which you license Your Content. You agree that npm will not be liable to you for those violations or their consequences.
npm welcomes your feedback and suggestions for npm Services. You agree that npm will be free to act on feedback and suggestions you provide without further notice, consent, or payment. You will not submit feedback or suggestions that you consider confidential or proprietary.
You will indemnify npm, its officers, directors, employees, representatives, and agents, and hold them harmless for, all liability, expenses, damages, and costs from any third-party claims, demands, lawsuits, or other proceedings alleging that Your Content, your use of npm Services, or both, violate the intellectual property right of a third party, this Agreement, or applicable law. You will not settle any such proceeding without the prior written consent of npm. npm will notify you of any such proceeding it becomes aware of.
Use of npm Services is at your sole risk. npm Services are provided on an "as is" and "as available" basis. npm expressly disclaims all warranties of any kind, whether express, implied, or statutory, including implied warranties of title, noninfringement, merchantability, and fitness for a particular purpose.
npm makes no warranty that npm Services will meet your requirements, operate in an uninterrupted, timely, secure, or error-free manner, or that errors in npm Services will be corrected.
You receive material via npm Services at your sole risk. You will be solely responsible for any damage to your computer system and network, as well as any data loss that may result from use of npm Services or material received via npm Services.
npm Services may provide information and software that is inaccurate, incomplete, misleading, illegal, offensive, or otherwise harmful. npm may, but does not promise to, review content provided by npm Services.
npm Services provide information about ownership and licensing of Packages, as provided by those Packages' publishers. That information may be wrong. npm cannot and does not provide legal advice.
npm Services may hyperlink to and integrate with third-party applications, websites, and other services. You decide whether and how to use and interact with such services. npm does not make any warranty regarding such services or content they may provide, and will not be liable to you for any damages related to such services. Use of such third-party services may be governed by other terms and privacy notices that are not part of this Agreement and are not controlled by npm.
Neither npm nor any third-party service provider used by npm to provide npm Services will, under any circumstances, be liable to you for any indirect, incidental, consequential, special, or exemplary damages related to your use of npm Services or this Agreement, whether based on breach of contract, breach of warranty, tort (including negligence, product liability, or otherwise), or any other pecuniary loss, and whether or not npm has been advised of the possibility of such damages.
To the maximum extent permitted by law, npm's liability to you for any damages related to this Agreement, for any one or more causes and regardless of the form of action, will not exceed $50.
Some jurisdictions do not allow exclusion of certain warranties or limits on liability for incidental or consequential damages. Some of "Disclaimers" and "Limits on Liability" may not apply to you.
Either you or npm may terminate this Agreement at any time with notice to the other.
On termination of this Agreement, your permission to use npm Open Source, as well any permission you may have to access Paid Services under additional terms, also terminate.
The following provisions survive termination of this Agreement: "Your Content", "Feedback", "Indemnity", "Disclaimers", "Limits on Liability", and "General Terms". Users of npm Services may continue to copy and share Your Content after termination of this Agreement.
There is no charge for use of npm Open Source. If you use Paid Services from npm, our Paid Services Terms at https://docs.npmjs.com/policies/private-terms apply.
If a provision of this Agreement is unenforceable as written, but could be changed to make it enforceable, that provision should be modified to the minimum extent necessary to make it enforceable. Otherwise, that provision should be removed.
You may not assign this Agreement. npm may assign this Agreement to any affiliate of npm, any third party that obtains control of npm, or any third party that purchases assets of npm relating to npm Services. Any purported assignment of rights in breach of this provision is void.
Neither the exercise of any right under this Agreement, nor waiver of any breach of this Agreement, waives any other breach of this Agreement.
This Agreement, together with the additional terms for Paid Services and npm software that you and npm agree to, embody all the terms of agreement between you and npm about npm Services. This Agreement supersedes any other agreements about npm Services, written or not.
The law of the State of California will govern any dispute, including any legal proceedings, relating to this Agreement or your use of npm Services (a Dispute).
You and npm will seek injunctions related to this agreement only in state or federal court in San Francisco, California. Neither you nor npm will object to jurisdiction, forum, or venue in those courts.
Other than to seek an injunction, you and npm will resolve any Dispute by binding American Arbitration Association arbitration. Arbitration will follow the AAA's Commercial Arbitration Rules and Supplementary Procedures for Consumer Related Disputes. Arbitration will happen in San Francisco, California. You will settle any Dispute as an individual, and not as part of a class action or other representative proceeding, whether as the plaintiff or a class member. No arbitrator will consolidate any Dispute with any another arbitration without npm's permission.
Any arbitration award will include costs of the arbitration, reasonable attorneys' fees, and reasonable costs for witnesses. You or npm can enter arbitration awards in any court with jurisdiction.
You may send notice to npm and questions about the terms governing npm products and services to legal@npmjs.com or by mail to:
GitHub, Inc
Attn: npm Legal Department
88 Colin P Kelly Jr St
San Francisco, CA. 94107
npm may send you notice using the email address you provide for your Account or by posting a message to the homepage or your Account page on the Website.
These npm Paid Services Terms of Use (these npm Paid Services Terms) supplement the terms for npm Open Source offered by npm, Inc. (npm) at https://docs.npmjs.com/policies/open-source-terms (npm Open Source Terms). They govern access to and use of npm Paid Services, including but not limited to the products known as npm Solo and npm Orgs, the private package storage, delivery, organization management, and access control features of https://www.npmjs.com (the Website) and the npm public registry at https://registry.npmjs.org (the Public Registry). These are collectively called the Paid Services.
These npm Paid Services Terms were last updated on March 10, 2022. You can review prior versions at https://github.com/npm/documentation/blob/main/content/policies/private-terms.mdx.
You may only access or use npm Paid Services by agreeing to the npm Open Source Terms as supplemented by these npm Paid Services Terms. If npm adds any additional functionality to npm Paid Services, you must agree to these npm Paid Services Terms to use those new features, too. You add these npm Paid Services Terms to your agreement with npm by using npm Paid Services with your account (your Account). These npm Paid Services Terms then become a part of the contract between you and npm, until you or npm disable npm Paid Services for your Account.
There is no charge for use of npm Open Source. If you use Paid Services, these payment terms apply. When enabling Paid Services, you must provide all the payment card details requested by the Website (your Payment Details). Those details must be for a valid payment card that you have the right to use (your Payment Card). You must keep your Payment Details up-to-date via the Website.
You can disable Paid Services at any time via the Website. npm will not refund any payment you have already made for Paid Services when you disable Paid Services.
Dollar amounts throughout this Agreement are amounts of United States Dollars. You must pay for Paid Services in United States Dollars.
Dollar amounts throughout this Agreement do not include tax. You will pay any tax.
npm will provide the private package storage and delivery features and services described in the public documentation for npm Paid Services at https://docs.npmjs.com/ (the npm Paid Services Documentation). npm grants you permission to use those features and services.
npm will also provide the organization management and access control features described in the npm Paid Services Documentation, and grants you permission to use those features and services, for npm "organizations" to which your Account belongs.
Permission to use npm Paid Services is not exclusive to you, and you may not transfer it to others. These npm Paid Services Terms do not give you permission to give others rights to use npm Paid Services. If you agree to a Payment Plan that gives you that right, you may do so only according to that Payment Plan.
Both your permission to use npm Paid Services and npm's commitment to provide npm Paid Services are subject to these npm Paid Services Terms, the npm Open Source Terms, and payment for use of npm Paid Services by your Account under a Payment Plan. Payment plans include:
the npm Solo Payment Plan at https://docs.npmjs.com/policies/solo-plan
or the npm Orgs Payment Plan at https://docs.npmjs.com/policies/orgs-plan
You may not use npm Paid Services unless you or someone else has agreed to a Payment Plan, enabled npm Paid Services for your Account under that Payment Plan, and made payment.
npm exists to facilitate sharing code, by making it easy for JavaScript module developers to publish and distribute packages.
npm is a piece of technology, but more importantly, it is a community.
We believe that our mission is best served in an environment that is friendly, safe, and accepting; free from intimidation or harassment.
Towards this end, certain behaviors and practices will not be tolerated.
We expect all members of the npm community, including paid and unpaid agents, administrators, users, and customers of npm, Inc., to abide by this Code of Conduct at all times in all npm community venues, online and in person, and in one-on-one communications pertaining to npm affairs.
This policy covers the usage of the npm registry, as well as the npm website, npm related events, and any other services offered by or on behalf of npm, Inc. (collectively, the "Service"). It also applies to behavior in the context of the npm Open Source project communities, including but not limited to public GitHub repositories, IRC channels, social media, mailing lists, and public events.
This Code of Conduct is in addition to, and does not in any way nullify or invalidate, any other terms or conditions related to use of the Service.
The definitions of various subjective terms such as "discriminatory", "hateful", or "confusing" will be decided at the sole discretion of the npm abuse team.
We are committed to providing a friendly, safe and welcoming environment for all, regardless of gender identity, sexual orientation, ability, ethnicity, religion, age, physical appearance, body size, race, or similar personal characteristics.
We ask that you please respect that people have differences of opinion regarding technical choices, and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a single right answer. A difference of technology preferences is not a license to be rude.
Disputes over package rights must be handled respectfully, according to the terms described in the Disputes Policy. There is never a good reason to be rude over package name disputes.
Any spamming, trolling, flaming, baiting, or other attention-stealing behavior is not welcome, and will not be tolerated.
Harassing other users of the Service is never tolerated, whether via public or private media.
Avoid using offensive or harassing package names, nicknames, or other identifiers that might detract from a friendly, safe, and welcoming environment for all.
Harassment includes, but is not limited to: harmful or prejudicial verbal or written comments related to gender identity, sexual orientation, ability, ethnicity, religion, age, physical appearance, body size, race, or similar personal characteristics; inappropriate use of nudity, sexual images, and/or sexually explicit language in public spaces; threats of physical or non-physical harm; deliberate intimidation, stalking or following; harassing photography or recording; sustained disruption of talks or other events; inappropriate physical contact; and unwelcome sexual attention.
The Service administrators reserve the right to make judgment calls about what is and isn't appropriate in published packages, package names, user and organization names, and other public content. Package that violates the npm Service's Acceptable Use rules including its Acceptable Content rules will be deleted, at the discretion of npm.
Please select the method of contact you think is most appropriate for the form of violation:
For urgent security issues, please open a ticket at https://npmjs.com/support. Requests to un-publish packages are not usually considered urgent security issues, as it is possible to un-publish a package within 24 hours of its first publish. Any publicly published package is immediately replicated to thousands of third-party mirrors, so any confidential information contained in a package should be considered immediately compromised.
If you believe someone is harassing you or is demonstrating some other form of malicious or inappropriate behavior, open a support ticket at https://npmjs.com/support. If this is the initial report of a problem, please include as much detail as possible. It is easiest for us to address issues when we have more context.
If you have concerns about a potential copyright violation, please refer to our Copyright Policy and take action as recommended by that policy.
If you think a package or other content is "squatting" on a name, follow the process described in the Disputes Policy.
For any other issues, or if in doubt, contact support.
All content published to the Service, including user account credentials, is hosted at the sole discretion of the npm administrators.
Unacceptable behavior from any community member, including sponsors, employees, customers, or others with decision-making authority, will not be tolerated.
Anyone asked to stop unacceptable behavior is expected to comply immediately.
If a community member engages in unacceptable behavior, the npm administrators may take any action they deem appropriate, up to and including a temporary ban or permanent expulsion from the community without warning (and without refund in the case of a paid event or service).
If your content or account has been disabled or restricted and you seek reinstatement or wish to appeal, please review GitHub's Appeal and Reinstatement page for information about the process and use the Appeal and Reinstatement form to submit a request.
Please open a support ticket at https://npmjs.com/support if you need to report a problem or address a grievance related to an abuse report.
You are also encouraged to contact us if you are curious about something that might be "on the line" between appropriate and inappropriate content. We are happy to provide guidance to help you be a successful part of our community.
This is a living document and may be updated from time to time. Please refer to the git history for this document to view the changes.
This Code of Conduct borrows heavily from the Stumptown Syndicate Citizen's Code of Conduct, and the Rust Project Code of Conduct.
This document may be reused under a Creative Commons Attribution-ShareAlike License.
This document describes the steps that you should take to resolve naming disputes with other npm publishers. It also describes the steps you should take if you think a name infringes your trademark.
This document is additive to the guidelines in the npm Code of Conduct and npm Open-Source terms. Nothing in this document should be interpreted to contradict any aspect of the npm Code of Conduct or Open-Source Terms.
This process is an excellent way to:
This process does not apply if the package violates our Terms of Use, in particular our Acceptable Use and Acceptable Content rules, or our Code of Conduct. Those documents refer to this one to resolve cases of "squatting"; see below.
If you see bad behavior or content you believe is unacceptable, refer to the Code of Conduct for guidelines on reporting violations. You are never expected to resolve abusive behavior on your own. We are here to help.
This process is not available for dispute requests due to lack of activity related to a specific name.
Please also note there are cases where a party may have claim to a specific name, but giving that name to the requesting party would pose a supply-chain risk to the npm ecosystem. In such cases, requests may be denied independent of the validity of the claim.
npm processes Trademark claims under GitHub's Trademark Policy.
If you think another npm publisher is infringing your trademark, such as by using a confusingly similar package, org, or user account name, please submit a Trademark Policy Violation Report via our form.
Use of npm's own trademarks is covered by our Logo and Usage Policy.
This is a living document and may be updated from time to time. Please refer to the git history for this document to view the changes.
It is against npm's Terms of Use to publish a package, register a user name or an organization name simply for the purposes of reserving it for future use.
We do not pro-actively scan the registry for squatted packages, so the fact that a name is in use does not mean we consider it valid. The standards for what we consider squatting depend on what is being squatted:
Package names are considered squatted if the package has no genuine function.
Organization names are considered squatted if there are no packages published within a reasonable time. If an organization is a paid organization, it may have private packages that are invisible to third parties. For privacy reasons, we cannot reveal whether or not an organization has private packages, so a paid organization will never be considered squatted.
We are extremely unlikely to transfer control of a user name, as it is totally valid to be an npm user and never publish any packages: for instance, you might be part of an organization or need read-only access to private packages.
Copyright (C) npm, Inc., All rights reserved
This document may be reused under a Creative Commons Attribution-ShareAlike License.
Copyright (c) npm, Inc. and Contributors All rights reserved.
npm is released under the Artistic License 2.0, subject to additional terms that are listed below.
The text of the npm License follows and the text of the additional terms follows the Artistic License 2.0 terms:
The Artistic License 2.0
Copyright (c) 2000-2006, The Perl Foundation.
Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.
Preamble
This license establishes the terms under which a given free software Package may be copied, modified, distributed, and/or redistributed. The intent is that the Copyright Holder maintains some artistic control over the development of that Package while still keeping the Package available as open source and free software.
You are always permitted to make arrangements wholly outside of this license directly with the Copyright Holder of a given Package. If the terms of this license do not permit the full use that you propose to make of the Package, you should contact the Copyright Holder and seek a different licensing arrangement.
Definitions
"Copyright Holder" means the individual(s) or organization(s)
named in the copyright notice for the entire Package.
"Contributor" means any party that has contributed code or other
material to the Package, in accordance with the Copyright Holder's
procedures.
"You" and "your" means any person who would like to copy,
distribute, or modify the Package.
"Package" means the collection of files distributed by the
Copyright Holder, and derivatives of that collection and/or of
those files. A given Package may consist of either the Standard
Version, or a Modified Version.
"Distribute" means providing a copy of the Package or making it
accessible to anyone else, or in the case of a company or
organization, to others outside of your company or organization.
"Distributor Fee" means any fee that you charge for Distributing
this Package or providing support for this Package to another
party.  It does not mean licensing fees.
"Standard Version" refers to the Package if it has not been
modified, or has been modified only in ways explicitly requested
by the Copyright Holder.
"Modified Version" means the Package, if it has been changed, and
such changes were not explicitly requested by the Copyright
Holder.
"Original License" means this Artistic License as Distributed with
the Standard Version of the Package, in its current version or as
it may be modified by The Perl Foundation in the future.
"Source" form means the source code, documentation source, and
configuration files for the Package.
"Compiled" form means the compiled bytecode, object code, binary,
or any other form resulting from mechanical transformation or
translation of the Source form.
Permission for Use and Modification Without Distribution
(1) You are permitted to use the Standard Version and create and use Modified Versions for any purpose without restriction, provided that you do not Distribute the Modified Version.
Permissions for Redistribution of the Standard Version
(2) You may Distribute verbatim copies of the Source form of the Standard Version of this Package in any medium without restriction, either gratis or for a Distributor Fee, provided that you duplicate all of the original copyright notices and associated disclaimers. At your discretion, such verbatim copies may or may not include a Compiled form of the Package.
(3) You may apply any bug fixes, portability changes, and other modifications made available from the Copyright Holder. The resulting Package will still be considered the Standard Version, and as such will be subject to the Original License.
Distribution of Modified Versions of the Package as Source
(4) You may Distribute your Modified Version as Source (either gratis or for a Distributor Fee, and with or without a Compiled form of the Modified Version) provided that you clearly document how it differs from the Standard Version, including, but not limited to, documenting any non-standard features, executables, or modules, and provided that you do at least ONE of the following:
(a)  make the Modified Version available to the Copyright Holder
of the Standard Version, under the Original License, so that the
Copyright Holder may include your modifications in the Standard
Version.
(b)  ensure that installation of your Modified Version does not
prevent the user installing or running the Standard Version. In
addition, the Modified Version must bear a name that is different
from the name of the Standard Version.
(c)  allow anyone who receives a copy of the Modified Version to
make the Source form of the Modified Version available to others
under
(i)  the Original License or
(ii)  a license that permits the licensee to freely copy,
modify and redistribute the Modified Version using the same
licensing terms that apply to the copy that the licensee
received, and requires that the Source form of the Modified
Version, and of any works derived from it, be made freely
available in that license fees are prohibited but Distributor
Fees are allowed.
Distribution of Compiled Forms of the Standard Version or Modified Versions without the Source
(5) You may Distribute Compiled forms of the Standard Version without the Source, provided that you include complete instructions on how to get the Source of the Standard Version. Such instructions must be valid at the time of your distribution. If these instructions, at any time while you are carrying out such distribution, become invalid, you must provide new instructions on demand or cease further distribution. If you provide valid instructions or cease distribution within thirty days after you become aware that the instructions are invalid, then you do not forfeit any of your rights under this license.
(6) You may Distribute a Modified Version in Compiled form without the Source, provided that you comply with Section 4 with respect to the Source of the Modified Version.
Aggregating or Linking the Package
(7) You may aggregate the Package (either the Standard Version or Modified Version) with other packages and Distribute the resulting aggregation provided that you do not charge a licensing fee for the Package. Distributor Fees are permitted, and licensing fees for other components in the aggregation are permitted. The terms of this license apply to the use and Distribution of the Standard or Modified Versions as included in the aggregation.
(8) You are permitted to link Modified and Standard Versions with other works, to embed the Package in a larger work of your own, or to build stand-alone binary or bytecode versions of applications that include the Package, and Distribute the result without restriction, provided the result does not expose a direct interface to the Package.
Items That are Not Considered Part of a Modified Version
(9) Works (including, but not limited to, modules and scripts) that merely extend or make use of the Package, do not, by themselves, cause the Package to be a Modified Version. In addition, such works are not considered parts of the Package itself, and are not subject to the terms of this license.
General Provisions
(10) Any use, modification, and distribution of the Standard or Modified Versions is governed by this Artistic License. By using, modifying or distributing the Package, you accept this license. Do not use, modify, or distribute the Package, if you do not accept this license.
(11) If your Modified Version has been derived from a Modified Version made by someone other than you, you are nevertheless required to ensure that your Modified Version complies with the requirements of this license.
(12) This license does not grant you the right to use any trademark, service mark, tradename, or logo of the Copyright Holder.
(13) This license includes the non-exclusive, worldwide, free-of-charge patent license to make, have made, use, offer to sell, sell, import and otherwise transfer the Package with respect to any patent claims licensable by the Copyright Holder that are necessarily infringed by the Package. If you institute patent litigation (including a cross-claim or counterclaim) against any party alleging that the Package constitutes direct or contributory patent infringement, then this Artistic License to you shall terminate on the date that such litigation is filed.
(14) Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL LAW. UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING IN ANY WAY OUT OF THE USE OF THE PACKAGE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
The following additional terms shall apply to use of the npm software, the npm website, the npm repository and any other services or products offered by npm, Inc.:
"Node.js" trademark Joyent, Inc. npm is not officially part of the Node.js project, and is neither owned by nor affiliated with Joyent, Inc.
"npm" and "The npm Registry" are owned by npm, Inc. All rights reserved.
Modules published on the npm registry are not officially endorsed by npm, Inc. or the Node.js project.
Data published to the npm registry is not part of npm itself, and is the sole property of the publisher. While every effort is made to ensure accountability, there is absolutely no guarantee, warrantee, or assertion expressed or implied as to the quality, fitness for a specific purpose, or lack of malice in any given npm package. Packages downloaded through the npm registry are independently licensed and are not covered by this license.
Additional policies relating to, and restrictions on use of, npm products and services are available on the npm website. All such policies and restrictions, as updated from time to time, are hereby incorporated into this license agreement. By using npm, you acknowledge your agreement to all such policies and restrictions.
If you have a complaint about a package in the public npm registry, and cannot resolve it with the package owner, please contact support and explain the situation. See the npm Dispute Resolution policy for more details.
Any data published to The npm Registry (including user account information) may be removed or modified at the sole discretion of the npm server administrators.
"npm Logo" contributed by Mathias Pettersson and Brian Hammond, use is subject to https://docs.npmjs.com/trademark
"Gubblebum Blocky" font Copyright (c) by Tjarda Koster, https://jelloween.deviantart.com included for use in the npm website and documentation, used with permission.
This program uses several Node modules contained in the node_modules/ subdirectory, according to the terms of their respective licenses.
This notice describes how npm, Inc., or npm for short, collects and uses data about you.
That depends on your personal situation, which is why you should read on and decide for yourself. But at a minimum, absolutely every npm user should understand:
The npm public registry is for making software available to everyone online.
But: Software comes from people, and says something about us.
So: Think carefully about what packages to publish, what data you put in those packages, and what others might do with that data.
When you create an account, certain contact information is displayed publicly in the npm platform. And when you upload a package, your name and contact information may become associated with that package.
If you find yourself in a jam, open a support ticket.
npm collects data about you:
when you use the npm command, the npx command or another program to access the npm public registry, Enterprise registries that npm hosts, private packages, such as when you're publishing a software package, and APIs for functionality like account and permissions management
when you browse the npm website, npmjs.com
when you use either the npm command or the website to create an npm account, update your account, and sign up for npm services
when you send support, privacy, legal, and other requests to npm
when working with and researching current and potential customers
When researching potential customers, npm staff sometimes search the public World Wide Web or paid business databases. Otherwise, npm doesn't buy or receive data about you from data brokers or other private services.
npm may inadvertently collect data about you if it is included in software packages that you or others upload.
When you use the npm command, the npx command, or other software to work with the npm public registry, an Enterprise registry that npm hosts, or private packages, npm logs data that might be identified to you:
a random, unique identifier, called npm-session, for each time you run commands like npm install
the names and versions of your project's dependencies, their dependencies, and so on, that come from the npm public registry, but not of other dependencies, like Git dependencies
the versions of Node.js, the npm command, and the operating system you are using
an npm-in-ci header, showing whether the command was run on a continuous integration server
the scope of the package for which you ran npm install, as an npm-scope header
a referrer header that shows the command you ran, with any file or directory paths redacted
data about the software you're using to access the registry, such as the User-Agent string
network request data, such as the date and time, your IP address, and the URL
npm uses this data to:
fulfill your requests, such as by sending the packages you ask for
send you alerts about security vulnerabilities that may affect the software you're building, when you run npm install or npm audit
keep registries working quickly and reliably
debug and develop the npm command and other software
defend registries from abuse and technical attacks
compile statistics on package usage and popularity
prepare reports on trends in the developer community
improve search results on the website
recommend packages that may be relevant to your work
When you visit www.npmjs.com, docs.npmjs.com, and other npm websites, npm uses cookies, server logs, and other methods to collect data about what pages you visit, and when. npm also collects technical information about the software and computer you use, such as:
your IP address
your preferred language
the web browser software you use
the kind of computer you use
the website that referred you
npm uses data about how you use the website to:
optimize the website, so that it's quick and easy to use
diagnose and debug technical errors
defend the website from abuse and technical attacks
compile statistics on package popularity
compile statistics on the kinds of software and computers visitors use
compile statistics on visitor searches and needs, to guide development of new website pages and functionality
decide who to contact about about product announcements, service changes, and new features
Many features of npm services require an npm account. For example, you must have an npm account to publish packages to the npm public registry.
To create an npm account, npm requires a working email address and an available user name. npm uses this data to provide you access to features and identify you across npm services, publicly and within npm.
You do not have to give your personal or legal name to create an npm account. You can use a pseudonym instead. You can also open more than one account.
If you sign up for an account, then npm will publish account data for the whole world to see on user pages like this one. npm also publishes account data through the npm public registry, which is available for everyone to see, and Enterprise registries that npm hosts for others to find with commands like npm owner ls tap.
If you give npm a personal name or names on social media like GitHub and Twitter through the website, like when you include this on your profile or user page, npm publishes that data along with the email address and user name for the account. You don't have to give npm a personal name or any social media names, and you can remove this data at any time by updating your user page.
npm uses your email to:
notify you about packages published using your account
reset your password and help keep your account secure
add metadata to packages that you publish
contact you in special circumstances related to your account or packages
contact you about support requests
contact you about legal requests, like DMCA takedown requests and privacy complaints
announce new npm product offerings, service changes, and features
send you tips about how to better use free and paid services
send you messages about paid services you might want
When you use npm publish or other software to publish packages to the npm public registry, an Enterprise registry that npm hosts, or as a private package, npm collects the contents of the package, plus metadata, including your account data. Other npm users may also publish packages that include data about you, such as the fact that you contributed code to a package.
npm uses data in packages to provide those packages to you and others who request them:
When you publish a package to the npm public registry, or change a package from private to public, npm makes the package and metadata available to everyone, online.
When you publish a package to an Enterprise registry that npm hosts, or as a private package, npm makes all of that data available to other users according to how the registry or the private packages account is configured. You may be able to configure who can access the package, or that may be up to others, such as the administrator of your company's Enterprise registry.
Making package data available to others allows them to download, build on, and depend on your work.
To sign up for paid services, npm requires your payment card data. npm itself does not collect or store enough information to charge your card itself. Rather, Stripe collects that data on npm's behalf, and gives npm security tokens that allow npm to create charges and subscriptions.
npm uses your payment card data only to charge for npm services.
npm instructs Stripe to store your payment card data only as long as you use paid npm services.
npm collects data about you when you send npm support requests, legal complaints, privacy inquiries, and business inquiries. Those data usually include your name and email address, and may include your company or other affiliation.
npm uses contact data to:
respond to you
compile aggregate statistics about correspondence
train support staff and other npm personnel
review the performance of npm personnel who respond
defend npm from legal claims
npm collects data about visits, user accounts, and forum data on npm.community, the discussion forum for users of npm products and services. npm uses data from npm.community to collaborate with the development community, and to inform development decisions about the command-line interface and other software.
npm shares account data with others as mentioned in the section about account data.
npm shares package data with others as mentioned in the section about package data.
npm publishes posts and other content you submit to npm.community.
npm does not sell information about you to others. However, npm uses services provided by other companies to provide npm services. The types of service providers that npm uses include:
Companies that enable us to offer features on our website, such as to display your avatar
Companies that facilitate the efficient distribution of content
Cloud computing platforms and services that host our discussion forums
Services that assist with the detection of spam, scams, abuse others, or other violations of our terms of service
Payment processors
Platforms to help us receive, manage, and respond to support requests
Platforms for internal communication
npm's website only uses cookies strictly necessary to provide, optimize and secure the website. For example, we use them to keep you logged in, remember your preferences, authenticate your device for security purposes, analyze your use of the service, compile statistical reports, and provide information for future development of npm. The website uses internal cookies for analytics purposes, not any third-party analytics or service providers.
By using the website, you agree that we can place these types of cookies on your computer or device. If you disable your browser or device’s ability to accept these cookies, you will not be able to log in or use the website.
You choose what data the npm publish command includes in package data. You can use an .npmignore file in your package to keep specific files out of the package. You can also use a files list in package.json files to instruct npm to include only specific files that you name, in addition to standard files like README files, LICENSE files, and package.json.
To double check the data that you will share in a package that you plan to publish, run the npm publish --dry-run command. If you are running an older version of the npm command, run the npm pack command to create a tarball, then check its contents, such as with tar tvzf $tarball.
To publish a package to the npm public registry, npm's terms of service require you to license npm to share it. If a package is made public, it is available for everyone online to see. However, your choice of public license for your package may affect what others can do with data about you in your package.
npm does not respond to the Do Not Track HTTP header.
npm stores account data, data about website use, data about registry use, and private packages on servers in the United States of America. metadata about those packages worldwide, via content delivery networks.
npm stores package data published to Enterprise registries that npm hosts, plus metadata about them, in cloud computing zones of customers' choosing.
By using the npm platform, you consent to the collection and storage of your data as outlined in this section.
npm respects privacy rights under Regulation (EU) 2016/679, the European Union's General Data Protection Regulation (GDPR). npm processes "Personal Data" on the following legal bases: (1) with your consent; (2) as necessary to perform our agreement to provide our services; and (3) as necessary for our legitimate interests in providing our services where those interests do not override your fundamental rights and freedom related to data privacy. Information we collect may be transferred to, and stored and processed in, the United States or any other country in which we or our affiliates or subcontractors maintain facilities, as described above.
If you reside in the EEA, Switzerland, or United Kingdom, you are entitled to certain rights, like the right to:
complain about our data collection or processing actions with the supervisor authority concerned. You can find a list of data protection authorities here.
access to information held about you.
ask us to correct or amend inaccurate or incomplete information we have about you.
ask us to erase data that under certain circumstances, like (1) when it is no longer necessary for the purpose for which it was collected, (2) you withdraw consent and no other legal basis for processing exists, or (3) you believe your fundamental rights to data privacy and protection outweigh our legitimate interest in continuing the processing.
request that we restrict our processing if we are processing your data based on legitimate interests or the performance of a task in the public interest as an exercise of official authority (including profiling); using your data for direct marketing (including profiling); or processing your data for purposes of scientific or historical research and statistics.
When you exercise your rights, npm may need to verify your identity and provide us with information before we access records containing your information. If you want to exercise your rights, please contact npm by opening a support ticket. We may have a reason under the law why we do not have to comply with your request or may comply with it in a more limited way than you anticipated. If we do, we will explain that to you in our response.
npm respects the rights of California residents under the California Consumer Privacy Act (CCPA). Where we collect information that is subject to the CCPA, that information we collect and your rights are described below.
Categories of personal information we collect:
Personal Identifiers:
Name and email address when you create an account. You will also be asked to create a username and we will assign one or more unique identifiers to your profile. We use this information to provide our services, respond to your requests, and send information to you.
We also collect your social media handle and basic account information if you provide it to us or interact with our services, such as our help desk, through social media.
We collect your payment information through our service provider, Stripe, as described above.
Internet or Other Electronic Network Activity Information: device identifiers such as IP address and user agent; the assigned unique IDs in cookies (as described below); information about how you arrived at and navigated through our Services.
Geolocation Data: We do not collect your specific longitude and latitude. However, we do collect imprecise location (e.g., your IP address).
Professional or employment-related information: If you apply for employment with us, information about your employment history.
Education information: If you apply for employment with us, information about your educational history.
We may collect any other information about you contained in software packages uploaded to our site, as described above under the "npm collects package data" section. We also collect the contents of your communications with us, e.g., when you submit a question to us through a web form or comments to us on social media.
We may disclose any of the categories of personal information listed above and use them for the above-listed purposes or for other business or operational purposes compatible with the context in which the personal information was collected. Our disclosures of personal information include disclosures to our "service providers," which are companies that we engage for business purposes to conduct activities on our behalf. The categories of service providers with whom we share information and the services they provide are described below.
Rights under CCPA:
Access/Right to Know: You have the right to request access to personal information we collected about you and information regarding the source of that personal information, the purposes for which we collect it, and the third parties and service providers with whom we share it.
Deletion: You have the right to request that we erase data we have collected from you. Please note that we may have a reason to deny your deletion request or delete data in a more limited way than you anticipated, e.g., because of a legal obligation to retain it.
To exercise your rights above, you can open a support ticket. When we process your request, we must verify your identity by asking you to (1) provide personal identifiers that we can match against information we may have collected from you previously; and (2) confirm your request using the email stated in the request.
Opt-out of sale:
California residents have the right to request that we stop "selling" their personal information. A "sale" of personal information is defined broadly: "selling, renting, releasing, disclosing, disseminating, making available, transferring, or otherwise communicating orally, in writing, or by electronic or other means, a consumer's personal information by the business to another business or a third party for monetary or other valuable consideration." We do not sell your information as defined by the CCPA.
Please note that your right to opt out does not apply to our sharing of personal information with service providers, who are parties we engage to perform a function on our behalf and are contractually obligated to use the Personal Information only for that function.
We may also disclose information to other entities who are not listed here when required by law or to protect our Company or other persons, as described in our Privacy Policy.
You can access your account data at any time by visiting your account page on www.npmjs.com. Your account page also lists all the packages published under your account or other accounts.
You can access package data by downloading the packages, as long as they're public or you have permission to access them.
You can see metadata about packages by running npm info $package, or by accessing the appropriate registry's API. Registry APIs provide metadata in standard JSON format, and packages as tarballs.
You can change your personal account data and payment card data at any time by visiting your account settings page on www.npmjs.com. You can change account and payment data for Enterprise by contacting support.
You can close your npm account at any time by e-mailing contacting support. Closing your account removes the profile from the public registry but does not automatically erase packages published under your account. We may retain some data about you internally even where you close your account.
npm's unpublish policy determines when you can erase packages from the npm public registry. The unpublish policy strikes a difficult balance between the purpose of publishing and hosting packages, others' reliance on what has been made public, and individual rights and freedoms.
If another user improperly publishes personal data about you, in a package or otherwise, open a support ticket.
Please note that while npm publishes notices about published data that's been erased, npm can't make everyone who has downloaded published package data or account data erase that data on your behalf. Choosing a public license, such as an open source software license, may encourage and allow storage, distribution, and use of package data indefinitely. Nearly all popular open source software licenses actually require preserving personal data that attributes the software to you, such as copyright notices, as a condition of permission for the software.
Please see our policy on "unpublishing" packages or our terms of service for more information on erasing packages.
If you accidentally publish a package that threatens your privacy, or discover someone else has published a package that does, open a support ticket. npm can and will take down packages in specific, exceptional situations to protect you, especially if others violate your privacy. Using npm to violate others' privacy is against our terms of service.
npm takes a few steps to notify others who may be copying data from the npm public registry that published data has been erased:
npm publishes new placeholder versions of some erased packages, with README files that mention the package has been erased, and why.
npm's registry APIs, special software services that others use to copy data from the npm public registry, send update messages about packages that have been erased.
We may transfer to another entity or its affiliates or service providers some or all information about you in connection with, or during negotiations of, any merger, acquisition, sale of assets or any line of business, change in ownership control, or financing transaction. We cannot promise that an acquiring party or the merged entity will have the same privacy practices or treat your information the same as described in this Policy.
npm's site and services are intended for users age sixteen and older. npm does not knowingly collect information from children. If we discover that we have inadvertently collected information from anyone younger than the age of 16, we will delete that information.
Please open a support ticket. You may also contact our Data Protection Officer directly.
Our United States HQ:
GitHub Data Protection Officer
Attention: npm Data Protection
88 Colin P. Kelly Jr. St.
San Francisco, CA 94107
United States
or our EU Office:
GitHub BV
Vijzelstraat 68-72
1017 HL Amsterdam
The Netherlands
This version of npm's privacy questions and answers took effect June 3, 2020.
npm will announce the next version on the npm blog. In the meantime, npm may update its contact information by updating the page at https://docs.npmjs.com/privacy, without an announcement. npm may change how it announces changes in future privacy versions.
You can review the history of changes in the Git repository for npm's public policies.
This document describes your options when looking to unpublish a package published to the public registry.
Registry data is immutable, meaning once published, a package cannot change. We do this for reasons of security and stability of the users who depend on those packages. So if you've ever published a package called "bob" at version 1.1.0, no other package can ever be published with that name at that version. This is true even if that package is unpublished.
However, because accidents happen, we allow you to unpublish packages in the situations described below. Otherwise, you can always deprecate a package.
For newly created packages, as long as no other packages in the npm Public Registry depend on your package, you can unpublish anytime within the first 72 hours after publishing.
Regardless of how long ago a package was published, you can unpublish a package that meets all of the following conditions:
To unpublish a single package version, run npm unpublish <package_name>@<version>.
If all the versions of a package can be unpublished, you can unpublish all versions at once by running npm unpublish <package_name> --force.
If your package does not meet the unpublish policy criteria, we recommend deprecating the package. This allows the package to be downloaded but publishes a clear warning message (that you get to write) every time the package is downloaded, and on the package's npmjs.com page. Users will know that you do not recommend they use the package, but if they are depending on it their builds will not break. We consider this a good compromise between reliability and author control.
This can be achieved by using one of the following from your command line:
If the entire package is deprecated, the package name will be dropped from our search results.
This document is additive to the unpublish procedures, the CLI commands unpublish documentation and the "Changes to npm Unpublish Policy - January 2020" blog post.
If for some reason your package meets the unpublish policy criteria but the unpublish command fails, or if you need assistance with the deprecate process, please reach out to our support team where we'll be happy to assist.
If you believe a package violates npm's terms or policies, such as our terms of use, reach out to our support team. If a package infringes your copyright, refer to npm's DMCA takedown policy. If you believe a package violates your privacy rights, contact our privacy team as soon as possible.
This is a living document and may be updated from time to time. Please refer to the git history for this document to view the changes.
Copyright (C) npm, Inc., All rights reserved
This document may be reused under a Creative Commons Attribution-ShareAlike License.
This policy describes how we at npm, Inc., the company behind npmjs.com and the npm public registry, respond to claims that materials users have submitted to our service infringe copyright.
npm follows GitHub's Copyright - DMCA Takedown Policy. Please carefully review that policy along with GitHub's Guide to Submitting a DMCA Takedown Notice to determine if you should submit a DMCA takedown.
If you are ready to submit a DMCA takedown notice, the fastest way to get a response is to enter your information and answer all the questions on GitHub's Copyright claims form. Be sure to select the option indicating that your claim involves content on npm.js.
You can also send an email notification to copyright@github.com. You may include an attachment if you like, but please also include a plain-text version of your letter in the body of your message.
If you must send your notice by physical mail, you can do that too, but it will take substantially longer for us to receive and respond to it. Notices we receive via plain-text email have a much faster turnaround than PDF attachments or physical mail. If you still wish to mail us your notice, GitHub's physical address is:
GitHub, Inc
Attn: DMCA Agent
88 Colin P Kelly Jr St
San Francisco, CA. 94107
This policy describes npm logos and trademarks and how you may use them. For information on what to do if someone infringes a trademark of yours with a confusing package name, see the Disputes policy.
The npm project contains two main parts:
"npm" and the npm logos are trademarks owned by npm, Inc. We have developed this policy to make it clear how other businesses and projects can (and cannot) use the npm name and logos.
"Nominative" or "referential" use means to refer to something or someone else by their trademark. So it's perfectly OK to use "npm" to refer to npm, Inc., the npm client, npm code, and the npm public registry. A referential use is generally going to be in a sentence or sentence fragment, like "first install the npm client," or in a book or article title. The use should not be attention-getting or potentially misperceived as suggesting "npm" is your own name, project, product or services.
It is not a referential use to incorporate the letters "npm" or any of the npm logos in the name or logo for your own company or its projects, products, services or social media handles.
If you need to use "npm" to indicate compatibility, you should use "npm" after your own product or service name and an accurate preposition:
You need to ask for permission for any uses not described. When in doubt about your use of the npm name or logo, please contact npm, Inc. for clarification.
We like to make it easy for anyone to use the npm name or logo for community-oriented efforts that help spread and improve npm. We are therefore likely to grant permission to use the npm name and logo in the following ways:
Any other requests are not likely to be granted licenses, but feel free to ask.
Our npm Logos are very recognizable and deserve special treatment. In short, the npm logos represent only npm and should not be used to represent your products. The npm Logos signify us, or a special relationship with us, and you may use them only with our permission. Since the goal is to avoid confusion about you being us, or your relationship with us, context counts. We will consider requests on a case-by-case basis.
Like the npm Logo, the npm Wombat graphic is a very recognizable part of the npm brand, and signifies a special relationship with the npm project, service, or company. It should never be used except with explicit written permission. We will consider requests on a case-by-case basis.
Please be advised that the Wombat and the logos generally may not be used to refer to the project, service, or company in a nominative sense, as any usage will almost always imply a special relationship with npm.
This is a living document and may be updated from time to time. Please refer to the git history for this document to view the changes.
Copyright © npm, Inc.
This document may be reused under a Creative Commons Attribution-ShareAlike License.
Outlined in this document are the practices and policies that npm applies to help ensure that we release stable/secure software, and react appropriately to security threats when they arise.
If you need to report a security vulnerability. Please visit https://npmjs.com/support. If your issue is specific to your account, such as lost credentials or problems with two-factor authentication, contacting our support team is more appropriate.
We review all security reports on the next business day. Note that the npm staff is generally offline for most US holidays, but please do not delay your report! Our off-hours support staff can fix many issues, and will alert our security point of contact if needed.
Any security tickets opened using https://npmjs.com/support will be escalated to the security point of contact, who will delegate incident response activities as appropriate. This is the best and fastest way to contact npm about any security-related matter.
We learn about critical software updates and security threats from a variety of sources:
This is a living document and may be updated from time to time. Please refer to the git history for this document to view the changes.
This document may be reused under a Creative Commons Attribution-ShareAlike License.
npm's full public dataset is available via the public registry. Using CouchDB replication, you can get a full copy of all metadata, and it is acceptable within our terms of use to download copies of tarballs for inspection or experimentation.
npm's website also has package metadata available. We allow this content to be indexed by commercial crawlers such as GoogleBot. At our discretion, we also allow experimental crawlers to access the site, as long as they keep their request velocity to 1 request per second or less. At that velocity, indexing all packages would take 3 days, so if you want a full copy of our metadata it is always going to be faster to access the data via replication, which takes only an hour or two to provide full data and will thereafter automatically stay in sync.
If you do not wish to install CouchDB to manage replication, we provide open source software that makes it easy to sync to the registry's public feed.
If you attempt to access package metadata by high-velocity crawling of the npm website, we reserve the right to rate-limit or ban your IP, user-agent or both.
We put together this page to give an overview of the most common attacks npm faces, a high-level description of how we mitigate those attacks, and links to more information.
This is the most common attack, not just on npm but on any web service. The best way to protect your account is to enable two-factor authentication (2FA). The strongest option is to use a security-key, either built-in to your device or an external hardware key; it binds the authentication to the site you are accessing, making phishing exceedingly difficult. Not everyone has access to a security-key though, so we also support authentication apps that generate one-time passcodes for 2FA.
Because of how common this attack is, and how critical npm packages are to the broader software ecosystem, we have undertaken a phased approach in mandating 2FA for npm package maintainers. This has already rolled out to the top-100 package maintainers and top-500 package maintainers, and in the near future, maintainers of all high-impact packages (those with 1 million+ weekly downloads or 500+ dependents) will be enrolled in mandatory 2FA.
We also recognize that passwords aren’t going away any time soon. For users that don’t opt-in to 2FA, we do an enhanced login verification with a one-time password sent to their email to protect from account takeover.
Another method used to take over an account is by identifying accounts using an expired domain for their email address. An attacker could register the expired domain and recreate the email address used to register the account. With access to an account's registered email address an attacker could take over an account not protected by 2FA via a password reset.
When a package is published the email address associated with the account, at the time the package was published, is included in the public metadata. Attackers are able to utilize this public data to identify accounts that might be susceptible to account takeover. It is important to note that the** email addresses stored in public metadata of packages are not updated when a maintainer updates their email address**. As such crawling public metadata to identify accounts susceptible to expired domain takeover will result in false positives, accounts that appear to be vulnerable but are not.
npm does periodically check if accounts email addresses have expired domains or invalid MX records. When the domain has expired, we disable the account from doing a password reset and require the user to undergo account recovery or go through a successful authentication flow before they can reset their password.
Attackers may attempt to trick others into installing a malicious package by registering a package with a similar name to a popular package, in hopes that people will mistype or otherwise confuse the two. npm is able to detect typosquat attacks and block the publishing of these packages.
A variant of this attack is when a public package is registered with the same name of a private package that an organization is using. We strongly encourage using scoped packages to ensure that a private package isn’t being substituted with one from the public registry. While npm is not able to detect dependency confusion attacks we have a zero tolerance for malicious packages on the registry. If you believe you have identified a dependency confusion package, please let us know!
Rather than tricking people into using a similarly-named package, attackers also try to add malicious behavior to existing popular packages. In partnership with Microsoft, npm both scans packages for known malicious content, and runs the packages to look for new patterns of behavior that could be malicious. This has led to a substantial reduction in malicious content in npm packages. Furthermore, our Trust and Safety team checks and removes malicious content reported by our users. Similar to dependency confusion attacks, we are constantly updating our detection services with new examples, so if you think a package contains malicious behavior, please let us know!
Select CLI Version:
Note: This command is unaware of workspaces.
10.4.0
npm is the package manager for the Node JavaScript platform. It puts modules in place so that node can find them, and manages dependency conflicts intelligently.
It is extremely configurable to support a variety of use cases. Most commonly, you use it to publish, discover, install, and develop node programs.
Run npm help to get a list of available commands.
npm comes preconfigured to use npm's public registry at https://registry.npmjs.org by default. Use of the npm public registry is subject to terms of use available at https://docs.npmjs.com/policies/terms.
You can configure npm to use any compatible registry you like, and even run your own registry. Use of someone else's registry is governed by their terms of use.
You probably got npm because you want to install stuff.
The very first thing you will most likely want to run in any node program is npm install to install its dependencies.
You can also run npm install blerg to install the latest version of "blerg". Check out npm install for more info. It can do a lot of stuff.
Use the npm search command to show everything that's available in the public registry. Use npm ls to show everything you've installed.
If a package lists a dependency using a git URL, npm will install that dependency using the git command and will generate an error if it is not installed.
If one of the packages npm tries to install is a native node module and requires compiling of C++ Code, npm will use node-gyp for that task. For a Unix system, node-gyp needs Python, make and a buildchain like GCC. On Windows, Python and Microsoft Visual Studio C++ are needed. For more information visit the node-gyp repository and the node-gyp Wiki.
See folders to learn about where npm puts stuff.
In particular, npm has two modes of operation:
Local mode is the default. Use -g or --global on any command to run in global mode instead.
If you're using npm to develop and publish your code, check out the following help topics:
npm is extremely configurable. It reads its configuration options from 5 places.
See config for much much more information.
Patches welcome!
If you would like to help, but don't know what to work on, read the contributing guidelines and check the issues list.
When you find issues, please report them: https://github.com/npm/cli/issues
Please be sure to follow the template and bug reporting guidelines.
Discuss new feature ideas on our discussion forum:
Or suggest formal RFC proposals:
Select CLI Version:
Note: This command is unaware of workspaces.
Used to set access controls on private packages.
For all of the subcommands, npm access will perform actions on the packages in the current working directory if no package name is passed to the subcommand.
public / restricted (deprecated): Set a package to be either publicly accessible or restricted.
grant / revoke (deprecated): Add or remove the ability of users and teams to have read-only or read-write access to a package.
2fa-required / 2fa-not-required (deprecated): Configure whether a package requires that anyone publishing it have two-factor authentication enabled on their account.
ls-packages (deprecated): Show all of the packages a user or a team is able to access, along with the access level, except for read-only public packages (it won't print the whole registry listing)
ls-collaborators (deprecated): Show all of the access privileges for a package. Will only show permissions for packages to which you have at least read access. If <user> is passed in, the list is filtered only to teams that user happens to belong to.
edit (not implemented)
npm access always operates directly on the current registry, configurable from the command line using --registry=<registry url>.
Unscoped packages are always public.
Scoped packages default to restricted, but you can either publish them as public using npm publish --access=public, or set their access as public using npm access public after the initial publish.
You must have privileges to set the access of a package:
If you have two-factor authentication enabled then you'll be prompted to provide a second factor, or may use the --otp=... option to specify it on the command line.
If your account is not paid, then attempts to publish scoped packages will fail with an HTTP 402 status code (logically enough), unless you use --access=public.
Management of teams and team memberships is done with the npm team command.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
The base URL of the npm registry.
Select CLI Version:
Note: This command is unaware of workspaces.
Create a new user in the specified registry, and save the credentials to the .npmrc file. If no registry is specified, the default registry will be used (see registry).
When using legacy for your auth-type, the username, password, and email are read in from prompts.
The base URL of the npm registry.
Associate an operation with a scope for a scoped registry.
Useful when logging in to or out of a private registry:
This will cause @mycorp to be mapped to the registry for future installation of packages specified according to the pattern @mycorp/package.
This will also cause npm init to create a scoped package.
What authentication strategy to use with login. Note that if an otp config is given, this value will always be set to legacy.
Select CLI Version:
The audit command submits a description of the dependencies configured in your project to your default registry and asks for a report of known vulnerabilities. If any vulnerabilities are found, then the impact and appropriate remediation will be calculated. If the fix argument is provided, then remediations will be applied to the package tree.
The command will exit with a 0 exit code if no vulnerabilities were found.
Note that some vulnerabilities cannot be fixed automatically and will require manual intervention or review. Also note that since npm audit fix runs a full-fledged npm install under the hood, all configs that apply to the installer will also apply to npm install -- so things like npm audit fix --package-lock-only will work as expected.
By default, the audit command will exit with a non-zero code if any vulnerability is found. It may be useful in CI environments to include the --audit-level parameter to specify the minimum vulnerability level that will cause the command to fail. This option does not filter the report output, it simply changes the command's failure threshold.
By default npm requires a package-lock or shrinkwrap in order to run the audit. You can bypass the package lock with --no-package-lock but be aware the results may be different with every run, since npm will re-build the dependency tree each time.
To ensure the integrity of packages you download from the public npm registry, or any registry that supports signatures, you can verify the registry signatures of downloaded packages using the npm CLI.
Registry signatures can be verified using the following audit command:
The npm CLI supports registry signatures and signing keys provided by any registry if the following conventions are followed:
See this example of a signed package from the public npm registry.
The sig is generated using the following template: ${package.name}@${package.version}:${package.dist.integrity} and the keyid has to match one of the public signing keys below.
Keys response:
See this example key's response from the public npm registry.
There are two audit endpoints that npm may use to fetch vulnerability information: the Bulk Advisory endpoint and the Quick Audit endpoint.
As of version 7, npm uses the much faster Bulk Advisory endpoint to optimize the speed of calculating audit results.
npm will generate a JSON payload with the name and list of versions of each package in the tree, and POST it to the default configured registry at the path /-/npm/v1/security/advisories/bulk.
Any packages in the tree that do not have a version field in their package.json file will be ignored. If any --omit options are specified (either via the --omit config, or one of the shorthands such as --production, --only=dev, and so on), then packages will be omitted from the submitted payload as appropriate.
If the registry responds with an error, or with an invalid response, then npm will attempt to load advisory data from the Quick Audit endpoint.
The expected result will contain a set of advisory objects for each dependency that matches the advisory range. Each advisory object contains a name, url, id, severity, vulnerable_versions, and title.
npm then uses these advisory objects to calculate vulnerabilities and meta-vulnerabilities of the dependencies within the tree.
If the Bulk Advisory endpoint returns an error, or invalid data, npm will attempt to load advisory data from the Quick Audit endpoint, which is considerably slower in most cases.
The full package tree as found in package-lock.json is submitted, along with the following pieces of additional metadata:
All packages in the tree are submitted to the Quick Audit endpoint. Omitted dependency types are skipped when generating the report.
Out of an abundance of caution, npm versions 5 and 6 would "scrub" any packages from the submitted report if their name contained a / character, so as to avoid leaking the names of potentially private packages or git URLs.
However, in practice, this resulted in audits often failing to properly detect meta-vulnerabilities, because the tree would appear to be invalid due to missing dependencies, and prevented the detection of vulnerabilities in package trees that used git dependencies or private modules.
This scrubbing has been removed from npm as of version 7.
npm uses the @npmcli/metavuln-calculator module to turn a set of security advisories into a set of "vulnerability" objects. A "meta-vulnerability" is a dependency that is vulnerable by virtue of dependence on vulnerable versions of a vulnerable package.
For example, if the package foo is vulnerable in the range >=1.0.2 <2.0.0, and the package bar depends on foo@^1.1.0, then that version of bar can only be installed by installing a vulnerable version of foo. In this case, bar is a "metavulnerability".
Once metavulnerabilities for a given package are calculated, they are cached in the ~/.npm folder and only re-evaluated if the advisory range changes, or a new version of the package is published (in which case, the new version is checked for metavulnerable status as well).
If the chain of metavulnerabilities extends all the way to the root project, and it cannot be updated without changing its dependency ranges, then npm audit fix will require the --force option to apply the remediation. If remediations do not require changes to the dependency ranges, then all vulnerable packages will be updated to a version that does not have an advisory or metavulnerability posted against it.
The npm audit command will exit with a 0 exit code if no vulnerabilities were found. The npm audit fix command will exit with 0 exit code if no vulnerabilities are found or if the remediation is able to successfully fix all vulnerabilities.
If vulnerabilities were found the exit code will depend on the audit-level config.
Scan your project for vulnerabilities and automatically install any compatible updates to vulnerable dependencies:
Run audit fix without modifying node_modules, but still updating the pkglock:
Skip updating devDependencies:
Have audit fix install SemVer-major updates to toplevel dependencies, not just SemVer-compatible ones:
Do a dry run to get an idea of what audit fix will do, and also output install information in JSON format:
Scan your project for vulnerabilities and just show the details, without fixing anything:
Get the detailed audit report in JSON format:
Fail an audit only if the results include a vulnerability with a level of moderate or higher:
The minimum level of vulnerability for npm audit to exit with a non-zero exit code.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
If set to true, the current operation will only use the package-lock.json, ignoring node_modules.
For update this means only the package-lock.json will be updated, instead of checking node_modules and downloading dependencies.
For list this means the output will be based on the tree described by the package-lock.json, rather than the contents of node_modules.
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
This command tries to guess at the likely location of a package's bug tracker URL or the mailto URL of the support email, and then tries to open it using the --browser config param. If no package name is provided, it will search for a package.json in the current folder and use the name property.
The browser that is called by npm commands to open websites.
Set to false to suppress browser behavior and instead print urls to terminal.
Set to true to use default system URL opener.
The base URL of the npm registry.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Select CLI Version:
Note: This command is unaware of workspaces.
Used to add, list, or clean the npm cache folder.
add: Add the specified packages to the local cache. This command is primarily intended to be used internally by npm, but it can provide a way to add data to the local installation cache explicitly.
clean: Delete all data out of the cache folder. Note that this is typically unnecessary, as npm's cache is self-healing and resistant to data corruption issues.
verify: Verify the contents of the cache folder, garbage collecting any unneeded data, and verifying the integrity of the cache index and all cached data.
npm stores cache data in an opaque directory within the configured cache, named _cacache. This directory is a cacache-based content-addressable cache that stores all http request data as well as other package-related data. This directory is primarily accessed through pacote, the library responsible for all package fetching as of npm@5.
All data that passes through the cache is fully verified for integrity on both insertion and extraction. Cache corruption will either trigger an error, or signal to pacote that the data must be refetched, which it will do automatically. For this reason, it should never be necessary to clear the cache for any reason other than reclaiming disk space, thus why clean now requires --force to run.
There is currently no method exposed through npm to inspect or directly manage the contents of this cache. In order to access it, cacache must be used directly.
npm will not remove data by itself: the cache will grow as new packages are installed.
The npm cache is strictly a cache: it should not be relied upon as a persistent and reliable data store for package data. npm makes no guarantee that a previously-cached piece of data will be available later, and will automatically delete corrupted contents. The primary guarantee that the cache makes is that, if it does return data, that data will be exactly the data that was inserted.
To run an offline verification of existing cache contents, use npm cache verify.
The location of npm's cache directory.
Select CLI Version:
This command is similar to npm install, except it's meant to be used in automated environments such as test platforms, continuous integration, and deployment -- or any situation where you want to make sure you're doing a clean install of your dependencies.
The main differences between using npm install and npm ci are:
NOTE: If you create your package-lock.json file by running npm install with flags that can affect the shape of your dependency tree, such as --legacy-peer-deps or --install-links, you must provide the same flags to npm ci or you are likely to encounter errors. An easy way to do this is to run, for example, npm config set legacy-peer-deps=true --location=project and commit the .npmrc file to your repo.
Make sure you have a package-lock and an up-to-date install:
Run npm ci in that project
Configure Travis CI to build using npm ci instead of npm install:
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
Note: This command is unaware of workspaces.
Enables tab-completion in all npm commands.
The synopsis above loads the completions into your current shell. Adding it to your ~/.bashrc or ~/.zshrc will make the completions available everywhere:
You may of course also pipe the output of npm completion to a file such as /usr/local/etc/bash_completion.d/npm or /etc/bash_completion.d/npm if you have a system that will read that file for you.
When COMP_CWORD, COMP_LINE, and COMP_POINT are defined in the environment, npm completion acts in "plumbing mode", and outputs completions based on the arguments.
Select CLI Version:
Note: This command is unaware of workspaces.
npm gets its config settings from the command line, environment variables, npmrc files, and in some cases, the package.json file.
See npmrc for more information about the npmrc files.
See config for a more thorough explanation of the mechanisms involved, and a full list of config options available.
The npm config command can be used to update and edit the contents of the user and global npmrc files.
Config supports the following sub-commands:
Sets each of the config keys to the value provided. Modifies the user configuration file unless location is passed.
If value is omitted, the key will be removed from your config file entirely.
Note: for backwards compatibility, npm config set key value is supported as an alias for npm config set key=value.
Echo the config value(s) to stdout.
If multiple keys are provided, then the values will be prefixed with the key names.
If no keys are provided, then this command behaves the same as npm config list.
Show all the config settings. Use -l to also show defaults. Use --json to show the settings in json format.
Deletes the specified keys from all configuration files.
Opens the config file in an editor. Use the --global flag to edit the global config.
Attempts to repair invalid configuration items. Usually this means attaching authentication config (i.e. _auth, _authToken) to the configured registry.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
The command to run for npm edit and npm config edit.
When passed to npm config this refers to which config file to use.
When set to "global" mode, packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Show extended information in ls, search, and help-search.
Select CLI Version:
Searches the local package tree and attempts to simplify the overall structure by moving dependencies further up the tree, where they can be more effectively shared by multiple dependent packages.
For example, consider this dependency graph:
In this case, npm dedupe will transform the tree to:
Because of the hierarchical nature of node's module lookup, b and d will both get their dependency met by the single c package at the root level of the tree.
In some cases, you may have a dependency graph like this:
During the installation process, the c@1.0.3 dependency for b was placed in the root of the tree. Though d's dependency on c@1.x could have been satisfied by c@1.0.3, the newer c@1.9.0 dependency was used, because npm favors updates by default, even when doing so causes duplication.
Running npm dedupe will cause npm to note the duplication and re-evaluate, deleting the nested c module, because the one in the root is sufficient.
To prefer deduplication over novelty during the installation process, run npm install --prefer-dedupe or npm config set prefer-dedupe true.
Arguments are ignored. Dedupe always acts on the entire tree.
Note that this operation transforms the dependency tree, but will never result in new modules being installed.
Using npm find-dupes will run the command in --dry-run mode.
Note: npm dedupe will never update the semver values of direct dependencies in your project package.json, if you want to update values in package.json you can run: npm update --save instead.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
Note: This command is unaware of workspaces.
This command will update the npm registry entry for a package, providing a deprecation warning to all who attempt to install it.
It works on version ranges as well as specific versions, so you can do something like this:
SemVer ranges passed to this command are interpreted such that they do include prerelease versions. For example:
In this case, a version my-thing@1.0.0-beta.0 will also be deprecated.
You must be the package owner to deprecate something. See the owner and adduser help topics.
To un-deprecate a package, specify an empty string ("") for the message argument. Note that you must use double quotes with no space between them to format an empty string.
The base URL of the npm registry.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Select CLI Version:
Similar to its git diff counterpart, this command will print diff patches of files for packages published to the npm registry.
npm diff --diff=<spec-a> --diff=<spec-b>
Compares two package versions using their registry specifiers, e.g: npm diff --diff=pkg@1.0.0 --diff=pkg@^2.0.0. It's also possible to compare across forks of any package, e.g: npm diff --diff=pkg@1.0.0 --diff=pkg-fork@1.0.0.
Any valid spec can be used, so that it's also possible to compare directories or git repositories, e.g: npm diff --diff=pkg@latest --diff=./packages/pkg
Here's an example comparing two different versions of a package named abbrev from the registry:
On success, output looks like:
Given the flexible nature of npm specs, you can also target local directories or git repos just like when using npm install:
In the example above we can compare the contents from the package installed from the git repo at github.com/npm/libnpmdiff with the contents of the ./local-path that contains a valid package, such as a modified copy of the original.
npm diff (in a package directory, no arguments):
If the package is published to the registry, npm diff will fetch the tarball version tagged as latest (this value can be configured using the tag option) and proceed to compare the contents of files present in that tarball, with the current files in your local file system.
This workflow provides a handy way for package authors to see what package-tracked files have been changed in comparison with the latest published version of that package.
npm diff --diff=<pkg-name> (in a package directory):
When using a single package name (with no version or tag specifier) as an argument, npm diff will work in a similar way to npm-outdated and reach for the registry to figure out what current published version of the package named <pkg-name> will satisfy its dependent declared semver-range. Once that specific version is known npm diff will print diff patches comparing the current version of <pkg-name> found in the local file system with that specific version returned by the registry.
Given a package named abbrev that is currently installed:
That will request from the registry its most up to date version and will print a diff output comparing the currently installed version to this newer one if the version numbers are not the same.
npm diff --diff=<spec-a> (in a package directory):
Similar to using only a single package name, it's also possible to declare a full registry specifier version if you wish to compare the local version of an installed package with the specific version/tag/semver-range provided in <spec-a>.
An example: assuming pkg@1.0.0 is installed in the current node_modules folder, running:
It will effectively be an alias to npm diff --diff=pkg@1.0.0 --diff=pkg@2.0.0.
npm diff --diff=<semver-a> [--diff=<semver-b>] (in a package directory):
Using npm diff along with semver-valid version numbers is a shorthand to compare different versions of the current package.
It needs to be run from a package directory, such that for a package named pkg running npm diff --diff=1.0.0 --diff=1.0.1 is the same as running npm diff --diff=pkg@1.0.0 --diff=pkg@1.0.1.
If only a single argument <version-a> is provided, then the current local file system is going to be compared against that version.
Here's an example comparing two specific versions (published to the configured registry) of the current project directory:
Note that tag names are not valid --diff argument values, if you wish to compare to a published tag, you must use the pkg@tagname syntax.
It's possible to also specify positional arguments using file names or globs pattern matching in order to limit the result of diff patches to only a subset of files for a given package, e.g:
In the example above the diff output is only going to print contents of files located within the folder ./lib/ and changed lines of code within the CHANGELOG.md file.
Define arguments to compare in npm diff.
Prints only filenames when using npm diff.
The number of lines of context to print in npm diff.
Ignore whitespace when comparing lines in npm diff.
Do not show any source or destination prefix in npm diff output.
Note: this causes npm diff to ignore the --diff-src-prefix and --diff-dst-prefix configs.
Source prefix to be used in npm diff output.
Destination prefix to be used in npm diff output.
Treat all files as text in npm diff.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
If you ask npm to install a package and don't tell it a specific version, then it will install the specified tag.
Also the tag that is added to the package@version specified by the npm tag command, if no explicit tag is given.
When used by the npm diff command, this is the tag used to fetch the tarball that will be compared with the local files by default.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Select CLI Version:
Add, remove, and enumerate distribution tags on a package:
add: Tags the specified version of the package with the specified tag, or the --tag config if not specified. If you have two-factor authentication on auth-and-writes then you’ll need to include a one-time password on the command line with --otp <one-time password>, or go through a second factor flow based on your authtype.
rm: Clear a tag that is no longer in use from the package. If you have two-factor authentication on auth-and-writes then you’ll need to include a one-time password on the command line with --otp <one-time password>, or go through a second factor flow based on your authtype
ls: Show all of the dist-tags for a package, defaulting to the package in the current prefix. This is the default action if none is specified.
A tag can be used when installing packages as a reference to a version instead of using a specific version number:
When installing dependencies, a preferred tagged version may be specified:
(This also applies to any other commands that resolve and install dependencies, such as npm dedupe, npm update, and npm audit fix.)
Publishing a package sets the latest tag to the published version unless the --tag option is used. For example, npm publish --tag=beta.
By default, npm install <pkg> (without any @<version> or @<tag> specifier) installs the latest tag.
Tags can be used to provide an alias instead of version numbers.
For example, a project might choose to have multiple streams of development and use a different tag for each stream, e.g., stable, beta, dev, canary.
By default, the latest tag is used by npm to identify the current version of a package, and npm install <pkg> (without any @<version> or @<tag> specifier) installs the latest tag. Typically, projects only use the latest tag for stable release versions, and use other tags for unstable versions such as prereleases.
The next tag is used by some projects to identify the upcoming version.
Other than latest, no tag has any special significance to npm itself.
This command used to be known as npm tag, which only created new tags, and so had a different syntax.
Tags must share a namespace with version numbers, because they are specified in the same slot: npm install <pkg>@<version> vs npm install <pkg>@<tag>.
Tags that can be interpreted as valid semver ranges will be rejected. For example, v1.4 cannot be used as a tag, because it is interpreted by semver as >=1.4.0 <1.5.0. See https://github.com/npm/npm/issues/6082.
The simplest way to avoid semver problems with tags is to use tags that do not begin with a number or the letter v.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Select CLI Version:
This command tries to guess at the likely location of a package's documentation URL, and then tries to open it using the --browser config param. You can pass multiple package names at once. If no package name is provided, it will search for a package.json in the current folder and use the name property.
The browser that is called by npm commands to open websites.
Set to false to suppress browser behavior and instead print urls to terminal.
Set to true to use default system URL opener.
The base URL of the npm registry.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Select CLI Version:
Note: This command is unaware of workspaces.
npm doctor runs a set of checks to ensure that your npm installation has what it needs to manage your JavaScript packages. npm is mostly a standalone tool, but it does have some basic requirements that must be met:
Without all of these working properly, npm may not work properly. Many issues are often attributable to things that are outside npm's code base, so npm doctor confirms that the npm installation is in a good state.
Also, in addition to this, there are also very many issue reports due to using old versions of npm. Since npm is constantly improving, running npm@latest is better than an old version.
npm doctor verifies the following items in your environment, and if there are any recommended changes, it will display them. By default npm runs all of these checks. You can limit what checks are ran by specifying them as extra arguments.
By default, npm installs from the primary npm registry, registry.npmjs.org. npm doctor hits a special ping endpoint within the registry. This can also be checked with npm ping. If this check fails, you may be using a proxy that needs to be configured, or may need to talk to your IT staff to get access over HTTPS to registry.npmjs.org.
This check is done against whichever registry you've configured (you can see what that is by running npm config get registry), and if you're using a private registry that doesn't support the /whoami endpoint supported by the primary registry, this check may fail.
While Node.js may come bundled with a particular version of npm, it's the policy of the CLI team that we recommend all users run npm@latest if they can. As the CLI is maintained by a small team of contributors, there are only resources for a single line of development, so npm's own long-term support releases typically only receive critical security and regression fixes. The team believes that the latest tested version of npm is almost always likely to be the most functional and defect-free version of npm.
For most users, in most circumstances, the best version of Node will be the latest long-term support (LTS) release. Those of you who want access to new ECMAscript features or bleeding-edge changes to Node's standard library may be running a newer version, and some may be required to run an older version of Node because of enterprise change control policies. That's OK! But in general, the npm team recommends that most users run Node.js LTS.
You may be installing from private package registries for your project or company. That's great! Others may be following tutorials or StackOverflow questions in an effort to troubleshoot problems you may be having. Sometimes, this may entail changing the registry you're pointing at. This part of npm doctor just lets you, and maybe whoever's helping you with support, know that you're not using the default registry.
While it's documented in the README, it may not be obvious that npm needs Git installed to do many of the things that it does. Also, in some cases – especially on Windows – you may have Git set up in such a way that it's not accessible via your PATH so that npm can find it. This check ensures that Git is available.
When an npm package is published, the publishing process generates a checksum that npm uses at install time to verify that the package didn't get corrupted in transit. npm doctor uses these checksums to validate the package tarballs in your local cache (you can see where that cache is located with npm config get cache). In the event that there are corrupt packages in your cache, you should probably run npm cache clean -f and reset the cache.
The base URL of the npm registry.
Select CLI Version:
Note: This command is unaware of workspaces.
Selects a dependency in the current project and opens the package folder in the default editor (or whatever you've configured as the npm editor config -- see npm-config.)
After it has been edited, the package is rebuilt so as to pick up any changes in compiled packages.
For instance, you can do npm install connect to install connect into your package, and then npm edit connect to make a few changes to your locally installed copy.
The command to run for npm edit and npm config edit.
Select CLI Version:
This command allows you to run an arbitrary command from an npm package (either one installed locally, or fetched remotely), in a similar context as running it via npm run.
Run without positional arguments or --call, this allows you to interactively run commands in the same sort of shell environment that package.json scripts are run. Interactive mode is not supported in CI environments when standard input is a TTY, to prevent hangs.
Whatever packages are specified by the --package option will be provided in the PATH of the executed command, along with any locally installed package executables. The --package option may be specified multiple times, to execute the supplied command in an environment where all specified packages are available.
If any requested packages are not present in the local project dependencies, then a prompt is printed, which can be suppressed by providing either --yes or --no. When standard input is not a TTY or a CI environment is detected, --yes is assumed. The requested packages are installed to a folder in the npm cache, which is added to the PATH environment variable in the executed process.
Package names provided without a specifier will be matched with whatever version exists in the local project. Package names with a specifier will only be considered a match if they have the exact same name and version as the local dependency.
If no -c or --call option is provided, then the positional arguments are used to generate the command string. If no --package options are provided, then npm will attempt to determine the executable name from the package specifier provided as the first positional argument according to the following heuristic:
To run a binary other than the named binary, specify one or more --package options, which will prevent npm from inferring the package from the first command argument.
When run via the npx binary, all flags and options must be set prior to any positional arguments. When run via npm exec, a double-hyphen -- flag can be used to suppress npm's parsing of switches and options that should be sent to the executed command.
For example:
In this case, npm will resolve the foo package name, and run the following command:
Since the --package option comes after the positional arguments, it is treated as an argument to the executed command.
In contrast, due to npm's argument parsing logic, running this command is different:
In this case, npm will parse the --package option first, resolving the @npmcli/foo package. Then, it will execute the following command in that context:
The double-hyphen character is recommended to explicitly tell npm to stop parsing command line options and switches. The following command would thus be equivalent to the npx command above:
The package or packages to install for npm exec
Optional companion option for npm exec, npx that allows for specifying a custom command to be run along with the installed packages.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Run the version of tap in the local dependencies, with the provided arguments:
Run a command other than the command whose name matches the package name by specifying a --package option:
Run an arbitrary shell script, in the context of the current project:
You may use the workspace or workspaces configs in order to run an arbitrary command from an npm package (either one installed locally, or fetched remotely) in the context of the specified workspaces. If no positional argument or --call option is provided, it will open an interactive subshell in the context of each of these configured workspaces one at a time.
Given a project with configured workspaces, e.g:
Assuming the workspace configuration is properly set up at the root level package.json file. e.g:
You can execute an arbitrary command from a package in the context of each of the configured workspaces when using the workspaces config options, in this example we're using eslint to lint any js file found within each workspace folder:
It's also possible to execute a command in a single workspace using the workspace config along with a name or directory path:
The workspace config can also be specified multiple times in order to run a specific script in the context of multiple workspaces. When defining values for the workspace config in the command line, it also possible to use -w as a shorthand, e.g:
This last command will run the eslint command in both ./packages/a and ./packages/b folders.
The npx binary was rewritten in npm v7.0.0, and the standalone npx package deprecated at that time. npx uses the npm exec command instead of a separate argument parser and install process, with some affordances to maintain backwards compatibility with the arguments it accepted in previous versions.
This resulted in some shifts in its functionality:
The npm cli utilizes its internal package cache when using the package name specified. You can use the following to change how and when the cli uses this cache. See npm cache for more on how the cache works.
Forces staleness checks for packages, making the cli look for updates immediately even if the package is already in the cache.
Bypasses staleness checks for packages. Missing data will still be requested from the server. To force full offline mode, use offline.
Forces full offline mode. Any packages not locally cached will result in an error.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
This value is not exported to the environment for child processes.
Run scripts in the context of all configured workspaces for the current project.
Select CLI Version:
This command will print the chain of dependencies causing a given package to be installed in the current project.
If one or more package specs are provided, then only packages matching one of the specifiers will have their relationships explained.
The package spec can also refer to a folder within ./node_modules
For example, running npm explain glob within npm's source tree will show:
To explain just the package residing at a specific folder, pass that as the argument to the command. This can be useful when trying to figure out exactly why a given dependency is being duplicated to satisfy conflicting version requirements within the project.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Select CLI Version:
Note: This command is unaware of workspaces.
Spawn a subshell in the directory of the installed package specified.
If a command is specified, then it is run in the subshell, which then immediately terminates.
This is particularly handy in the case of git submodules in the node_modules folder:
Note that the package is not automatically rebuilt afterwards, so be sure to use npm rebuild <pkg> if you make any changes.
The shell to run for the npm explore command.
Select CLI Version:
Runs npm dedupe in --dry-run mode, making npm only output the duplications, without actually changing the package tree.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
This command retrieves information on how to fund the dependencies of a given project. If no package name is provided, it will list all dependencies that are looking for funding in a tree structure, listing the type of funding and the url to visit. If a package name is provided then it tries to open its funding url using the --browser config param; if there are multiple funding sources for the package, the user will be instructed to pass the --which option to disambiguate.
The list will avoid duplicated entries and will stack all packages that share the same url as a single entry. Thus, the list does not have the same shape of the output from npm ls.
It's possible to filter the results to only include a single workspace and its dependencies using the workspace config option.
Here's an example running npm fund in a project with a configured workspace a:
And here is an example of the expected result when filtering only by a specific workspace a in the same project:
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
The browser that is called by npm commands to open websites.
Set to false to suppress browser behavior and instead print urls to terminal.
Set to true to use default system URL opener.
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
If there are multiple funding sources, which 1-indexed source URL to open.
Select CLI Version:
Note: This command is unaware of workspaces.
If supplied a topic, then show the appropriate documentation page.
If the topic does not exist, or if multiple terms are provided, then npm will run the help-search command to find a match. Note that, if help-search finds a single subject, then it will run help on that topic, so unique matches are equivalent to specifying a topic name.
The program to use to view help content.
Set to "browser" to view html help content in the default web browser.
Select CLI Version:
Note: This command is unaware of workspaces.
This command will search the npm markdown documentation files for the terms provided, and then list the results, sorted by relevance.
If only one result is found, then it will show that help topic.
If the argument to npm help is not a known help topic, then it will call help-search. It is rarely if ever necessary to call this command directly.
Show extended information in ls, search, and help-search.
Select CLI Version:
Note: This command is unaware of workspaces.
Allows you to manage npm hooks, including adding, removing, listing, and updating.
Hooks allow you to configure URL endpoints that will be notified whenever a change happens to any of the supported entity types. Three different types of entities can be watched by hooks: packages, owners, and scopes.
To create a package hook, simply reference the package name.
To create an owner hook, prefix the owner name with ~ (as in, ~youruser).
To create a scope hook, prefix the scope name with @ (as in, @yourscope).
The hook id used by update and rm are the IDs listed in npm hook ls for that particular hook.
The shared secret will be sent along to the URL endpoint so you can verify the request came from your own configured hook.
Add a hook to watch a package for changes:
Add a hook to watch packages belonging to the user substack:
Add a hook to watch packages in the scope @npm
List all your active hooks:
List your active hooks for the lodash package:
Update an existing hook's url:
Remove a hook:
The base URL of the npm registry.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Select CLI Version:
npm init <initializer> can be used to set up a new or existing npm package.
initializer in this case is an npm package named create-<initializer>, which will be installed by npm-exec, and then have its main bin executed -- presumably creating or updating package.json and running any other initialization-related operations.
The init command is transformed to a corresponding npm exec operation as follows:
If the initializer is omitted (by just calling npm init), init will fall back to legacy init behavior. It will ask you a bunch of questions, and then write a package.json for you. It will attempt to make reasonable guesses based on existing fields, dependencies, and options selected. It is strictly additive, so it will keep any fields and values that were already set. You can also use -y/--yes to skip the questionnaire altogether. If you pass --scope, it will create a scoped package.
Note: if a user already has the create-<initializer> package globally installed, that will be what npm init uses. If you want npm to use the latest version, or another specific version you must specify it:
Any additional options will be passed directly to the command, so npm init foo -- --hello will map to npm exec -- create-foo --hello.
To better illustrate how options are forwarded, here's a more evolved example showing options passed to both the npm cli and a create package, both following commands are equivalent:
Create a new React-based project using create-react-app:
Create a new esm-compatible package using create-esm:
Generate a plain old package.json using legacy init:
Generate it without having it ask any questions:
It's possible to create a new workspace within your project by using the workspace config option. When using npm init -w <dir> the cli will create the folders and boilerplate expected while also adding a reference to your project package.json "workspaces": [] property in order to make sure that new generated workspace is properly set up as such.
Given a project with no workspaces, e.g:
You may generate a new workspace using the legacy init:
That will generate a new folder and package.json file, while also updating your top-level package.json to add the reference to this new workspace:
The workspaces init also supports the npm init <initializer> -w <dir> syntax, following the same set of rules explained earlier in the initial Description section of this page. Similar to the previous example of creating a new React-based project using create-react-app, the following syntax will make sure to create the new react app as a nested workspace within your project and configure your package.json to recognize it as such:
This will make sure to generate your react app as expected, one important consideration to have in mind is that npm exec is going to be run in the context of the newly created folder for that workspace, and that's the reason why in this example the initializer uses the initializer name followed with a dot to represent the current directory in that context, e.g: react-app .:
The value npm init should use by default for the package author's name.
The value npm init should use by default for the package author's homepage.
The value npm init should use by default for the package license.
A module that will be loaded by the npm init command. See the documentation for the init-package-json module for more information, or npm init.
The value that npm init should use by default for the package version number, if not already set in package.json.
Automatically answer "yes" to any prompts that npm might print on the command line.
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
Associate an operation with a scope for a scoped registry.
Useful when logging in to or out of a private registry:
This will cause @mycorp to be mapped to the registry for future installation of packages specified according to the pattern @mycorp/package.
This will also cause npm init to create a scoped package.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
If set to true, the npm cli will run an update after operations that may possibly change the workspaces installed to the node_modules folder.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Select CLI Version:
This command installs a package and any packages that it depends on. If the package has a package-lock, or an npm shrinkwrap file, or a yarn lock file, the installation of dependencies will be driven by that, respecting the following order of precedence:
See package-lock.json and npm shrinkwrap.
A package is:
Even if you never publish your package, you can still get a lot of benefits of using npm if you just want to write a node program (a), and perhaps if you also want to be able to easily install it elsewhere after packing it up into a tarball (b).
npm install (in a package directory, no arguments):
Install the dependencies to the local node_modules folder.
In global mode (ie, with -g or --global appended to the command), it installs the current package context (ie, the current working directory) as a global package.
By default, npm install will install all modules listed as dependencies in package.json.
With the --production flag (or when the NODE_ENV environment variable is set to production), npm will not install modules listed in devDependencies. To install all modules listed in both dependencies and devDependencies when NODE_ENV environment variable is set to production, you can use --production=false.
NOTE: The --production flag has no particular meaning when adding a dependency to a project.
npm install <folder>:
If <folder> sits inside the root of your project, its dependencies will be installed and may be hoisted to the top-level node_modules as they would for other types of dependencies. If <folder> sits outside the root of your project, npm will not install the package dependencies in the directory <folder>, but it will create a symlink to <folder>.
NOTE: If you want to install the content of a directory like a package from the registry instead of creating a link, you would need to use the --install-links option.
Example:
npm install <tarball file>:
Install a package that is sitting on the filesystem. Note: if you just want to link a dev directory into your npm root, you can do this more easily by using npm link.
Tarball requirements:
Example:
npm install <tarball url>:
Fetch the tarball url, and then install it. In order to distinguish between this and other options, the argument must start with "http://" or "https://"
Example:
npm install [<@scope>/]<name>:
Do a <name>@<tag> install, where <tag> is the "tag" config. (See config. The config's default value is latest.)
In most cases, this will install the version of the modules tagged as latest on the npm registry.
Example:
npm install saves any specified packages into dependencies by default. Additionally, you can control where and how they get saved with some additional flags:
-P, --save-prod: Package will appear in your dependencies. This is the default unless -D or -O are present.
-D, --save-dev: Package will appear in your devDependencies.
-O, --save-optional: Package will appear in your optionalDependencies.
--no-save: Prevents saving to dependencies.
When using any of the above options to save dependencies to your package.json, there are two additional, optional flags:
-E, --save-exact: Saved dependencies will be configured with an exact version rather than using npm's default semver range operator.
-B, --save-bundle: Saved dependencies will also be added to your bundleDependencies list.
Further, if you have an npm-shrinkwrap.json or package-lock.json then it will be updated as well.
<scope> is optional. The package will be downloaded from the registry associated with the specified scope. If no registry is associated with the given scope the default registry is assumed. See scope.
Note: if you do not include the @-symbol on your scope name, npm will interpret this as a GitHub repository instead, see below. Scopes names must also be followed by a slash.
Examples:
Note: If there is a file or folder named <name> in the current working directory, then it will try to install that, and only try to fetch the package by name if it is not valid.
npm install <alias>@npm:<name>:
Install a package under a custom alias. Allows multiple versions of a same-name package side-by-side, more convenient import names for packages with otherwise long ones, and using git forks replacements or forked npm packages as replacements. Aliasing works only on your project and does not rename packages in transitive dependencies. Aliases should follow the naming conventions stated in validate-npm-package-name.
Examples:
npm install [<@scope>/]<name>@<tag>:
Install the version of the package that is referenced by the specified tag. If the tag does not exist in the registry data for that package, then this will fail.
Example:
npm install [<@scope>/]<name>@<version>:
Install the specified version of the package. This will fail if the version has not been published to the registry.
Example:
npm install [<@scope>/]<name>@<version range>:
Install a version of the package matching the specified version range. This will follow the same rules for resolving dependencies described in package.json.
Note that most version ranges must be put in quotes so that your shell will treat it as a single argument.
Example:
npm install <git remote url>:
Installs the package from the hosted git provider, cloning it with git. For a full git remote url, only that URL will be attempted.
<protocol> is one of git, git+ssh, git+http, git+https, or git+file.
If #<commit-ish> is provided, it will be used to clone exactly that commit. If the commit-ish has the format #semver:<semver>, <semver> can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither #<commit-ish> or #semver:<semver> is specified, then the default branch of the repository is used.
If the repository makes use of submodules, those submodules will be cloned as well.
If the package being installed contains a prepare script, its dependencies and devDependencies will be installed, and the prepare script will be run, before the package is packaged and installed.
The following git environment variables are recognized by npm and will be added to the environment when running git:
See the git man page for details.
Examples:
npm install <githubname>/<githubrepo>[#<commit-ish>]:
npm install github:<githubname>/<githubrepo>[#<commit-ish>]:
Install the package at https://github.com/githubname/githubrepo by attempting to clone it using git.
If #<commit-ish> is provided, it will be used to clone exactly that commit. If the commit-ish has the format #semver:<semver>, <semver> can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither #<commit-ish> or #semver:<semver> is specified, then the default branch is used.
As with regular git dependencies, dependencies and devDependencies will be installed if the package has a prepare script before the package is done installing.
Examples:
npm install gist:[<githubname>/]<gistID>[#<commit-ish>|#semver:<semver>]:
Install the package at https://gist.github.com/gistID by attempting to clone it using git. The GitHub username associated with the gist is optional and will not be saved in package.json.
As with regular git dependencies, dependencies and devDependencies will be installed if the package has a prepare script before the package is done installing.
Example:
npm install bitbucket:<bitbucketname>/<bitbucketrepo>[#<commit-ish>]:
Install the package at https://bitbucket.org/bitbucketname/bitbucketrepo by attempting to clone it using git.
If #<commit-ish> is provided, it will be used to clone exactly that commit. If the commit-ish has the format #semver:<semver>, <semver> can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither #<commit-ish> or #semver:<semver> is specified, then master is used.
As with regular git dependencies, dependencies and devDependencies will be installed if the package has a prepare script before the package is done installing.
Example:
npm install gitlab:<gitlabname>/<gitlabrepo>[#<commit-ish>]:
Install the package at https://gitlab.com/gitlabname/gitlabrepo by attempting to clone it using git.
If #<commit-ish> is provided, it will be used to clone exactly that commit. If the commit-ish has the format #semver:<semver>, <semver> can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither #<commit-ish> or #semver:<semver> is specified, then master is used.
As with regular git dependencies, dependencies and devDependencies will be installed if the package has a prepare script before the package is done installing.
Example:
You may combine multiple arguments and even multiple types of arguments. For example:
The --tag argument will apply to all of the specified install targets. If a tag with the given name exists, the tagged version is preferred over newer versions.
The --dry-run argument will report in the usual way what the install would have done without actually installing anything.
The --package-lock-only argument will only update the package-lock.json, instead of checking node_modules and downloading dependencies.
The -f or --force argument will force npm to fetch remote resources even if a local copy exists on disk.
See the config help doc. Many of the configuration params have some effect on installation, since that's most of what npm does.
These are some of the most common options related to installation.
Save installed packages to a package.json file as dependencies.
When used with the npm rm command, removes the dependency from package.json.
Will also prevent writing to package-lock.json if set to false.
Dependencies saved to package.json will be configured with an exact version rather than using npm's default semver range operator.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
Prefer to deduplicate packages if possible, rather than choosing a newer version of a dependency.
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
If set to true, the current operation will only use the package-lock.json, ignoring node_modules.
For update this means only the package-lock.json will be updated, instead of checking node_modules and downloading dependencies.
For list this means the output will be based on the tree described by the package-lock.json, rather than the contents of node_modules.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Override CPU architecture of native modules to install. Acceptable values are same as cpu field of package.json, which comes from process.arch.
Override OS of native modules to install. Acceptable values are same as os field of package.json, which comes from process.platform.
Override libc of native modules to install. Acceptable values are same as libc field of package.json
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Given a package{dep} structure: A{B,C}, B{C}, C{D}, the npm install algorithm produces:
That is, the dependency from B to C is satisfied by the fact that A already caused C to be installed at a higher level. D is still installed at the top level because nothing conflicts with it.
For A{B,C}, B{C,D@1}, C{D@2}, this algorithm produces:
Because B's D@1 will be installed in the top-level, C now has to install D@2 privately for itself. This algorithm is deterministic, but different trees may be produced if two dependencies are requested for installation in a different order.
See folders for a more detailed description of the specific folder structures that npm creates.
Select CLI Version:
This command runs npm ci followed immediately by npm test.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
This command runs an npm install followed immediately by an npm test. It takes exactly the same arguments as npm install.
Save installed packages to a package.json file as dependencies.
When used with the npm rm command, removes the dependency from package.json.
Will also prevent writing to package-lock.json if set to false.
Dependencies saved to package.json will be configured with an exact version rather than using npm's default semver range operator.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
Prefer to deduplicate packages if possible, rather than choosing a newer version of a dependency.
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
If set to true, the current operation will only use the package-lock.json, ignoring node_modules.
For update this means only the package-lock.json will be updated, instead of checking node_modules and downloading dependencies.
For list this means the output will be based on the tree described by the package-lock.json, rather than the contents of node_modules.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Override CPU architecture of native modules to install. Acceptable values are same as cpu field of package.json, which comes from process.arch.
Override OS of native modules to install. Acceptable values are same as os field of package.json, which comes from process.platform.
Override libc of native modules to install. Acceptable values are same as libc field of package.json
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
This is handy for installing your own stuff, so that you can work on it and test iteratively without having to continually rebuild.
Package linking is a two-step process.
First, npm link in a package folder with no arguments will create a symlink in the global folder {prefix}/lib/node_modules/<package> that links to the package where the npm link command was executed. It will also link any bins in the package to {prefix}/bin/{name}. Note that npm link uses the global prefix (see npm prefix -g for its value).
Next, in some other location, npm link package-name will create a symbolic link from globally-installed package-name to node_modules/ of the current folder.
Note that package-name is taken from package.json, not from the directory name.
The package name can be optionally prefixed with a scope. See scope. The scope must be preceded by an @-symbol and followed by a slash.
When creating tarballs for npm publish, the linked packages are "snapshotted" to their current state by resolving the symbolic links, if they are included in bundleDependencies.
For example:
Now, any changes to ~/projects/node-redis will be reflected in ~/projects/node-bloggy/node_modules/node-redis/. Note that the link should be to the package name, not the directory name for that package.
You may also shortcut the two steps in one. For example, to do the above use-case in a shorter way:
The second line is the equivalent of doing:
That is, it first creates a global link, and then links the global installation target into your project's node_modules folder.
Note that in this case, you are referring to the directory name, node-redis, rather than the package name redis.
If your linked package is scoped (see scope) your link command must include that scope, e.g.
Note that package dependencies linked in this way are not saved to package.json by default, on the assumption that the intention is to have a link stand in for a regular non-link dependency. Otherwise, for example, if you depend on redis@^3.0.1, and ran npm link redis, it would replace the ^3.0.1 dependency with file:../path/to/node-redis, which you probably don't want! Additionally, other users or developers on your project would run into issues if they do not have their folders set up exactly the same as yours.
If you are adding a new dependency as a link, you should add it to the relevant metadata by running npm install <dep> --package-lock-only.
If you want to save the file: reference in your package.json and package-lock.json files, you can use npm link <dep> --save to do so.
npm link <pkg> --workspace <name> will link the relevant package as a dependency of the specified workspace(s). Note that It may actually be linked into the parent project's node_modules folder, if there are no conflicting dependencies.
npm link --workspace <name> will create a global link to the specified workspace(s).
Save installed packages to a package.json file as dependencies.
When used with the npm rm command, removes the dependency from package.json.
Will also prevent writing to package-lock.json if set to false.
Dependencies saved to package.json will be configured with an exact version rather than using npm's default semver range operator.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
Note: This command is unaware of workspaces.
Verify a user in the specified registry, and save the credentials to the .npmrc file. If no registry is specified, the default registry will be used (see config).
When using legacy for your auth-type, the username and password, are read in from prompts.
To reset your password, go to https://www.npmjs.com/forgot
To change your email address, go to https://www.npmjs.com/email-edit
You may use this command multiple times with the same user account to authorize on a new machine. When authenticating on a new machine, the username, password and email address must all match with your existing record.
The base URL of the npm registry.
Associate an operation with a scope for a scoped registry.
Useful when logging in to or out of a private registry:
This will cause @mycorp to be mapped to the registry for future installation of packages specified according to the pattern @mycorp/package.
This will also cause npm init to create a scoped package.
What authentication strategy to use with login. Note that if an otp config is given, this value will always be set to legacy.
Select CLI Version:
Note: This command is unaware of workspaces.
When logged into a registry that supports token-based authentication, tell the server to end this token's session. This will invalidate the token everywhere you're using it, not just for the current environment.
When logged into a legacy registry that uses username and password authentication, this will clear the credentials in your user configuration. In this case, it will only affect the current environment.
If --scope is provided, this will find the credentials for the registry connected to that scope, if set.
The base URL of the npm registry.
Associate an operation with a scope for a scoped registry.
Useful when logging in to or out of a private registry:
This will cause @mycorp to be mapped to the registry for future installation of packages specified according to the pattern @mycorp/package.
This will also cause npm init to create a scoped package.
Select CLI Version:
This command will print to stdout all the versions of packages that are installed, as well as their dependencies when --all is specified, in a tree structure.
Note: to get a "bottoms up" view of why a given package is included in the tree at all, use npm explain.
Positional arguments are name@version-range identifiers, which will limit the results to only the paths to the packages named. Note that nested packages will also show the paths to the specified packages. For example, running npm ls promzard in npm's source tree will show:
It will print out extraneous, missing, and invalid packages.
If a project specifies git urls for dependencies these are shown in parentheses after the name@version to make it easier for users to recognize potential forks of a project.
The tree shown is the logical dependency tree, based on package dependencies, not the physical layout of your node_modules folder.
When run as ll or la, it shows extended information by default.
The npm ls command's output and behavior made a ton of sense when npm created a node_modules folder that naively nested every dependency. In such a case, the logical dependency graph and physical tree of packages on disk would be roughly identical.
With the advent of automatic install-time deduplication of dependencies in npm v3, the ls output was modified to display the logical dependency graph as a tree structure, since this was more useful to most users. However, without using npm ls -l, it became impossible to show where a package was actually installed much of the time!
With the advent of automatic installation of peerDependencies in npm v7, this gets even more curious, as peerDependencies are logically "underneath" their dependents in the dependency graph, but are always physically at or above their location on disk.
Also, in the years since npm got an ls command (in version 0.0.2!), dependency graphs have gotten much larger as a general rule. Therefore, in order to avoid dumping an excessive amount of content to the terminal, npm ls now only shows the top level dependencies, unless --all is provided.
A thorough re-examination of the use cases, intention, behavior, and output of this command, is currently underway. Expect significant changes to at least the default human-readable npm ls output in npm v8.
When running npm outdated and npm ls, setting --all will show all outdated or installed packages, rather than only those directly depended upon by the current project.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Show extended information in ls, search, and help-search.
Output parseable results from commands that write to standard output. For npm search, this will be tab-separated table format.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
The depth to go when recursing packages for npm ls.
If not set, npm ls will show only the immediate dependencies of the root project. If --all is set, then npm will show all dependencies by default.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
Used with npm ls, limiting output to only those packages that are linked.
If set to true, the current operation will only use the package-lock.json, ignoring node_modules.
For update this means only the package-lock.json will be updated, instead of checking node_modules and downloading dependencies.
For list this means the output will be based on the tree described by the package-lock.json, rather than the contents of node_modules.
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
Note: This command is unaware of workspaces.
Add a new developer to an org:
Add a new admin to an org (or change a developer to an admin):
Remove a user from an org:
List all users in an org:
List all users in JSON format:
See what role a user has in an org:
You can use the npm org commands to manage and view users of an organization. It supports adding and removing users, changing their roles, listing them, and finding specific ones and their roles.
The base URL of the npm registry.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Output parseable results from commands that write to standard output. For npm search, this will be tab-separated table format.
Select CLI Version:
This command will check the registry to see if any (or, specific) installed packages are currently outdated.
By default, only the direct dependencies of the root project and direct dependencies of your configured workspaces are shown. Use --all to find all outdated meta-dependencies as well.
In the output:
With these dependencies:
A few things to note:
When running npm outdated and npm ls, setting --all will show all outdated or installed packages, rather than only those directly depended upon by the current project.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Show extended information in ls, search, and help-search.
Output parseable results from commands that write to standard output. For npm search, this will be tab-separated table format.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Select CLI Version:
Manage ownership of published packages.
Note that there is only one level of access. Either you can modify a package, or you can't. Future versions may contain more fine-grained access levels, but that is not implemented at this time.
If you have two-factor authentication enabled with auth-and-writes (see npm-profile) then you'll need to go through a second factor flow when changing ownership or include an otp on the command line with --otp.
The base URL of the npm registry.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Select CLI Version:
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Directory in which npm pack will save tarballs.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
For anything that's installable (that is, a package folder, tarball, tarball url, git url, name@tag, name@version, name, or scoped name), this command will fetch it to the cache, copy the tarball to the current working directory as <name>-<version>.tgz, and then write the filenames out to stdout.
If the same package is specified multiple times, then the file will be overwritten the second time.
If no arguments are supplied, then npm packs the current package folder.
Select CLI Version:
Note: This command is unaware of workspaces.
Ping the configured or given npm registry and verify authentication. If it works it will output something like:
otherwise you will get an error:
The base URL of the npm registry.
Select CLI Version:
A command that automates the management of package.json files. npm pkg provide 3 different sub commands that allow you to modify or retrieve values for given object keys in your package.json.
The syntax to retrieve and set fields is a dot separated representation of the nested object properties to be found within your package.json, it's the same notation used in npm view to retrieve information from the registry manifest, below you can find more examples on how to use it.
Returned values are always in json format.
npm pkg get <field>
Retrieves a value key, defined in your package.json file.
For example, in order to retrieve the name of the current package, you can run:
It's also possible to retrieve multiple values at once:
You can view child fields by separating them with a period. To retrieve the value of a test script value, you would run the following command:
For fields that are arrays, requesting a non-numeric field will return all of the values from the objects in the list. For example, to get all the contributor emails for a package, you would run:
You may also use numeric indices in square braces to specifically select an item in an array field. To just get the email address of the first contributor in the list, you can run:
For complex fields you can also name a property in square brackets to specifically select a child field. This is especially helpful with the exports object:
npm pkg set <field>=<value>
Sets a value in your package.json based on the field value. When saving to your package.json file the same set of rules used during npm install and other cli commands that touches the package.json file are used, making sure to respect the existing indentation and possibly applying some validation prior to saving values to the file.
The same syntax used to retrieve values from your package can also be used to define new properties or overriding existing ones, below are some examples of how the dot separated syntax can be used to edit your package.json file.
Defining a new bin named mynewcommand in your package.json that points to a file cli.js:
Setting multiple fields at once is also possible:
It's also possible to add to array values, for example to add a new contributor entry:
You may also append items to the end of an array using the special empty bracket notation:
It's also possible to parse values as json prior to saving them to your package.json file, for example in order to set a "private": true property:
It also enables saving values as numbers:
npm pkg delete <key>
Deletes a key from your package.json
The same syntax used to set values from your package can also be used to remove existing ones. For example, in order to remove a script named build:
npm pkg fix
Auto corrects common errors in your package.json. npm already does this during publish, which leads to subtle (mostly harmless) differences between the contents of your package.json file and the manifest that npm uses during installation.
You can set/get/delete items across your configured workspaces by using the workspace or workspaces config options.
For example, setting a funding value across all configured workspaces of a project:
When using npm pkg get to retrieve info from your configured workspaces, the returned result will be in a json format in which top level keys are the names of each workspace, the values of these keys will be the result values returned from each of the configured workspaces, e.g:
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Select CLI Version:
Note: This command is unaware of workspaces.
Print the local prefix to standard output. This is the closest parent directory to contain a package.json file or node_modules directory, unless -g is also specified.
If -g is specified, this will be the value of the global prefix. See npm config for more detail.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Select CLI Version:
Note: This command is unaware of workspaces.
Change your profile information on the registry. Note that this command depends on the registry implementation, so third-party registries may not support this interface.
npm profile set <property> <value>: Set the value of a profile property. You can set the following properties this way: email, fullname, homepage, freenode, twitter, github
npm profile set password: Change your password. This is interactive, you'll be prompted for your current password and a new password. You'll also be prompted for an OTP if you have two-factor authentication enabled.
npm profile enable-2fa [auth-and-writes|auth-only]: Enables two-factor authentication. Defaults to auth-and-writes mode. Modes are:
npm profile disable-2fa: Disables two-factor authentication.
Some of these commands may not be available on non npmjs.com registries.
The base URL of the npm registry.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Output parseable results from commands that write to standard output. For npm search, this will be tab-separated table format.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Select CLI Version:
This command removes "extraneous" packages. If a package name is provided, then only packages matching one of the supplied names are removed.
Extraneous packages are those present in the node_modules folder that are not listed as any package's dependency list.
If the --omit=dev flag is specified or the NODE_ENV environment variable is set to production, this command will remove the packages specified in your devDependencies.
If the --dry-run flag is used then no changes will actually be made.
If the --json flag is used, then the changes npm prune made (or would have made with --dry-run) are printed as a JSON object.
In normal operation, extraneous modules are pruned automatically, so you'll only need this command with the --production flag. However, in the real world, operation is not always "normal". When crashes or mistakes happen, this command can help clean up any resulting garbage.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
Publishes a package to the registry so that it can be installed by name.
By default npm will publish to the public registry. This can be overridden by specifying a different default registry or using a scope in the name, combined with a scope-configured registry (see package.json).
A package is interpreted the same way as other commands (like npm install) and can be:
The publish will fail if the package name and version combination already exists in the specified registry.
Once a package is published with a given name and version, that specific name and version combination can never be used again, even if it is removed with npm unpublish.
As of npm@5, both a sha1sum and an integrity field with a sha512sum of the tarball will be submitted to the registry during publication. Subsequent installs will use the strongest supported algorithm to verify downloads.
Similar to --dry-run see npm pack, which figures out the files to be included and packs them into a tarball to be uploaded to the registry.
To see what will be included in your package, run npm pack --dry-run. All files are included by default, with the following exceptions:
Certain files that are relevant to package installation and distribution are always included. For example, package.json, README.md, LICENSE, and so on.
If there is a "files" list in package.json, then only the files specified will be included. (If directories are specified, then they will be walked recursively and their contents included, subject to the same ignore rules.)
If there is a .gitignore or .npmignore file, then ignored files in that and all child directories will be excluded from the package. If both files exist, then the .gitignore is ignored, and only the .npmignore is used.
.npmignore files follow the same pattern rules as .gitignore files
If the file matches certain patterns, then it will never be included, unless explicitly added to the "files" list in package.json, or un-ignored with a ! rule in a .npmignore or .gitignore file.
Symbolic links are never included in npm packages.
See developers for full details on what's included in the published package, as well as details on how the package is built.
If you ask npm to install a package and don't tell it a specific version, then it will install the specified tag.
Also the tag that is added to the package@version specified by the npm tag command, if no explicit tag is given.
When used by the npm diff command, this is the tag used to fetch the tarball that will be compared with the local files by default.
If you do not want your scoped package to be publicly viewable (and installable) set --access=restricted.
Unscoped packages can not be set to restricted.
Note: This defaults to not changing the current access level for existing packages. Specifying a value of restricted or public during publish will change the access for an existing package the same way that npm access set status would.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When publishing from a supported cloud CI/CD system, the package will be publicly linked to where it was built and published from.
This config can not be used with: provenance-file
When publishing, the provenance bundle at the given path will be used.
This config can not be used with: provenance
Select CLI Version:
The npm query command allows for usage of css selectors in order to retrieve an array of dependency objects.
If package-lock-only is enabled, only the information in the package lock (or shrinkwrap) is loaded. This means that information from the package.json files of your dependencies will not be included in the result set (e.g. description, homepage, engines).
If package-lock-only is enabled, only the information in the package lock (or shrinkwrap) is loaded. This means that information from the package.json files of your dependencies will not be included in the result set (e.g. description, homepage, engines).
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
If set to true, the current operation will only use the package-lock.json, ignoring node_modules.
For update this means only the package-lock.json will be updated, instead of checking node_modules and downloading dependencies.
For list this means the output will be based on the tree described by the package-lock.json, rather than the contents of node_modules.
Select CLI Version:
This command does the following:
This command is particularly useful in scenarios including but not limited to:
If one or more package specs are provided, then only packages with a name and version matching one of the specifiers will be rebuilt.
Usually, you should not need to run npm rebuild as it is already done for you as part of npm install (unless you suppressed these steps with --ignore-scripts or --no-bin-links).
If there is a binding.gyp file in the root of your package, then npm will use a default install hook:
This default behavior is suppressed if the package.json has its own install or preinstall scripts. It is also suppressed if the package specifies "gypfile": false
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
This command tries to guess at the likely location of a package's repository URL, and then tries to open it using the --browser config param. If no package name is provided, it will search for a package.json in the current folder and use the repository property.
The browser that is called by npm commands to open websites.
Set to false to suppress browser behavior and instead print urls to terminal.
Set to true to use default system URL opener.
The base URL of the npm registry.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Select CLI Version:
This restarts a project. It is equivalent to running npm run-script restart.
If the current project has a "restart" script specified in package.json, then the following scripts will be run:
If it does not have a "restart" script specified, but it does have stop and/or start scripts, then the following scripts will be run:
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
The shell to use for scripts run with the npm exec, npm run and npm init <package-spec> commands.
Select CLI Version:
Note: This command is unaware of workspaces.
Print the effective node_modules folder to standard out.
Useful for using npm in shell scripts that do things with the node_modules folder. For example:
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Select CLI Version:
This runs an arbitrary command from a package's "scripts" object. If no "command" is provided, it will list the available scripts.
run[-script] is used by the test, start, restart, and stop commands, but can be called directly, as well. When the scripts in the package are printed out, they're separated into lifecycle (test, start, restart) and directly-run scripts.
Any positional arguments are passed to the specified script. Use -- to pass --prefixed flags and options which would otherwise be parsed by npm.
For example:
The arguments will only be passed to the script specified after npm run and not to any pre or post script.
The env script is a special built-in command that can be used to list environment variables that will be available to the script at runtime. If an "env" command is defined in your package, it will take precedence over the built-in.
In addition to the shell's pre-existing PATH, npm run adds node_modules/.bin to the PATH provided to scripts. Any binaries provided by locally-installed dependencies can be used without the node_modules/.bin prefix. For example, if there is a devDependency on tap in your package, you should write:
instead of
The actual shell your script is run within is platform dependent. By default, on Unix-like systems it is the /bin/sh command, on Windows it is cmd.exe. The actual shell referred to by /bin/sh also depends on the system. You can customize the shell with the script-shell config.
Scripts are run from the root of the package folder, regardless of what the current working directory is when npm run is called. If you want your script to use different behavior based on what subdirectory you're in, you can use the INIT_CWD environment variable, which holds the full path you were in when you ran npm run.
npm run sets the NODE environment variable to the node executable with which npm is executed.
If you try to run a script without having a node_modules directory and it fails, you will be given a warning to run npm install, just in case you've forgotten.
You may use the workspace or workspaces configs in order to run an arbitrary command from a package's "scripts" object in the context of the specified workspaces. If no "command" is provided, it will list the available scripts for each of these configured workspaces.
Given a project with configured workspaces, e.g:
Assuming the workspace configuration is properly set up at the root level package.json file. e.g:
And that each of the configured workspaces has a configured test script, we can run tests in all of them using the workspaces config:
It's also possible to run a script in a single workspace using the workspace config along with a name or directory path:
The workspace config can also be specified multiple times in order to run a specific script in the context of multiple workspaces. When defining values for the workspace config in the command line, it also possible to use -w as a shorthand, e.g:
This last command will run test in both ./packages/a and ./packages/b packages.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
If true, npm will not exit with an error code when run-script is invoked for a script that isn't defined in the scripts section of package.json. This option can be used when it's desirable to optionally run a script when it's present and fail if the script fails. This is useful, for example, when running scripts that may only apply for some builds in an otherwise generic CI setup.
This value is not exported to the environment for child processes.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
The shell to use for scripts run with the npm exec, npm run and npm init <package-spec> commands.
Select CLI Version:
The npm sbom command generates a Software Bill of Materials (SBOM) listing the dependencies for the current project. SBOMs can be generated in either SPDX or CycloneDX format.
If package-lock-only is enabled, only the information in the package lock (or shrinkwrap) is loaded. This means that information from the package.json files of your dependencies will not be included in the result set (e.g. description, homepage, engines).
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
If set to true, the current operation will only use the package-lock.json, ignoring node_modules.
For update this means only the package-lock.json will be updated, instead of checking node_modules and downloading dependencies.
For list this means the output will be based on the tree described by the package-lock.json, rather than the contents of node_modules.
SBOM format to use when generating SBOMs.
The type of package described by the generated SBOM. For SPDX, this is the value for the primaryPackagePurpose field. For CycloneDX, this is the value for the type field.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Select CLI Version:
Note: This command is unaware of workspaces.
Search the registry for packages matching the search terms. npm search performs a linear, incremental, lexically-ordered search through package metadata for all files in the registry. If your terminal has color support, it will further highlight the matches in the results. This can be disabled with the config item color
Additionally, using the --searchopts and --searchexclude options paired with more search terms will include and exclude further patterns. The main difference between --searchopts and the standard search terms is that the former does not highlight results in the output and you can use them more fine-grained filtering. Additionally, you can add both of these to your config to change default search filtering behavior.
Search also allows targeting of maintainers in search results, by prefixing their npm username with =.
If a term starts with /, then it's interpreted as a regular expression and supports standard JavaScript RegExp syntax. In this case search will ignore a trailing / . (Note you must escape or quote many regular expression characters in most shells.)
Show extended information in ls, search, and help-search.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
If false, never shows colors. If "always" then always shows colors. If true, then only prints color codes for tty file descriptors.
Output parseable results from commands that write to standard output. For npm search, this will be tab-separated table format.
Show the description in npm search
Space-separated options that are always passed to search.
Space-separated options that limit the results from search.
The base URL of the npm registry.
If true, staleness checks for cached data will be forced, making the CLI look for updates immediately even for fresh package data.
If true, staleness checks for cached data will be bypassed, but missing data will be requested from the server. To force full offline mode, use --offline.
Force offline mode: no network requests will be done during install. To allow the CLI to fill in missing cache data, see --prefer-offline.
Select CLI Version:
Note: This command is unaware of workspaces.
This command repurposes package-lock.json into a publishable npm-shrinkwrap.json or simply creates a new one. The file created and updated by this command will then take precedence over any other existing or future package-lock.json files. For a detailed explanation of the design and purpose of package locks in npm, see package-lock-json.
Select CLI Version:
Note: This command is unaware of workspaces.
"Starring" a package means that you have some interest in it. It's a vaguely positive way to show that you care.
It's a boolean thing. Starring repeatedly has no additional effect.
There's also these extra commands to help you manage your favorite packages:
You can also "unstar" a package using npm unstar
"Unstarring" is the same thing, but in reverse.
You can see all your starred packages using npm stars
The base URL of the npm registry.
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Select CLI Version:
Note: This command is unaware of workspaces.
If you have starred a lot of neat things and want to find them again quickly this command lets you do just that.
You may also want to see your friend's favorite packages, in this case you will most certainly enjoy this command.
The base URL of the npm registry.
Select CLI Version:
This runs a predefined command specified in the "start" property of a package's "scripts" object.
If the "scripts" object does not define a "start" property, npm will run node server.js.
Note that this is different from the default node behavior of running the file specified in a package's "main" attribute when evoking with node .
As of npm@2.0.0, you can use custom arguments when executing scripts. Refer to npm run-script for more details.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
The shell to use for scripts run with the npm exec, npm run and npm init <package-spec> commands.
Select CLI Version:
This runs a predefined command specified in the "stop" property of a package's "scripts" object.
Unlike with npm start, there is no default script that will run if the "stop" property is not defined.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
The shell to use for scripts run with the npm exec, npm run and npm init <package-spec> commands.
Select CLI Version:
Note: This command is unaware of workspaces.
Used to manage teams in organizations, and change team memberships. Does not handle permissions for packages.
Teams must always be fully qualified with the organization/scope they belong to when operating on them, separated by a colon (:). That is, if you have a newteam team in an org organization, you must always refer to that team as @org:newteam in these commands.
If you have two-factor authentication enabled in auth-and-writes mode, then you can provide a code from your authenticator with [--otp <otpcode>]. If you don't include this then you will be taken through a second factor flow based on your authtype.
create / destroy: Create a new team, or destroy an existing one. Note: You cannot remove the developers team, learn more.
Here's how to create a new team newteam under the org org:
You should see a confirming message such as: +@org:newteam once the new team has been created.
add: Add a user to an existing team.
Adding a new user username to a team named newteam under the org org:
On success, you should see a message: username added to @org:newteam
rm: Using npm team rm you can also remove users from a team they belong to.
Here's an example removing user username from newteam team in org organization:
Once the user is removed a confirmation message is displayed: username removed from @org:newteam
ls: If performed on an organization name, will return a list of existing teams under that organization. If performed on a team, it will instead return a list of all users belonging to that particular team.
Here's an example of how to list all teams from an org named org:
Example listing all members of a team named newteam:
npm team always operates directly on the current registry, configurable from the command line using --registry=<registry url>.
You must be a team admin to create teams and manage team membership, under the given organization. Listing teams and team memberships may be done by any member of the organization.
Organization creation and management of team admins and organization members is done through the website, not the npm CLI.
To use teams to manage permissions on packages belonging to your organization, use the npm access command to grant or revoke the appropriate permissions.
The base URL of the npm registry.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Output parseable results from commands that write to standard output. For npm search, this will be tab-separated table format.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Select CLI Version:
This runs a predefined command specified in the "test" property of a package's "scripts" object.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
The shell to use for scripts run with the npm exec, npm run and npm init <package-spec> commands.
Select CLI Version:
Note: This command is unaware of workspaces.
This lets you list, create and revoke authentication tokens.
npm token create [--read-only] [--cidr=<cidr-ranges>]: Create a new authentication token. It can be --read-only, or accept a list of CIDR ranges with which to limit use of this token. This will prompt you for your password, and, if you have two-factor authentication enabled, an otp.
Currently, the cli can not generate automation tokens. Please refer to the docs website for more information on generating automation tokens.
This is used to mark a token as unable to publish when configuring limited access tokens with the npm token create command.
This is a list of CIDR address to be used when configuring limited access tokens with the npm token create command.
The base URL of the npm registry.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Select CLI Version:
This uninstalls a package, completely removing everything npm installed on its behalf.
It also removes the package from the dependencies, devDependencies, optionalDependencies, and peerDependencies objects in your package.json.
Further, if you have an npm-shrinkwrap.json or package-lock.json, npm will update those files as well.
--no-save will tell npm not to remove the package from your package.json, npm-shrinkwrap.json, or package-lock.json files.
--save or -S will tell npm to remove the package from your package.json, npm-shrinkwrap.json, and package-lock.json files. This is the default, but you may need to use this if you have for instance save=false in your npmrc file
In global mode (ie, with -g or --global appended to the command), it uninstalls the current package context as a global package. --no-save is ignored in this case.
Scope is optional and follows the usual rules for scope.
sax will no longer be in your package.json, npm-shrinkwrap.json, or package-lock.json files.
lodash will not be removed from your package.json, npm-shrinkwrap.json, or package-lock.json files.
Save installed packages to a package.json file as dependencies.
When used with the npm rm command, removes the dependency from package.json.
Will also prevent writing to package-lock.json if set to false.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
To learn more about how the npm registry treats unpublish, see our unpublish policies.
Consider using the deprecate command instead, if your intent is to encourage users to upgrade, or if you no longer want to maintain a package.
This removes a package version from the registry, deleting its entry and removing the tarball.
The npm registry will return an error if you are not logged in.
If you do not specify a package name at all, the name and version to be unpublished will be pulled from the project in the current directory.
If you specify a package name but do not specify a version or if you remove all of a package's versions then the registry will remove the root package entry entirely.
Even if you unpublish a package version, that specific name and version combination can never be reused. In order to publish the package again, you must use a new version number. If you unpublish the entire package, you may not publish any new versions of that package until 24 hours have passed.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Select CLI Version:
Note: This command is unaware of workspaces.
"Unstarring" a package is the opposite of npm star, it removes an item from your list of favorite packages.
There's also these extra commands to help you manage your favorite packages:
You can "star" a package using npm star
You can see all your starred packages using npm stars
The base URL of the npm registry.
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Select CLI Version:
This command will update all the packages listed to the latest version (specified by the tag config), respecting the semver constraints of both your package and its dependencies (if they also require the same package).
It will also install missing packages.
If the -g flag is specified, this command will update globally installed packages.
If no package name is specified, all packages in the specified location (global or local) will be updated.
Note that by default npm update will not update the semver values of direct dependencies in your project package.json. If you want to also update values in package.json you can run: npm update --save (or add the save=true option to a configuration file to make that the default behavior).
For the examples below, assume that the current package is app and it depends on dependencies, dep1 (dep2, .. etc.). The published versions of dep1 are:
If app's package.json contains:
Then npm update will install dep1@1.2.2, because 1.2.2 is latest and 1.2.2 satisfies ^1.1.1.
However, if app's package.json contains:
In this case, running npm update will install dep1@1.1.2. Even though the latest tag points to 1.2.2, this version does not satisfy ~1.1.1, which is equivalent to >=1.1.1 <1.2.0. So the highest-sorting version that satisfies ~1.1.1 is used, which is 1.1.2.
Suppose app has a caret dependency on a version below 1.0.0, for example:
npm update will install dep1@0.2.0.
If the dependence were on ^0.4.0:
Then npm update will install dep1@0.4.1, because that is the highest-sorting version that satisfies ^0.4.0 (>= 0.4.0 <0.5.0)
Suppose your app now also has a dependency on dep2
and dep2 itself depends on this limited range of dep1
Then npm update will install dep1@1.1.2 because that is the highest version that dep2 allows. npm will prioritize having a single version of dep1 in your tree rather than two when that single version can satisfy the semver requirements of multiple dependencies in your tree. In this case if you really did need your package to use a newer version you would need to use npm install.
npm update -g will apply the update action to each globally installed package that is outdated -- that is, has a version that is different from wanted.
Note: Globally installed packages are treated as if they are installed with a caret semver range specified. So if you require to update to latest you may need to run npm install -g [<pkg>...]
NOTE: If a package has been upgraded to a version newer than latest, it will be downgraded.
Save installed packages to a package.json file as dependencies.
When used with the npm rm command, removes the dependency from package.json.
Will also prevent writing to package-lock.json if set to false.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Select CLI Version:
Prevents throwing an error when npm version is used to set the new version to the same value as the current version.
Run git commit hooks when using the npm version command.
Tag the commit when using the npm version command. Setting this to false results in no commit being made at all.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
The "prerelease identifier" to use as a prefix for the "prerelease" part of a semver. Like the rc in 1.2.0-rc.8.
If set to true, then the npm version command will tag the version using -s to add a signature.
Note that git requires you to have set up GPG keys in your git configs for this to work properly.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
If set to true, the npm cli will run an update after operations that may possibly change the workspaces installed to the node_modules folder.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
Run this in a package directory to bump the version and write the new data back to package.json, package-lock.json, and, if present, npm-shrinkwrap.json.
The newversion argument should be a valid semver string, a valid second argument to semver.inc (one of patch, minor, major, prepatch, preminor, premajor, prerelease), or from-git. In the second case, the existing version will be incremented by 1 in the specified field. from-git will try to read the latest git tag, and use that as the new npm version.
If run in a git repo, it will also create a version commit and tag. This behavior is controlled by git-tag-version (see below), and can be disabled on the command line by running npm --no-git-tag-version version. It will fail if the working directory is not clean, unless the -f or --force flag is set.
If supplied with -m or --message config option, npm will use it as a commit message when creating a version commit. If the message config contains %s then that will be replaced with the resulting version number. For example:
If the sign-git-tag config is set, then the tag will be signed using the -s flag to git. Note that you must have a default GPG key set up in your git config for this to work properly. For example:
If preversion, version, or postversion are in the scripts property of the package.json, they will be executed as part of running npm version.
The exact order of execution is as follows:
Take the following example:
This runs all your tests and proceeds only if they pass. Then runs your build script, and adds everything in the dist directory to the commit. After the commit, it pushes the new commit and tag up to the server, and deletes the build/temp directory.
Select CLI Version:
This command shows data about a package and prints it to stdout.
As an example, to view information about the connect package from the registry, you would run:
The default version is "latest" if unspecified.
Field names can be specified after the package descriptor. For example, to show the dependencies of the ronn package at version 0.3.5, you could do the following:
By default, npm view shows data about the current project context (by looking for a package.json). To show field data for the current project use a file path (i.e. .):
You can view child fields by separating them with a period. To view the git repository URL for the latest version of npm, you would run the following command:
This makes it easy to view information about a dependency with a bit of shell scripting. For example, to view all the data about the version of opts that ronn depends on, you could write the following:
For fields that are arrays, requesting a non-numeric field will return all of the values from the objects in the list. For example, to get all the contributor email addresses for the express package, you would run:
You may also use numeric indices in square braces to specifically select an item in an array field. To just get the email address of the first contributor in the list, you can run:
If the field value you are querying for is a property of an object, you should run:
Multiple fields may be specified, and will be printed one after another. For example, to get all the contributor names and email addresses, you can do this:
"Person" fields are shown as a string if they would be shown as an object. So, for example, this will show the list of npm contributors in the shortened string format. (See package.json for more on this.)
If a version range is provided, then data will be printed for every matching version of the package. This will show which version of jsdom was required by each matching version of yui3:
To show the connect package version history, you can do this:
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
If only a single string field for a single version is output, then it will not be colorized or quoted, to enable piping the output to another command. If the field is an object, it will be output as a JavaScript object literal.
If the --json flag is given, the outputted fields will be JSON.
If the version range matches multiple versions then each printed value will be prefixed with the version it applies to.
If multiple fields are requested, then each of them is prefixed with the field name.
Select CLI Version:
Note: This command is unaware of workspaces.
Display the npm username of the currently logged-in user.
If logged into a registry that provides token-based authentication, then connect to the /-/whoami registry endpoint to find the username associated with the token, and print to standard output.
If logged into a registry that uses Basic Auth, then simply print the username portion of the authentication string.
The base URL of the npm registry.
Select CLI Version:
This command allows you to run an arbitrary command from an npm package (either one installed locally, or fetched remotely), in a similar context as running it via npm run.
Whatever packages are specified by the --package option will be provided in the PATH of the executed command, along with any locally installed package executables. The --package option may be specified multiple times, to execute the supplied command in an environment where all specified packages are available.
If any requested packages are not present in the local project dependencies, then they are installed to a folder in the npm cache, which is added to the PATH environment variable in the executed process. A prompt is printed (which can be suppressed by providing either --yes or --no).
Package names provided without a specifier will be matched with whatever version exists in the local project. Package names with a specifier will only be considered a match if they have the exact same name and version as the local dependency.
If no -c or --call option is provided, then the positional arguments are used to generate the command string. If no --package options are provided, then npm will attempt to determine the executable name from the package specifier provided as the first positional argument according to the following heuristic:
To run a binary other than the named binary, specify one or more --package options, which will prevent npm from inferring the package from the first command argument.
When run via the npx binary, all flags and options must be set prior to any positional arguments. When run via npm exec, a double-hyphen -- flag can be used to suppress npm's parsing of switches and options that should be sent to the executed command.
For example:
In this case, npm will resolve the foo package name, and run the following command:
Since the --package option comes after the positional arguments, it is treated as an argument to the executed command.
In contrast, due to npm's argument parsing logic, running this command is different:
In this case, npm will parse the --package option first, resolving the @npmcli/foo package. Then, it will execute the following command in that context:
The double-hyphen character is recommended to explicitly tell npm to stop parsing command line options and switches. The following command would thus be equivalent to the npx command above:
Run the version of tap in the local dependencies, with the provided arguments:
Run a command other than the command whose name matches the package name by specifying a --package option:
Run an arbitrary shell script, in the context of the current project:
The npx binary was rewritten in npm v7.0.0, and the standalone npx package deprecated at that time. npx uses the npm exec command instead of a separate argument parser and install process, with some affordances to maintain backwards compatibility with the arguments it accepted in previous versions.
This resulted in some shifts in its functionality:
Select CLI Version:
To publish and install packages to and from the public npm registry, you must install Node.js and the npm command line interface using either a Node version manager or a Node installer. We strongly recommend using a Node version manager to install Node.js and npm. We do not recommend using a Node installer, since the Node installation process installs npm in a directory with local permissions and can cause permissions errors when you run npm packages globally.
To see if you already have Node.js and npm installed and check the installed version, run the following commands:
Node version managers allow you to install and switch between multiple versions of Node.js and npm on your system so you can test your applications on multiple versions of npm to ensure they work for users on different versions. You can search for them on GitHub.
If you are unable to use a Node version manager, you can use a Node installer to install both Node.js and npm on your system.
If you're using OS X or Windows, use one of the installers from the Node.js download page. Be sure to install the version labeled LTS. Other versions have not yet been tested with npm.
If you're using Linux or another operating system, use one of the following installers:
Or see this page to install npm for Linux in the way many Linux developers prefer.
For more information on installing Node.js on a variety of operating systems, see this page.
Select CLI Version:
npm puts various things on your computer. That's its job.
This document will tell you what it puts where.
The prefix config defaults to the location where node is installed. On most systems, this is /usr/local. On Windows, it's %AppData%\npm. On Unix systems, it's one level up, since node is typically installed at {prefix}/bin/node rather than {prefix}/node.exe.
When the global flag is set, npm installs things into this prefix. When it is not set, it uses the root of the current package, or the current working directory if not in a package already.
Packages are dropped into the node_modules folder under the prefix. When installing locally, this means that you can require("packagename") to load its main module, or require("packagename/lib/path/to/sub/module") to load other modules.
Global installs on Unix systems go to {prefix}/lib/node_modules. Global installs on Windows go to {prefix}/node_modules (that is, no lib folder.)
Scoped packages are installed the same way, except they are grouped together in a sub-folder of the relevant node_modules folder with the name of that scope prefix by the @ symbol, e.g. npm install @myorg/package would place the package in {prefix}/node_modules/@myorg/package. See scope for more details.
If you wish to require() a package, then install it locally.
When in global mode, executables are linked into {prefix}/bin on Unix, or directly into {prefix} on Windows. Ensure that path is in your terminal's PATH environment to run them.
When in local mode, executables are linked into ./node_modules/.bin so that they can be made available to scripts run through npm. (For example, so that a test runner will be in the path when you run npm test.)
When in global mode, man pages are linked into {prefix}/share/man.
When in local mode, man pages are not installed.
Man pages are not installed on Windows systems.
See npm cache. Cache files are stored in ~/.npm on Posix, or %LocalAppData%/npm-cache on Windows.
This is controlled by the cache config param.
Temporary files are stored by default in the folder specified by the tmp config, which defaults to the TMPDIR, TMP, or TEMP environment variables, or /tmp on Unix and c:\windows\temp on Windows.
Temp files are given a unique folder under this root for each run of the program, and are deleted upon successful exit.
When installing locally, npm first tries to find an appropriate prefix folder. This is so that npm install foo@1.2.3 will install to the sensible root of your package, even if you happen to have cded into some other folder.
Starting at the $PWD, npm will walk up the folder tree checking for a folder that contains either a package.json file, or a node_modules folder. If such a thing is found, then that is treated as the effective "current directory" for the purpose of running npm commands. (This behavior is inspired by and similar to git's .git-folder seeking logic when running git commands in a working dir.)
If no package root is found, then the current folder is used.
When you run npm install foo@1.2.3, then the package is loaded into the cache, and then unpacked into ./node_modules/foo. Then, any of foo's dependencies are similarly unpacked into ./node_modules/foo/node_modules/....
Any bin files are symlinked to ./node_modules/.bin/, so that they may be found by npm scripts when necessary.
If the global config is set to true, then npm will install packages "globally".
For global installation, packages are installed roughly the same way, but using the folders described above.
Cycles are handled using the property of node's module system that it walks up the directories looking for node_modules folders. So, at every stage, if a package is already installed in an ancestor node_modules folder, then it is not installed at the current location.
Consider the case above, where foo -> bar -> baz. Imagine if, in addition to that, baz depended on bar, so you'd have: foo -> bar -> baz -> bar -> baz .... However, since the folder structure is: foo/node_modules/bar/node_modules/baz, there's no need to put another copy of bar into .../baz/node_modules, since when baz calls require("bar"), it will get the copy that is installed in foo/node_modules/bar.
This shortcut is only used if the exact same version would be installed in multiple nested node_modules folders. It is still possible to have a/node_modules/b/node_modules/a if the two "a" packages are different versions. However, without repeating the exact same package multiple times, an infinite regress will always be prevented.
Another optimization can be made by installing dependencies at the highest level possible, below the localized "target" folder (hoisting). Since version 3, npm hoists dependencies by default.
Consider this dependency graph:
In this case, we might expect a folder structure like this (with all dependencies hoisted to the highest level possible):
Since foo depends directly on bar@1.2.3 and baz@1.2.3, those are installed in foo's node_modules folder.
Even though the latest copy of blerg is 1.3.7, foo has a specific dependency on version 1.2.5. So, that gets installed at [A]. Since the parent installation of blerg satisfies bar's dependency on blerg@1.x, it does not install another copy under [B].
Bar [B] also has dependencies on baz and asdf. Because it depends on baz@2.x, it cannot re-use the baz@1.2.3 installed in the parent node_modules folder [D], and must install its own copy [C]. In order to minimize duplication, npm hoists dependencies to the top level by default, so asdf is installed under [A].
Underneath bar, the baz -> quux -> bar dependency creates a cycle. However, because bar is already in quux's ancestry [B], it does not unpack another copy of bar into that folder. Likewise, quux's [E] folder tree is empty, because its dependency on bar is satisfied by the parent folder copy installed at [B].
For a graphical breakdown of what is installed where, use npm ls.
Upon publishing, npm will look in the node_modules folder. If any of the items there are not in the bundleDependencies array, then they will not be included in the package tarball.
This allows a package maintainer to install all of their dependencies (and dev dependencies) locally, but only re-publish those items that cannot be found elsewhere. See package.json for more information.
Select CLI Version:
npm gets its config settings from the command line, environment variables, and npmrc files.
The npm config command can be used to update and edit the contents of the user and global npmrc files.
For a list of available configuration options, see config.
The four relevant files are:
All npm config files are an ini-formatted list of key = value parameters. Environment variables can be replaced using ${VARIABLE_NAME}. For example:
Each of these files is loaded, and config options are resolved in priority order. For example, a setting in the userconfig file would override the setting in the globalconfig file.
Array values are specified by adding "[]" after the key name. For example:
Lines in .npmrc files are interpreted as comments when they begin with a ; or # character. .npmrc files are parsed by npm/ini, which specifies this comment syntax.
For example:
When working locally in a project, a .npmrc file in the root of the project (ie, a sibling of node_modules and package.json) will set config values specific to this project.
Note that this only applies to the root of the project that you're running npm in. It has no effect when your module is published. For example, you can't publish a module that forces itself to install globally, or in a different location.
Additionally, this file is not read in global mode, such as when running npm install -g.
$HOME/.npmrc (or the userconfig param, if set in the environment or on the command line)
$PREFIX/etc/npmrc (or the globalconfig param, if set above): This file is an ini-file formatted list of key = value parameters. Environment variables can be replaced as above.
path/to/npm/itself/npmrc
This is an unchangeable "builtin" configuration file that npm keeps consistent across updates. Set fields in here using the ./configure script that comes with npm. This is primarily for distribution maintainers to override default configs in a standard and consistent manner.
The settings _auth, _authToken, username and _password must all be scoped to a specific registry. This ensures that npm will never send credentials to the wrong host.
The full list is:
In order to scope these values, they must be prefixed by a URI fragment. If the credential is meant for any request to a registry on a single host, the scope may look like //registry.npmjs.org/:. If it must be scoped to a specific path on the host that path may also be provided, such as //my-custom-registry.org/unique/path:.
Select CLI Version:
npm-shrinkwrap.json is a file created by npm shrinkwrap. It is identical to package-lock.json, with one major caveat: Unlike package-lock.json, npm-shrinkwrap.json may be included when publishing a package.
The recommended use-case for npm-shrinkwrap.json is applications deployed through the publishing process on the registry: for example, daemons and command-line tools intended as global installs or devDependencies. It's strongly discouraged for library authors to publish this file, since that would prevent end users from having control over transitive dependency updates.
If both package-lock.json and npm-shrinkwrap.json are present in a package root, npm-shrinkwrap.json will be preferred over the package-lock.json file.
For full details and description of the npm-shrinkwrap.json file format, refer to the manual page for package-lock.json.
Select CLI Version:
This document is all you need to know about what's required in your package.json file. It must be actual JSON, not just a JavaScript object literal.
A lot of the behavior described in this document is affected by the config settings described in config.
If you plan to publish your package, the most important things in your package.json are the name and version fields as they will be required. The name and version together form an identifier that is assumed to be completely unique. Changes to the package should come along with changes to the version. If you don't plan to publish your package, the name and version fields are optional.
The name is what your thing is called.
Some rules:
Some tips:
A name can be optionally prefixed by a scope, e.g. @myorg/mypackage. See scope for more detail.
If you plan to publish your package, the most important things in your package.json are the name and version fields as they will be required. The name and version together form an identifier that is assumed to be completely unique. Changes to the package should come along with changes to the version. If you don't plan to publish your package, the name and version fields are optional.
Version must be parseable by node-semver, which is bundled with npm as a dependency. (npm install semver to use it yourself.)
Put a description in it. It's a string. This helps people discover your package, as it's listed in npm search.
Put keywords in it. It's an array of strings. This helps people discover your package as it's listed in npm search.
The url to the project homepage.
Example:
The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.
It should look like this:
You can specify either one or both values. If you want to provide only a url, you can specify the value for "bugs" as a simple string instead of an object.
If a url is provided, it will be used by the npm bugs command.
You should specify a license for your package so that people know how they are permitted to use it, and any restrictions you're placing on it.
If you're using a common license such as BSD-2-Clause or MIT, add a current SPDX license identifier for the license you're using, like this:
You can check the full list of SPDX license IDs. Ideally you should pick one that is OSI approved.
If your package is licensed under multiple common licenses, use an SPDX license expression syntax version 2.0 string, like this:
If you are using a license that hasn't been assigned an SPDX identifier, or if you are using a custom license, use a string value like this one:
Then include a file named <filename> at the top level of the package.
Some old packages used license objects or a "licenses" property containing an array of license objects:
Those styles are now deprecated. Instead, use SPDX expressions, like this:
Finally, if you do not wish to grant others the right to use a private or unpublished package under any terms:
Consider also setting "private": true to prevent accidental publication.
The "author" is one person. "contributors" is an array of people. A "person" is an object with a "name" field and optionally "url" and "email", like this:
Or you can shorten that all into a single string, and npm will parse it for you:
Both email and url are optional either way.
npm also sets a top-level "maintainers" field with your npm user info.
You can specify an object containing a URL that provides up-to-date information about ways to help fund development of your package, or a string URL, or an array of these:
Users can use the npm fund subcommand to list the funding URLs of all dependencies of their project, direct and indirect. A shortcut to visit each funding url is also available when providing the project name such as: npm fund <projectname> (when there are multiple URLs, the first one will be visited)
The optional files field is an array of file patterns that describes the entries to be included when your package is installed as a dependency. File patterns follow a similar syntax to .gitignore, but reversed: including a file, directory, or glob pattern (*, **/*, and such) will make it so that file is included in the tarball when it's packed. Omitting the field will make it default to ["*"], which means it will include all files.
Some special files and directories are also included or excluded regardless of whether they exist in the files array (see below).
You can also provide a .npmignore file in the root of your package or in subdirectories, which will keep files from being included. At the root of your package it will not override the "files" field, but in subdirectories it will. The .npmignore file works just like a .gitignore. If there is a .gitignore file, and .npmignore is missing, .gitignore's contents will be used instead.
Certain files are always included, regardless of settings:
README & LICENSE can have any case and extension.
Some files are always ignored by default:
Most of these ignored files can be included specifically if included in the files globs. Exceptions to this are:
These can not be included.
The main field is a module ID that is the primary entry point to your program. That is, if your package is named foo, and a user installs it, and then does require("foo"), then your main module's exports object will be returned.
This should be a module relative to the root of your package folder.
For most modules, it makes the most sense to have a main script and often not much else.
If main is not set, it defaults to index.js in the package's root folder.
If your module is meant to be used client-side the browser field should be used instead of the main field. This is helpful to hint users that it might rely on primitives that aren't available in Node.js modules. (e.g. window)
A lot of packages have one or more executable files that they'd like to install into the PATH. npm makes this pretty easy (in fact, it uses this feature to install the "npm" executable.)
To use this, supply a bin field in your package.json which is a map of command name to local file name. When this package is installed globally, that file will be either linked inside the global bins directory or a cmd (Windows Command File) will be created which executes the specified file in the bin field, so it is available to run by name or name.cmd (on Windows PowerShell). When this package is installed as a dependency in another package, the file will be linked where it will be available to that package either directly by npm exec or by name in other scripts when invoking them via npm run-script.
For example, myapp could have this:
So, when you install myapp, in case of unix-like OS it'll create a symlink from the cli.js script to /usr/local/bin/myapp and in case of windows it will create a cmd file usually at C:\Users\{Username}\AppData\Roaming\npm\myapp.cmd which runs the cli.js script.
If you have a single executable, and its name should be the name of the package, then you can just supply it as a string. For example:
would be the same as this:
Please make sure that your file(s) referenced in bin starts with #!/usr/bin/env node, otherwise the scripts are started without the node executable!
Note that you can also set the executable files using directories.bin.
See folders for more info on executables.
Specify either a single file or an array of filenames to put in place for the man program to find.
If only a single file is provided, then it's installed such that it is the result from man <pkgname>, regardless of its actual filename. For example:
would link the ./man/doc.1 file in such that it is the target for man foo
If the filename doesn't start with the package name, then it's prefixed. So, this:
will create files to do man foo and man foo-bar.
Man files must end with a number, and optionally a .gz suffix if they are compressed. The number dictates which man section the file is installed into.
will create entries for man foo and man 2 foo
The CommonJS Packages spec details a few ways that you can indicate the structure of your package using a directories object. If you look at npm's package.json, you'll see that it has directories for doc, lib, and man.
In the future, this information may be used in other creative ways.
If you specify a bin directory in directories.bin, all the files in that folder will be added.
Because of the way the bin directive works, specifying both a bin path and setting directories.bin is an error. If you want to specify individual files, use bin, and for all the files in an existing bin directory, use directories.bin.
A folder that is full of man pages. Sugar to generate a "man" array by walking the folder.
Specify the place where your code lives. This is helpful for people who want to contribute. If the git repo is on GitHub, then the npm docs command will be able to find you.
Do it like this:
The URL should be a publicly available (perhaps read-only) url that can be handed directly to a VCS program without any modification. It should not be a url to an html project page that you put in your browser. It's for computers.
For GitHub, GitHub gist, Bitbucket, or GitLab repositories you can use the same shortcut syntax you use for npm install:
If the package.json for your package is not in the root directory (for example if it is part of a monorepo), you can specify the directory in which it lives:
The "scripts" property is a dictionary containing script commands that are run at various times in the lifecycle of your package. The key is the lifecycle event, and the value is the command to run at that point.
See scripts to find out more about writing package scripts.
A "config" object can be used to set configuration parameters used in package scripts that persist across upgrades. For instance, if a package had the following:
It could also have a "start" command that referenced the npm_package_config_port environment variable.
Dependencies are specified in a simple object that maps a package name to a version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.
Please do not put test harnesses or transpilers or other "development" time tools in your dependencies object. See devDependencies, below.
See semver for more details about specifying version ranges.
For example, these are all valid:
You may specify a tarball URL in place of a version range.
This tarball will be downloaded and installed locally to your package at install time.
Git urls are of the form:
<protocol> is one of git, git+ssh, git+http, git+https, or git+file.
If #<commit-ish> is provided, it will be used to clone exactly that commit. If the commit-ish has the format #semver:<semver>, <semver> can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither #<commit-ish> or #semver:<semver> is specified, then the default branch is used.
Examples:
When installing from a git repository, the presence of certain fields in the package.json will cause npm to believe it needs to perform a build. To do so your repository will be cloned into a temporary directory, all of its deps installed, relevant scripts run, and the resulting directory packed and installed.
This flow will occur if your git dependency uses workspaces, or if any of the following scripts are present:
If your git repository includes pre-built artifacts, you will likely want to make sure that none of the above scripts are defined, or your dependency will be rebuilt for every installation.
As of version 1.1.65, you can refer to GitHub urls as just "foo": "user/foo-project". Just as with git URLs, a commit-ish suffix can be included. For example:
As of version 2.0.0 you can provide a path to a local directory that contains a package. Local paths can be saved using npm install -S or npm install --save, using any of these forms:
in which case they will be normalized to a relative path and added to your package.json. For example:
This feature is helpful for local offline development and creating tests that require npm installing where you don't want to hit an external server, but should not be used when publishing your package to the public registry.
note: Packages linked by local path will not have their own dependencies installed when npm install is ran in this case. You must run npm install from inside the local path itself.
If someone is planning on downloading and using your module in their program, then they probably don't want or need to download and build the external test or documentation framework that you use.
In this case, it's best to map these additional items in a devDependencies object.
These things will be installed when doing npm link or npm install from the root of a package, and can be managed like any other npm configuration param. See config for more on the topic.
For build steps that are not platform-specific, such as compiling CoffeeScript or other languages to JavaScript, use the prepare script to do this, and make the required package a devDependency.
For example:
The prepare script will be run before publishing, so that users can consume the functionality without requiring them to compile it themselves. In dev mode (ie, locally running npm install), it'll run this script as well, so that you can test it easily.
In some cases, you want to express the compatibility of your package with a host tool or library, while not necessarily doing a require of this host. This is usually referred to as a plugin. Notably, your module may be exposing a specific interface, expected and specified by the host documentation.
For example:
This ensures your package tea-latte can be installed along with the second major version of the host package tea only. npm install tea-latte could possibly yield the following dependency graph:
In npm versions 3 through 6, peerDependencies were not automatically installed, and would raise a warning if an invalid version of the peer dependency was found in the tree. As of npm v7, peerDependencies are installed by default.
Trying to install another plugin with a conflicting requirement may cause an error if the tree cannot be resolved correctly. For this reason, make sure your plugin requirement is as broad as possible, and not to lock it down to specific patch versions.
Assuming the host complies with semver, only changes in the host package's major version will break your plugin. Thus, if you've worked with every 1.x version of the host package, use "^1.0" or "1.x" to express this. If you depend on features introduced in 1.5.2, use "^1.5.2".
When a user installs your package, npm will emit warnings if packages specified in peerDependencies are not already installed. The peerDependenciesMeta field serves to provide npm more information on how your peer dependencies are to be used. Specifically, it allows peer dependencies to be marked as optional.
For example:
Marking a peer dependency as optional ensures npm will not emit a warning if the soy-milk package is not installed on the host. This allows you to integrate and interact with a variety of host packages without requiring all of them to be installed.
This defines an array of package names that will be bundled when publishing the package.
In cases where you need to preserve npm packages locally or have them available through a single file download, you can bundle the packages in a tarball file by specifying the package names in the bundleDependencies array and executing npm pack.
For example:
If we define a package.json like this:
we can obtain awesome-web-framework-1.0.0.tgz file by running npm pack. This file contains the dependencies renderized and super-streams which can be installed in a new project by executing npm install awesome-web-framework-1.0.0.tgz. Note that the package names do not include any versions, as that information is specified in dependencies.
If this is spelled "bundledDependencies", then that is also honored.
Alternatively, "bundleDependencies" can be defined as a boolean value. A value of true will bundle all dependencies, a value of false will bundle none.
If a dependency can be used, but you would like npm to proceed if it cannot be found or fails to install, then you may put it in the optionalDependencies object. This is a map of package name to version or url, just like the dependencies object. The difference is that build failures do not cause installation to fail. Running npm install --omit=optional will prevent these dependencies from being installed.
It is still your program's responsibility to handle the lack of the dependency. For example, something like this:
Entries in optionalDependencies will override entries of the same name in dependencies, so it's usually best to only put in one place.
If you need to make specific changes to dependencies of your dependencies, for example replacing the version of a dependency with a known security issue, replacing an existing dependency with a fork, or making sure that the same version of a package is used everywhere, then you may add an override.
Overrides provide a way to replace a package in your dependency tree with another version, or another package entirely. These changes can be scoped as specific or as vague as desired.
To make sure the package foo is always installed as version 1.0.0 no matter what version your dependencies rely on:
The above is a short hand notation, the full object form can be used to allow overriding a package itself as well as a child of the package. This will cause foo to always be 1.0.0 while also making bar at any depth beyond foo also 1.0.0:
To only override foo to be 1.0.0 when it's a child (or grandchild, or great grandchild, etc) of the package bar:
Keys can be nested to any arbitrary length. To override foo only when it's a child of bar and only when bar is a child of baz:
The key of an override can also include a version, or range of versions. To override foo to 1.0.0, but only when it's a child of bar@2.0.0:
You may not set an override for a package that you directly depend on unless both the dependency and the override itself share the exact same spec. To make this limitation easier to deal with, overrides may also be defined as a reference to a spec for a direct dependency by prefixing the name of the package you wish the version to match with a $.
You can specify the version of node that your stuff works on:
And, like with dependencies, if you don't specify the version (or if you specify "*" as the version), then any version of node will do.
You can also use the "engines" field to specify which versions of npm are capable of properly installing your program. For example:
Unless the user has set the engine-strict config flag, this field is advisory only and will only produce warnings when your package is installed as a dependency.
You can specify which operating systems your module will run on:
You can also block instead of allowing operating systems, just prepend the blocked os with a '!':
The host operating system is determined by process.platform
It is allowed to both block and allow an item, although there isn't any good reason to do this.
If your code only runs on certain cpu architectures, you can specify which ones.
Like the os option, you can also block architectures:
The host architecture is determined by process.arch
If you set "private": true in your package.json, then npm will refuse to publish it.
This is a way to prevent accidental publication of private repositories. If you would like to ensure that a given package is only ever published to a specific registry (for example, an internal registry), then use the publishConfig dictionary described below to override the registry config param at publish-time.
This is a set of config values that will be used at publish-time. It's especially handy if you want to set the tag, registry or access, so that you can ensure that a given package is not tagged with "latest", published to the global public registry or that a scoped module is private by default.
See config to see the list of config options that can be overridden.
The optional workspaces field is an array of file patterns that describes locations within the local file system that the install client should look up to find each workspace that needs to be symlinked to the top level node_modules folder.
It can describe either the direct paths of the folders to be used as workspaces or it can define globs that will resolve to these same folders.
In the following example, all folders located inside the folder ./packages will be treated as workspaces as long as they have valid package.json files inside them:
See workspaces for more examples.
npm will default some values based on package contents.
"scripts": {"start": "node server.js"}
If there is a server.js file in the root of your package, then npm will default the start command to node server.js.
"scripts":{"install": "node-gyp rebuild"}
If there is a binding.gyp file in the root of your package and you have not defined an install or preinstall script, npm will default the install command to compile using node-gyp.
"contributors": [...]
If there is an AUTHORS file in the root of your package, npm will treat each line as a Name <email> (url) format, where email and url are optional. Lines which start with a # or are blank, will be ignored.
Select CLI Version:
package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json. It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates.
This file is intended to be committed into source repositories, and serves various purposes:
Describe a single representation of a dependency tree such that teammates, deployments, and continuous integration are guaranteed to install exactly the same dependencies.
Provide a facility for users to "time-travel" to previous states of node_modules without having to commit the directory itself.
Facilitate greater visibility of tree changes through readable source control diffs.
Optimize the installation process by allowing npm to skip repeated metadata resolutions for previously-installed packages.
As of npm v7, lockfiles include enough information to gain a complete picture of the package tree, reducing the need to read package.json files, and allowing for significant performance improvements.
Both of these files have the same format, and perform similar functions in the root of a project.
The difference is that package-lock.json cannot be published, and it will be ignored if found in any place other than the root project.
In contrast, npm-shrinkwrap.json allows publication, and defines the dependency tree from the point encountered. This is not recommended unless deploying a CLI tool or otherwise using the publication process for producing production packages.
If both package-lock.json and npm-shrinkwrap.json are present in the root of a project, npm-shrinkwrap.json will take precedence and package-lock.json will be ignored.
In order to avoid processing the node_modules folder repeatedly, npm as of v7 uses a "hidden" lockfile present in node_modules/.package-lock.json. This contains information about the tree, and is used in lieu of reading the entire node_modules hierarchy provided that the following conditions are met:
That is, the hidden lockfile will only be relevant if it was created as part of the most recent update to the package tree. If another CLI mutates the tree in any way, this will be detected, and the hidden lockfile will be ignored.
Note that it is possible to manually change the contents of a package in such a way that the modified time of the package folder is unaffected. For example, if you add a file to node_modules/foo/lib/bar.js, then the modified time on node_modules/foo will not reflect this change. If you are manually editing files in node_modules, it is generally best to delete the file at node_modules/.package-lock.json.
As the hidden lockfile is ignored by older npm versions, it does not contain the backwards compatibility affordances present in "normal" lockfiles. That is, it is lockfileVersion: 3, rather than lockfileVersion: 2.
When npm detects a lockfile from npm v6 or before during the package installation process, it is automatically updated to fetch missing information from either the node_modules tree or (in the case of empty node_modules trees or very old lockfile formats) the npm registry.
The name of the package this is a package-lock for. This will match what's in package.json.
The version of the package this is a package-lock for. This will match what's in package.json.
An integer version, starting at 1 with the version number of this document whose semantics were used when generating this package-lock.json.
Note that the file format changed significantly in npm v7 to track information that would have otherwise required looking in node_modules or the npm registry. Lockfiles generated by npm v7 will contain lockfileVersion: 2.
npm will always attempt to get whatever data it can out of a lockfile, even if it is not a version that it was designed to support.
This is an object that maps package locations to an object containing the information about that package.
The root project is typically listed with a key of "", and all other packages are listed with their relative paths from the root project folder.
Package descriptors have the following fields:
version: The version found in package.json
resolved: The place where the package was actually resolved from. In the case of packages fetched from the registry, this will be a url to a tarball. In the case of git dependencies, this will be the full git url with commit sha. In the case of link dependencies, this will be the location of the link target. registry.npmjs.org is a magic value meaning "the currently configured registry".
integrity: A sha512 or sha1 Standard Subresource Integrity string for the artifact that was unpacked in this location.
link: A flag to indicate that this is a symbolic link. If this is present, no other fields are specified, since the link target will also be included in the lockfile.
dev, optional, devOptional: If the package is strictly part of the devDependencies tree, then dev will be true. If it is strictly part of the optionalDependencies tree, then optional will be set. If it is both a dev dependency and an optional dependency of a non-dev dependency, then devOptional will be set. (An optional dependency of a dev dependency will have both dev and optional set.)
inBundle: A flag to indicate that the package is a bundled dependency.
hasInstallScript: A flag to indicate that the package has a preinstall, install, or postinstall script.
hasShrinkwrap: A flag to indicate that the package has an npm-shrinkwrap.json file.
bin, license, engines, dependencies, optionalDependencies: fields from package.json
Legacy data for supporting versions of npm that use lockfileVersion: 1. This is a mapping of package names to dependency objects. Because the object structure is strictly hierarchical, symbolic link dependencies are somewhat challenging to represent in some cases.
npm v7 ignores this section entirely if a packages section is present, but does keep it up to date in order to support switching between npm v6 and npm v7.
Dependency objects have the following fields:
version: a specifier that varies depending on the nature of the package, and is usable in fetching a new copy of it.
integrity: A sha512 or sha1 Standard Subresource Integrity string for the artifact that was unpacked in this location. For git dependencies, this is the commit sha.
resolved: For registry sources this is path of the tarball relative to the registry URL. If the tarball URL isn't on the same server as the registry URL then this is a complete URL. registry.npmjs.org is a magic value meaning "the currently configured registry".
bundled: If true, this is the bundled dependency and will be installed by the parent module. When installing, this module will be extracted from the parent module during the extract phase, not installed as a separate dependency.
dev: If true then this dependency is either a development dependency ONLY of the top level module or a transitive dependency of one. This is false for dependencies that are both a development dependency of the top level and a transitive dependency of a non-development dependency of the top level.
optional: If true then this dependency is either an optional dependency ONLY of the top level module or a transitive dependency of one. This is false for dependencies that are both an optional dependency of the top level and a transitive dependency of a non-optional dependency of the top level.
requires: This is a mapping of module name to version. This is a list of everything this module requires, regardless of where it will be installed. The version should match via normal matching rules a dependency either in our dependencies or in a level higher than us.
dependencies: The dependencies of this dependency, exactly as at the top level.
Select CLI Version:
To resolve packages by name and version, npm talks to a registry website that implements the CommonJS Package Registry specification for reading package info.
npm is configured to use the npm public registry at https://registry.npmjs.org by default. Use of the npm public registry is subject to terms of use available at https://docs.npmjs.com/policies/terms.
You can configure npm to use any compatible registry you like, and even run your own registry. Use of someone else's registry may be governed by their terms of use.
npm's package registry implementation supports several write APIs as well, to allow for publishing packages and managing user account information.
The npm public registry is powered by a CouchDB database, of which there is a public mirror at https://skimdb.npmjs.com/registry.
The registry URL used is determined by the scope of the package (see scope. If no scope is specified, the default registry is used, which is supplied by the registry config parameter. See npm config, npmrc, and config for more on managing npm's configuration. Authentication configuration such as auth tokens and certificates are configured specifically scoped to an individual registry. See Auth Related Configuration
When the default registry is used in a package-lock or shrinkwrap it has the special meaning of "the currently configured registry". If you create a lock file while using the default registry you can switch to another registry and npm will install packages from the new registry, but if you create a lock file while using a custom registry packages will be installed from that registry even after you change to another registry.
Yes.
When making requests of the registry npm adds two headers with information about your environment:
The npm registry does not try to correlate the information in these headers with any authenticated accounts that may be used in the same requests.
Set "private": true in your package.json to prevent it from being published at all, or "publishConfig":{"registry":"http://my-internal-registry.local"} to force it to be published only to your internal/private registry.
See package.json for more info on what goes in the package.json file.
https://www.npmjs.com/
Select CLI Version:
Commands like npm install and the dependency sections in the package.json use a package name specifier. This can be many different things that all refer to a "package". Examples include a package name, git url, tarball, or local directory. These will generally be referred to as <package-spec> in the help output for the npm commands that use this package name specifier.
Refers to a package by name, with or without a scope, and optionally tag, version, or version range. This is typically used in combination with the registry config to refer to a package in a registry.
Examples:
Primarily used by commands like npm install and in the dependency sections in the package.json, this refers to a package by an alias. The <alias> is the name of the package as it is reified in the node_modules folder, and the <name> refers to a package name as found in the configured registry.
See Package name above for more info on referring to a package by name, and registry for configuring which registry is used when referring to a package by name.
Examples:
This refers to a package on the local filesystem. Specifically this is a folder with a package.json file in it. This should always be prefixed with a / or ./ (or your OS equivalent) to reduce confusion. npm currently will parse a string with more than one / in it as a folder, but this is legacy behavior that may be removed in a future version.
Examples:
Examples:
Refers to a package in a tarball format, either on the local filesystem or remotely via url. This is the format that packages exist in when uploaded to a registry.
Refers to a package in a git repo. This can be a full git url, git shorthand, or a username/package on GitHub. You can specify a git tag, branch, or other git ref by appending #ref.
Examples:
Select CLI Version:
This article details npm configuration in general. To learn about the config command, see npm config.
npm gets its configuration values from the following sources, sorted by priority:
Putting --foo bar on the command line sets the foo configuration parameter to "bar". A -- argument tells the cli parser to stop reading flags. Using --flag without specifying any value will set the value to true.
Example: --flag1 --flag2 will set both configuration parameters to true, while --flag1 --flag2 bar will set flag1 to true, and flag2 to bar. Finally, --flag1 --flag2 -- bar will set both configuration parameters to true, and the bar is taken as a command argument.
Any environment variables that start with npm_config_ will be interpreted as a configuration parameter. For example, putting npm_config_foo=bar in your environment will set the foo configuration parameter to bar. Any environment configurations that are not given a value will be given the value of true. Config values are case-insensitive, so NPM_CONFIG_FOO=bar will work the same. However, please note that inside scripts npm will set its own environment variables and Node will prefer those lowercase versions over any uppercase ones that you might set. For details see this issue.
Notice that you need to use underscores instead of dashes, so --allow-same-version would become npm_config_allow_same_version=true.
The four relevant files are:
See npmrc for more details.
Run npm config ls -l to see a set of configuration parameters that are internal to npm, and are defaults if nothing else is specified.
The following shorthands are parsed on the command-line:
If the specified configuration param resolves unambiguously to a known configuration parameter, then it is expanded to that configuration parameter. For example:
If multiple single-character shorthands are strung together, and the resulting combination is unambiguously not some other configuration param, then it is expanded to its various component pieces. For example:
A basic-auth string to use when authenticating against the npm registry. This will ONLY be used to authenticate against the npm registry. For other registries you will need to scope it like "//other-registry.tld/:_auth"
Warning: This should generally not be set via a command-line option. It is safer to use a registry-provided authentication bearer token stored in the ~/.npmrc file by running npm login.
If you do not want your scoped package to be publicly viewable (and installable) set --access=restricted.
Unscoped packages can not be set to restricted.
Note: This defaults to not changing the current access level for existing packages. Specifying a value of restricted or public during publish will change the access for an existing package the same way that npm access set status would.
When running npm outdated and npm ls, setting --all will show all outdated or installed packages, rather than only those directly depended upon by the current project.
Prevents throwing an error when npm version is used to set the new version to the same value as the current version.
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm audit for details on what is submitted.
The minimum level of vulnerability for npm audit to exit with a non-zero exit code.
What authentication strategy to use with login. Note that if an otp config is given, this value will always be set to legacy.
If passed to npm install, will rebuild the npm tree such that only versions that were available on or before the --before time get installed. If there's no versions available for the current set of direct dependencies, the command will error.
If the requested version is a dist-tag and the given tag does not pass the --before filter, the most recent version less than or equal to that tag will be used. For example, foo@latest might install foo@1.2 even though latest is 2.0.
Tells npm to create symlinks (or .cmd shims on Windows) for package executables.
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
The browser that is called by npm commands to open websites.
Set to false to suppress browser behavior and instead print urls to terminal.
Set to true to use default system URL opener.
The Certificate Authority signing certificate that is trusted for SSL connections to the registry. Values should be in PEM format (Windows calls it "Base-64 encoded X.509 (.CER)") with newlines replaced by the string "\n". For example:
Set to null to only allow "known" registrars, or to a specific CA cert to trust only that specific signing authority.
Multiple CAs can be trusted by specifying an array of certificates:
See also the strict-ssl config.
The location of npm's cache directory.
A path to a file containing one or multiple Certificate Authority signing certificates. Similar to the ca setting, but allows for multiple CA's, as well as for the CA information to be stored in a file on disk.
Optional companion option for npm exec, npx that allows for specifying a custom command to be run along with the installed packages.
This is a list of CIDR address to be used when configuring limited access tokens with the npm token create command.
If false, never shows colors. If "always" then always shows colors. If true, then only prints color codes for tty file descriptors.
Run git commit hooks when using the npm version command.
Override CPU architecture of native modules to install. Acceptable values are same as cpu field of package.json, which comes from process.arch.
The depth to go when recursing packages for npm ls.
If not set, npm ls will show only the immediate dependencies of the root project. If --all is set, then npm will show all dependencies by default.
Show the description in npm search
Define arguments to compare in npm diff.
Destination prefix to be used in npm diff output.
Ignore whitespace when comparing lines in npm diff.
Prints only filenames when using npm diff.
Do not show any source or destination prefix in npm diff output.
Note: this causes npm diff to ignore the --diff-src-prefix and --diff-dst-prefix configs.
Source prefix to be used in npm diff output.
Treat all files as text in npm diff.
The number of lines of context to print in npm diff.
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, install, update, dedupe, uninstall, as well as pack and publish.
Note: This is NOT honored by other network related commands, eg dist-tags, owner, etc.
The command to run for npm edit and npm config edit.
If set to true, then npm will stubbornly refuse to install (or even consider installing) any package that claims to not be compatible with the current Node.js version.
This can be overridden by setting the --force flag.
The "retries" config for the retry module to use when fetching packages from the registry.
npm will retry idempotent read requests to the registry in the case of network failures or 5xx HTTP errors.
The "factor" config for the retry module to use when fetching packages.
The "maxTimeout" config for the retry module to use when fetching packages.
The "minTimeout" config for the retry module to use when fetching packages.
The maximum amount of time to wait for HTTP requests to complete.
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
Run all build scripts (ie, preinstall, install, and postinstall) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
Format package-lock.json or npm-shrinkwrap.json as a human readable file.
When "true" displays the message at the end of each npm install acknowledging the number of dependencies looking for funding. See npm fund for details.
The command to use for git commands. If git is installed on the computer, but is not in the PATH, then set this to the full path to the git binary.
Tag the commit when using the npm version command. Setting this to false results in no commit being made at all.
Operates in "global" mode, so that packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
The config file to read for global config options.
The string that starts all the debugging log output.
A proxy to use for outgoing https requests. If the HTTPS_PROXY or https_proxy or HTTP_PROXY or http_proxy environment variables are set, proxy settings will be honored by the underlying make-fetch-happen library.
If true, npm will not exit with an error code when run-script is invoked for a script that isn't defined in the scripts section of package.json. This option can be used when it's desirable to optionally run a script when it's present and fail if the script fails. This is useful, for example, when running scripts that may only apply for some builds in an otherwise generic CI setup.
This value is not exported to the environment for child processes.
If true, npm does not run scripts specified in package.json files.
Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre- or post-scripts.
Option that allows for defining which types of dependencies to install.
This is the inverse of --omit=<type>.
Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.
Allow installing "staged" published packages, as defined by npm RFC PR #92.
This is experimental, and not implemented by the npm public registry.
Include the workspace root when workspaces are enabled for a command.
When false, specifying individual workspaces via the workspace config, or all workspaces via the workspaces flag, will cause npm to operate only on the specified workspaces, and not on the root project.
This value is not exported to the environment for child processes.
The value npm init should use by default for the package author's email.
The value npm init should use by default for the package author's name.
The value npm init should use by default for the package author's homepage.
The value npm init should use by default for the package license.
A module that will be loaded by the npm init command. See the documentation for the init-package-json module for more information, or npm init.
The value that npm init should use by default for the package version number, if not already set in package.json.
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
Whether or not to output JSON data, rather than the normal output.
Not supported by all npm commands.
Causes npm to completely ignore peerDependencies when building a package tree, as in npm versions 3 through 6.
If a package cannot be installed because of overly strict peerDependencies that collide, it provides a way to move forward resolving the situation.
This differs from --omit=peer, in that --omit=peer will avoid unpacking peerDependencies on disk, but will still design a tree such that peerDependencies could be unpacked in a correct place.
Use of legacy-peer-deps is not recommended, as it will not enforce the peerDependencies contract that meta-dependencies may rely on.
Override libc of native modules to install. Acceptable values are same as libc field of package.json
Used with npm ls, limiting output to only those packages that are linked.
The IP address of the local interface to use when making connections to the npm registry. Must be IPv4 in versions of Node prior to 0.12.
When passed to npm config this refers to which config file to use.
When set to "global" mode, packages are installed into the prefix folder instead of the current working directory. See folders for more on the differences in behavior.
Set the lockfile format version to be used in package-lock.json and npm-shrinkwrap-json files. Possible options are:
1: The lockfile version used by npm versions 5 and 6. Lacks some data that is used during the install, resulting in slower and possibly less deterministic installs. Prevents lockfile churn when interoperating with older npm versions.
2: The default lockfile version used by npm version 7 and 8. Includes both the version 1 lockfile data and version 3 lockfile data, for maximum determinism and interoperability, at the expense of more bytes on disk.
3: Only the new lockfile information introduced in npm version 7. Smaller on disk than lockfile version 2, but not interoperable with older npm versions. Ideal if all users are on npm version 7 and higher.
What level of logs to report. All logs are written to a debug log, with the path to that file printed if the execution of a command fails.
Any logs of a higher level than the setting are shown. The default is "notice".
See also the foreground-scripts config.
The location of npm's log directory. See npm logging for more information.
The maximum number of log files to store.
If set to 0, no log files will be written for the current run.
Show extended information in ls, search, and help-search.
The maximum number of connections to use per origin (protocol/host/port combination).
Commit message which is used by npm version when creating version commit.
Any "%s" in the message will be replaced with the version number.
Options to pass through to Node.js via the NODE_OPTIONS environment variable. This does not impact how npm itself is executed but it does impact how lifecycle scripts are called.
Domain extensions that should bypass any proxies.
Also accepts a comma-delimited string.
Force offline mode: no network requests will be done during install. To allow the CLI to fill in missing cache data, see --prefer-offline.
Dependency types to omit from the installation tree on disk.
Note that these dependencies are still resolved and added to the package-lock.json or npm-shrinkwrap.json file. They are just not physically installed on disk.
If a package type appears in both the --include and --omit lists, then it will be included.
If the resulting omit list includes 'dev', then the NODE_ENV environment variable will be set to 'production' for all lifecycle scripts.
This option causes npm to create lock files without a resolved key for registry dependencies. Subsequent installs will need to resolve tarball endpoints with the configured registry, likely resulting in a longer install time.
Override OS of native modules to install. Acceptable values are same as os field of package.json, which comes from process.platform.
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with npm access.
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
Directory in which npm pack will save tarballs.
The package or packages to install for npm exec
If set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.
If set to true, the current operation will only use the package-lock.json, ignoring node_modules.
For update this means only the package-lock.json will be updated, instead of checking node_modules and downloading dependencies.
For list this means the output will be based on the tree described by the package-lock.json, rather than the contents of node_modules.
Output parseable results from commands that write to standard output. For npm search, this will be tab-separated table format.
Prefer to deduplicate packages if possible, rather than choosing a newer version of a dependency.
If true, staleness checks for cached data will be bypassed, but missing data will be requested from the server. To force full offline mode, use --offline.
If true, staleness checks for cached data will be forced, making the CLI look for updates immediately even for fresh package data.
The location to install global items. If set on the command line, then it forces non-global commands to run in the specified folder.
The "prerelease identifier" to use as a prefix for the "prerelease" part of a semver. Like the rc in 1.2.0-rc.8.
When set to true, npm will display a progress bar during time intensive operations, if process.stderr is a TTY.
Set to false to suppress the progress bar.
When publishing from a supported cloud CI/CD system, the package will be publicly linked to where it was built and published from.
This config can not be used with: provenance-file
When publishing, the provenance bundle at the given path will be used.
This config can not be used with: provenance
A proxy to use for outgoing http requests. If the HTTP_PROXY or http_proxy environment variables are set, proxy settings will be honored by the underlying request library.
This is used to mark a token as unable to publish when configuring limited access tokens with the npm token create command.
Rebuild bundled dependencies after installation.
The base URL of the npm registry.
Defines behavior for replacing the registry host in a lockfile with the configured registry.
The default behavior is to replace package dist URLs from the default registry (https://registry.npmjs.org) to the configured registry. If set to "never", then use the registry value. If set to "always", then replace the registry host with the configured host every time.
You may also specify a bare hostname (e.g., "registry.npmjs.org").
Save installed packages to a package.json file as dependencies.
When used with the npm rm command, removes the dependency from package.json.
Will also prevent writing to package-lock.json if set to false.
If a package would be saved at install time by the use of --save, --save-dev, or --save-optional, then also put it in the bundleDependencies list.
Ignored if --save-peer is set, since peerDependencies cannot be bundled.
Save installed packages to a package.json file as devDependencies.
Dependencies saved to package.json will be configured with an exact version rather than using npm's default semver range operator.
Save installed packages to a package.json file as optionalDependencies.
Save installed packages to a package.json file as peerDependencies
Configure how versions of packages installed to a package.json file via --save or --save-dev get prefixed.
For example if a package has version 1.2.3, by default its version is set to ^1.2.3 which allows minor upgrades for that package, but after npm config set save-prefix='~' it would be set to ~1.2.3 which only allows patch upgrades.
Save installed packages into dependencies specifically. This is useful if a package already exists in devDependencies or optionalDependencies, but you want to move it to be a non-optional production dependency.
This is the default behavior if --save is true, and neither --save-dev or --save-optional are true.
SBOM format to use when generating SBOMs.
The type of package described by the generated SBOM. For SPDX, this is the value for the primaryPackagePurpose field. For CycloneDX, this is the value for the type field.
Associate an operation with a scope for a scoped registry.
Useful when logging in to or out of a private registry:
This will cause @mycorp to be mapped to the registry for future installation of packages specified according to the pattern @mycorp/package.
This will also cause npm init to create a scoped package.
The shell to use for scripts run with the npm exec, npm run and npm init <package-spec> commands.
Space-separated options that limit the results from search.
Number of items to limit search results to. Will not apply at all to legacy searches.
Space-separated options that are always passed to search.
The age of the cache, in seconds, before another registry request is made if using legacy search endpoint.
The shell to run for the npm explore command.
If set to true, then the npm version command will commit the new package version using -S to add a signature.
Note that git requires you to have set up GPG keys in your git configs for this to work properly.
If set to true, then the npm version command will tag the version using -s to add a signature.
Note that git requires you to have set up GPG keys in your git configs for this to work properly.
If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
By default, conflicting peerDependencies deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's peerDependencies object.
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If --strict-peer-deps is set, then this warning is treated as a failure.
Whether or not to do SSL key validation when making requests to the registry via https.
See also the ca config.
If you ask npm to install a package and don't tell it a specific version, then it will install the specified tag.
Also the tag that is added to the package@version specified by the npm tag command, if no explicit tag is given.
When used by the npm diff command, this is the tag used to fetch the tarball that will be compared with the local files by default.
If set, alters the prefix used when tagging a new version when performing a version increment using npm version. To remove the prefix altogether, set it to the empty string: "".
Because other tools may rely on the convention that npm version tags look like v1.0.0, only use this property if it is absolutely necessary. In particular, use care when overriding this setting for public packages.
If true, writes timing information to a process specific json file in the cache or logs-dir. The file name ends with -timing.json.
You can quickly view it with this json command line: cat ~/.npm/_logs/*-timing.json | npm exec -- json -g.
Timing information will also be reported in the terminal. To suppress this while still writing the timing file, use --silent.
The "umask" value to use when setting the file creation mode on files and folders.
Folders and executables are given a mode which is 0o777 masked against this value. Other files are given a mode which is 0o666 masked against this value.
Note that the underlying system will also apply its own umask value to files and folders that are created, and npm does not circumvent this, but rather adds the --umask config to it.
Thus, the effective default umask value on most POSIX systems is 0o22, meaning that folders and executables are created with a mode of 0o755 and other files are created with a mode of 0o644.
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
Set to false to suppress the update notification when using an older version of npm than the latest.
Show short usage output about the command specified.
Sets the User-Agent request header. The following fields are replaced with their actual counterparts:
The location of user-level configuration settings.
This may be overridden by the npm_config_userconfig environment variable or the --userconfig command line option, but may not be overridden by settings in the globalconfig file.
If true, output the npm version and exit successfully.
Only relevant when specified explicitly on the command line.
If true, output the npm version as well as node's process.versions map and the version in the current working directory's package.json file if one exists, and exit successfully.
Only relevant when specified explicitly on the command line.
The program to use to view help content.
Set to "browser" to view html help content in the default web browser.
If there are multiple funding sources, which 1-indexed source URL to open.
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
Valid values for the workspace config are either:
When set for the npm init command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
This value is not exported to the environment for child processes.
Set to true to run the command in the context of all configured workspaces.
Explicitly setting this to false will cause commands like install to ignore workspaces altogether. When not set explicitly:
This value is not exported to the environment for child processes.
If set to true, the npm cli will run an update after operations that may possibly change the workspaces installed to the node_modules folder.
Automatically answer "yes" to any prompts that npm might print on the command line.
When set to dev or development, this is an alias for --include=dev.
--cache-max=0 is an alias for --prefer-online
--cache-min=9999 (or bigger) is an alias for --prefer-offline.
A client certificate to pass when accessing the registry. Values should be in PEM format (Windows calls it "Base-64 encoded X.509 (.CER)") with newlines replaced by the string "\n". For example:
It is not the path to a certificate file, though you can set a registry-scoped "certfile" path like "//other-registry.tld/:certfile=/path/to/cert.pem".
Alias for --include=dev.
Only install direct dependencies in the top level node_modules, but hoist on deeper dependencies. Sets --install-strategy=shallow.
Alias for --init-author-email
Alias for --init-author-name
Alias for --init-author-url
Alias for --init-license
Alias for --init-module
Alias for --init-version
A client key to pass when accessing the registry. Values should be in PEM format with newlines replaced by the string "\n". For example:
It is not the path to a key file, though you can set a registry-scoped "keyfile" path like "//other-registry.tld/:keyfile=/path/to/key.pem".
Instead of hoisting package installs in node_modules, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets --install-strategy=nested.
When set to prod or production, this is an alias for --omit=dev.
Default value does install optional deps unless otherwise omitted.
Alias for --include=optional or --omit=optional
Alias for --omit=dev
Alias for --package-lock
Select CLI Version:
The npm CLI has various mechanisms for showing different levels of information back to end-users for certain commands, configurations & environments.
All logs are written to a debug log, with the path to that file printed if the execution of a command fails.
The default location of the logs directory is a directory named _logs inside the npm cache. This can be changed with the logs-dir config option.
For example, if you wanted to write all your logs to the current working directory, you could run: npm install --logs-dir=.. This is especially helpful in debugging a specific npm issue as you can run a command multiple times with different config values and then diff all the log files.
Log files will be removed from the logs-dir when the number of log files exceeds logs-max, with the oldest logs being deleted first.
To turn off logs completely set --logs-max=0.
loglevel is a global argument/config that can be set to determine the type of information to be displayed.
The default value of loglevel is "notice" but there are several levels/types of logs available, including:
All logs pertaining to a level proceeding the current setting will be shown.
The log levels listed above have various corresponding aliases, including:
The npm CLI began hiding the output of lifecycle scripts for npm install as of v7. Notably, this means you will not see logs/output from packages that may be using "install scripts" to display information back to you or from your own project's scripts defined in package.json. If you'd like to change this behavior & log this output you can set foreground-scripts to true.
The --timing config can be set which does a few things:
This file contains a timers object where the keys are an identifier for the portion of the process being timed and the value is the number of milliseconds it took to complete.
Sometimes it is helpful to get timing information without outputting anything to the terminal. For example, the performance might be affected by writing to the terminal. In this case you can use --timing --silent which will still write the timing file, but not output anything to the terminal while running.
The npm CLI reads from & logs any npm-notice headers that are returned from the configured registry. This mechanism can be used by third-party registries to provide useful information when network-dependent requests occur.
This header is not cached, and will not be logged if the request is served from the cache.
The npm CLI makes a best effort to redact the following from terminal output and log files:
However, this behavior should not be relied on to keep all possible sensitive information redacted. If you are concerned about secrets in your log file or terminal output, you can use --loglevel=silent and --logs-max=0 to ensure no logs are written to your terminal or filesystem.
Select CLI Version:
All npm packages have a name. Some package names also have a scope. A scope follows the usual rules for package names (URL-safe characters, no leading dots or underscores). When used in package names, scopes are preceded by an @ symbol and followed by a slash, e.g.
Scopes are a way of grouping related packages together, and also affect a few things about the way npm treats the package.
Each npm user/organization has their own scope, and only you can add packages in your scope. This means you don't have to worry about someone taking your package name ahead of you. Thus it is also a good way to signal official packages for organizations.
Scoped packages can be published and installed as of npm@2 and are supported by the primary npm registry. Unscoped packages can depend on scoped packages and vice versa. The npm client is backwards-compatible with unscoped registries, so it can be used to work with scoped and unscoped registries at the same time.
Scoped packages are installed to a sub-folder of the regular installation folder, e.g. if your other packages are installed in node_modules/packagename, scoped modules will be installed in node_modules/@myorg/packagename. The scope folder (@myorg) is simply the name of the scope preceded by an @ symbol, and can contain any number of scoped packages.
A scoped package is installed by referencing it by name, preceded by an @ symbol, in npm install:
Or in package.json:
Note that if the @ symbol is omitted, in either case, npm will instead attempt to install from GitHub; see npm install.
Because scoped packages are installed into a scope folder, you have to include the name of the scope when requiring them in your code, e.g.
There is nothing special about the way Node treats scope folders. This simply requires the mypackage module in the folder named @myorg.
Scoped packages can be published from the CLI as of npm@2 and can be published to any registry that supports them, including the primary npm registry.
(As of 2015-04-19, and with npm 2.0 or better, the primary npm registry does support scoped packages.)
If you wish, you may associate a scope with a registry; see below.
Publishing to a scope, you have two options:
If publishing a public module to an organization scope, you must first either create an organization with the name of the scope that you'd like to publish to or be added to an existing organization with the appropriate permissions. For example, if you'd like to publish to @org, you would need to create the org organization on npmjs.com prior to trying to publish.
Scoped packages are not public by default. You will need to specify --access public with the initial npm publish command. This will publish the package and set access to public as if you had run npm access public after publishing. You do not need to do this when publishing new versions of an existing scoped package.
To publish a private scoped package to the npm registry, you must have an npm Private Modules account.
You can then publish the module with npm publish or npm publish --access restricted, and it will be present in the npm registry, with restricted access. You can then change the access permissions, if desired, with npm access or on the npmjs.com website.
Scopes can be associated with a separate registry. This allows you to seamlessly use a mix of packages from the primary npm registry and one or more private registries, such as GitHub Packages or the open source Verdaccio project.
You can associate a scope with a registry at login, e.g.
Scopes have a many-to-one relationship with registries: one registry can host multiple scopes, but a scope only ever points to one registry.
You can also associate a scope with a registry using npm config:
Once a scope is associated with a registry, any npm install for a package with that scope will request packages from that registry instead. Any npm publish for a package name that contains the scope will be published to that registry instead.
Select CLI Version:
The "scripts" property of your package.json file supports a number of built-in scripts and their preset life cycle events as well as arbitrary scripts. These all can be executed by running npm run-script <stage> or npm run <stage> for short. Pre and post commands with matching names will be run for those as well (e.g. premyscript, myscript, postmyscript). Scripts from dependencies can be run with npm explore <pkg> -- npm run <stage>.
To create "pre" or "post" scripts for any scripts defined in the "scripts" section of the package.json, simply create another script with a matching name and add "pre" or "post" to the beginning of them.
In this example npm run compress would execute these scripts as described.
There are some special life cycle scripts that happen only in certain situations. These scripts happen in addition to the pre<event>, post<event>, and <event> scripts.
prepare (since npm@4.0.0)
Runs BEFORE the package is packed, i.e. during npm publish and npm pack
Runs on local npm install without any arguments
Runs AFTER prepublish, but BEFORE prepublishOnly
NOTE: If a package being installed through git contains a prepare script, its dependencies and devDependencies will be installed, and the prepare script will be run, before the package is packaged and installed.
As of npm@7 these scripts run in the background. To see the output, run with: --foreground-scripts.
prepublish (DEPRECATED)
prepublishOnly
prepack
postpack
dependencies
Deprecation Note: prepublish
Since npm@1.1.71, the npm CLI has run the prepublish script for both npm publish and npm install, because it's a convenient way to prepare a package for use (some common use cases are described in the section below). It has also turned out to be, in practice, very confusing. As of npm@4.0.0, a new event has been introduced, prepare, that preserves this existing behavior. A new event, prepublishOnly has been added as a transitional strategy to allow users to avoid the confusing behavior of existing npm versions and only run on npm publish (for instance, running the tests one last time to ensure they're in good shape).
See https://github.com/npm/npm/issues/10074 for a much lengthier justification, with further reading, for this change.
Use Cases
If you need to perform operations on your package before it is used, in a way that is not dependent on the operating system or architecture of the target system, use a prepublish script. This includes tasks such as:
The advantage of doing these things at prepublish time is that they can be done once, in a single place, thus reducing complexity and variability. Additionally, this means that:
The dependencies script is run any time an npm command causes changes to the node_modules directory. It is run AFTER the changes have been applied and the package.json and package-lock.json files have been updated.
These all run after the actual installation of modules into node_modules, in order, with no internal actions happening in between
These also run when you run npm install -g <pkg-name>
If there is a binding.gyp file in the root of your package and you haven't defined your own install or preinstall scripts, npm will default the install command to compile using node-gyp via node-gyp rebuild
These are run from the scripts of <pkg-name>
prepare is only run if the current directory is a symlink (e.g. with linked packages)
If there is a restart script defined, these events are run, otherwise stop and start are both run if present, including their pre and post iterations)
If there is a server.js file in the root of your package, then npm will default the start command to node server.js. prestart and poststart will still run in this case.
While npm v6 had uninstall lifecycle scripts, npm v7 does not. Removal of a package can happen for a wide variety of reasons, and there's no clear way to currently give the script enough context to be useful.
Reasons for a package removal include:
Due to the lack of necessary context, uninstall lifecycle scripts are not implemented and will not function.
When npm is run as root, scripts are always run with the effective uid and gid of the working directory owner.
Package scripts run in an environment where many pieces of information are made available regarding the setup of npm and the current state of the process.
If you depend on modules that define executable scripts, like test suites, then those executables will be added to the PATH for executing the scripts. So, if your package.json has this:
then you could run npm start to execute the bar script, which is exported into the node_modules/.bin directory on npm install.
The package.json fields are tacked onto the npm_package_ prefix. So, for instance, if you had {"name":"foo", "version":"1.2.5"} in your package.json file, then your package scripts would have the npm_package_name environment variable set to "foo", and the npm_package_version set to "1.2.5". You can access these variables in your code with process.env.npm_package_name and process.env.npm_package_version, and so on for other fields.
See package.json for more on package configs.
Lastly, the npm_lifecycle_event environment variable is set to whichever stage of the cycle is being executed. So, you could have a single script used for different parts of the process which switches based on what's currently happening.
Objects are flattened following this format, so if you had {"scripts":{"install":"foo.js"}} in your package.json, then you'd see this in the script:
For example, if your package.json contains this:
then scripts/install.js will be called for the install and post-install stages of the lifecycle, and scripts/uninstall.js will be called when the package is uninstalled. Since scripts/install.js is running for two different phases, it would be wise in this case to look at the npm_lifecycle_event environment variable.
If you want to run a make command, you can do so. This works just fine:
Scripts are run by passing the line as a script argument to sh.
If the script exits with a code other than 0, then this will abort the process.
Note that these script files don't have to be Node.js or even JavaScript programs. They just have to be some kind of executable file.
Select CLI Version:
Workspaces is a generic term that refers to the set of features in the npm cli that provides support to managing multiple packages from your local file system from within a singular top-level, root package.
This set of features makes up for a much more streamlined workflow handling linked packages from the local file system. Automating the linking process as part of npm install and avoiding manually having to use npm link in order to add references to packages that should be symlinked into the current node_modules folder.
We also refer to these packages being auto-symlinked during npm install as a single workspace, meaning it's a nested package within the current local file system that is explicitly defined in the package.json workspaces configuration.
Workspaces are usually defined via the workspaces property of the package.json file, e.g:
Given the above package.json example living at a current working directory . that contains a folder named packages/a that itself contains a package.json inside it, defining a Node.js package, e.g:
The expected result once running npm install in this current working directory . is that the folder packages/a will get symlinked to the node_modules folder of the current working dir.
Below is a post npm install example, given that same previous example structure of files and folders:
You may automate the required steps to define a new workspace using npm init. For example in a project that already has a package.json defined you can run:
This command will create the missing folders and a new package.json file (if needed) while also making sure to properly configure the "workspaces" property of your root project package.json.
It's possible to directly add/remove/update dependencies of your workspaces using the workspace config.
For example, assuming the following structure:
If you want to add a dependency named abbrev from the registry as a dependency of your workspace a, you may use the workspace config to tell the npm installer that package should be added as a dependency of the provided workspace:
Note: other installing commands such as uninstall, ci, etc will also respect the provided workspace configuration.
Given the specifities of how Node.js handles module resolution it's possible to consume any defined workspace by its declared package.json name. Continuing from the example defined above, let's also create a Node.js script that will require the workspace a example module, e.g:
When running it with:
node lib/index.js
This demonstrates how the nature of node_modules resolution allows for workspaces to enable a portable workflow for requiring each workspace in such a way that is also easy to publish these nested workspaces to be consumed elsewhere.
You can use the workspace configuration option to run commands in the context of a configured workspace. Additionally, if your current directory is in a workspace, the workspace configuration is implicitly set, and prefix is set to the root workspace.
Following is a quick example on how to use the npm run command in the context of nested workspaces. For a project containing multiple workspaces, e.g:
By running a command using the workspace option, it's possible to run the given command in the context of that specific workspace. e.g:
You could also run the command within the workspace.
Either will run the test script defined within the ./packages/a/package.json file.
Please note that you can also specify this argument multiple times in the command-line in order to target multiple workspaces, e.g:
Or run the command for each workspace within the 'packages' folder:
It's also possible to use the workspaces (plural) configuration option to enable the same behavior but running that command in the context of all configured workspaces. e.g:
Will run the test script in both ./packages/a and ./packages/b.
Commands will be run in each workspace in the order they appear in your package.json
Order of run is different with:
It is not required for all of the workspaces to implement scripts run with the npm run command.
By running the command with the --if-present flag, npm will ignore workspaces missing target script.
Select CLI Version:
There are three levels of org users:
The super admin is the only person who can add users to the org because it impacts the monthly bill. The super admin will use the website to manage membership. Every org has a developers team that all users are automatically added to.
The team admin is the person who manages team creation, team membership, and package access for teams. The team admin grants package access to teams, not individuals.
The developer will be able to access packages based on the teams they are on. Access is either read-write or read-only.
There are two main commands:
Each org is automatically given a developers team, so you can see the whole list of team members in your org. This team automatically gets read-write access to all packages, but you can change that with the access command.
Create a new team:
to scope it for your org & publish as usual
Select CLI Version:
The npm query command exposes a new dependency selector syntax (informed by & respecting many aspects of the CSS Selectors 4 Spec) which:
The :semver() pseudo selector allows comparing fields from each node's package.json using semver methods. It accepts up to 3 parameters, all but the first of which are optional.
When the special infer function is used the spec and the actual value from the node are compared. If both are versions, according to semver.valid(), eq is used. If both values are ranges, according to !semver.valid(), intersects is used. If the values are mixed types satisfies is used.
Some examples:
The :outdated pseudo selector retrieves data from the registry and returns information about which of your dependencies are outdated. The type parameter may be one of the following:
In addition to the filtering performed by the pseudo selector, some extra data is added to the resulting objects. The following data can be found under the queryContext property of each node.
Some examples:
The attribute selector evaluates the key/value pairs in package.json if they are Strings.
The generic :attr() pseudo selector standardizes a pattern which can be used for attribute selection of Objects, Arrays or Arrays of Objects accessible via Arborist's Node.package metadata. This allows for iterative attribute selection beyond top-level String evaluation. The last argument passed to :attr() must be an attribute selector or a nested :attr(). See examples below:
Nested objects are expressed as sequential arguments to :attr().
Arrays specifically uses a special/reserved . character in place of a typical attribute name. Arrays also support exact value matching when a String is passed to the selector.
Dependency groups are defined by the package relationships to their ancestors (ie. the dependency types that are defined in package.json). This approach is user-centric as the ecosystem has been taught to think about dependencies in these groups first-and-foremost. Dependencies are allowed to be included in multiple groups (ex. a prod dependency may also be a dev dependency (in that it's also required by another dev dependency) & may also be bundled - a selector for that type of dependency would look like: *.prod.dev.bundled).
Please note that currently workspace deps are always prod dependencies. Additionally the .root dependency is also considered a prod dependency.
Select CLI Version:
So, you've decided to use npm to develop (and maybe publish/deploy) your project.
Fantastic!
There are a few things that you need to do above the simple steps that your users will do to install your program.
These are man pages. If you install npm, you should be able to then do man npm-thing to get the documentation on a particular topic, or npm help thing to see the same information.
A package is:
Even if you never publish your package, you can still get a lot of benefits of using npm if you just want to write a node program (a), and perhaps if you also want to be able to easily install it elsewhere after packing it up into a tarball (b).
Git urls can be of the form:
The commit-ish can be any tag, sha, or branch which can be supplied as an argument to git checkout. The default is whatever the repository uses as its default branch.
You need to have a package.json file in the root of your project to do much of anything with npm. That is basically the whole interface.
See package.json for details about what goes in that file. At the very least, you need:
name: This should be a string that identifies your project. Please do not use the name to specify that it runs on node, or is in JavaScript. You can use the "engines" field to explicitly state the versions of node (or whatever else) that your program requires, and it's pretty well assumed that it's JavaScript.
It does not necessarily need to match your github repository name.
So, node-foo and bar-js are bad names. foo or bar are better.
version: A semver-compatible version.
engines: Specify the versions of node (or whatever else) that your program runs on. The node API changes a lot, and there may be bugs or new functionality that you depend on. Be explicit.
author: Take some credit.
scripts: If you have a special compilation or installation script, then you should put it in the scripts object. You should definitely have at least a basic smoke-test command as the "scripts.test" field. See scripts.
main: If you have a single module that serves as the entry point to your program (like what the "foo" package gives you at require("foo")), then you need to specify that in the "main" field.
directories: This is an object mapping names to folders. The best ones to include are "lib" and "doc", but if you use "man" to specify a folder full of man pages, they'll get installed just like these ones.
You can use npm init in the root of your package in order to get you started with a pretty basic package.json file. See npm init for more info.
Use a .npmignore file to keep stuff out of your package. If there's no .npmignore file, but there is a .gitignore file, then npm will ignore the stuff matched by the .gitignore file. If you want to include something that is excluded by your .gitignore file, you can create an empty .npmignore file to override it. Like git, npm looks for .npmignore and .gitignore files in all subdirectories of your package, not only the root directory.
.npmignore files follow the same pattern rules as .gitignore files:
By default, the following paths and files are ignored, so there's no need to add them to .npmignore explicitly:
Additionally, everything in node_modules is ignored, except for bundled dependencies. npm automatically handles this for you, so don't bother adding node_modules to .npmignore.
The following paths and files are never ignored, so adding them to .npmignore is pointless:
If, given the structure of your project, you find .npmignore to be a maintenance headache, you might instead try populating the files property of package.json, which is an array of file or directory names that should be included in your package. Sometimes manually picking which items to allow is easier to manage than building a block list.
If you want to double check that your package will include only the files you intend it to when published, you can run the npm pack command locally which will generate a tarball in the working directory, the same way it does for publishing.
npm link is designed to install a development package and see the changes in real time without having to keep re-installing it. (You do need to either re-link or npm rebuild -g to update compiled packages, of course.)
More info at npm link.
This is important.
If you can not install it locally, you'll have problems trying to publish it. Or, worse yet, you'll be able to publish it, but you'll be publishing a broken or pointless package. So don't do that.
In the root of your package, do this:
That'll show you that it's working. If you'd rather just create a symlink package that points to your working directory, then do this:
Use npm ls -g to see if it's there.
To test a local install, go into some other folder, and then do:
to install it locally into the node_modules folder in that other place.
Then go into the node-repl, and try using require("my-thing") to bring in your module's main module.
Create a user with the adduser command. It works like this:
and then follow the prompts.
This is documented better in npm adduser.
This part's easy. In the root of your folder, do this:
You can give publish a url to a tarball, or a filename of a tarball, or a path to a folder.
Note that pretty much everything in that folder will be exposed by default. So, if you have secret stuff in there, use a .npmignore file to list out the globs to ignore, or publish from a fresh checkout.
Send emails, write blogs, blab in IRC.
Tell the world how easy it is to install your program!
Select CLI Version:
So sad to see you go.
Or, if that fails, get the npm source code, and do:
Usually, the above instructions are sufficient. That will remove npm, but leave behind anything you've installed.
If that doesn't work, or if you require more drastic measures, continue reading.
Note that this is only necessary for globally-installed packages. Local installs are completely contained within a project's node_modules folder. Delete that folder, and everything is gone unless a package's install script is particularly ill-behaved.
This assumes that you installed node and npm in the default place. If you configured node with a different --prefix, or installed npm with a different prefix setting, then adjust the paths accordingly, replacing /usr/local with your install prefix.
To remove everything npm-related manually:
If you installed things with npm, then your best bet is to uninstall them with npm first, and then install them again once you have a proper install. This can help find any symlinks that are lying around:
Prior to version 0.3, npm used shim files for executables and node modules. To track those down, you can do the following:
Select CLI Version:
We read every piece of feedback, and take your input very seriously.

            To see all available qualifiers, see our documentation.
          

        Documentation for the npm registry, website, and command-line interface.
      

This is the documentation for https://docs.npmjs.com/.
This repository contains the content for our documentation site, and the GitHub Actions workflows that generate the site itself.
Do you want to know more? Check out our contributing guide.
The npm product documentation in the content, and static folders are licensed under a CC-BY 4.0 license.
All other code in this repository is licensed under a MIT license.
When using the GitHub logos, be sure to follow the GitHub logo guidelines.

        Documentation for the npm registry, website, and command-line interface.
      
These are the legal policies of npm, Inc.
These are updated from time to time. Their sources are stored in a git repository at https://github.com/npm/documentation/tree/main/content/policies.
