Inline PostCSS config or a custom directory to search PostCSS config from (default is project root).
For inline PostCSS config, it expects the same format as postcss.config.js. But for plugins property, only array format can be used.
The search is done using postcss-load-config and only the supported config file names are loaded.
Note if an inline config is provided, Vite will not search for other PostCSS config sources.
Specify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:
Example:
This option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.
Example:
If this option is set, CSS preprocessors will run in workers when possible. true means the number of CPUs minus 1.
Whether to enable sourcemaps during dev.
Selects the engine used for CSS processing. Check out Lightning CSS for more information.
Configures Lightning CSS. Full transform options can be found in the Lightning CSS repo.
Whether to support named imports from .json files.
If set to true, imported JSON will be transformed into export default JSON.parse("...") which is significantly more performant than Object literals, especially when the JSON file is large.
Enabling this disables named imports.
ESBuildOptions extends esbuild's own transform options. The most common use case is customizing JSX:
By default, esbuild is applied to ts, jsx and tsx files. You can customize this with esbuild.include and esbuild.exclude, which can be a regex, a picomatch pattern, or an array of either.
In addition, you can also use esbuild.jsxInject to automatically inject JSX helper imports for every file transformed by esbuild:
When build.minify is true, all minify optimizations are applied by default. To disable certain aspects of it, set any of esbuild.minifyIdentifiers, esbuild.minifySyntax, or esbuild.minifyWhitespace options to false. Note the esbuild.minify option can't be used to override build.minify.
Set to false to disable esbuild transforms.
Specify additional picomatch patterns to be treated as static assets so that:
They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over fetch or XHR.
Importing them from JS will return their resolved URL string (this can be overwritten if you have a enforce: 'pre' plugin to handle the asset type differently).
The built-in asset type list can be found here.
Example:
Adjust console output verbosity. Default is 'info'.
Use a custom logger to log messages. You can use Vite's createLogger API to get the default logger and customize it to, for example, change the message or filter out certain warnings.
Set to false to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use --clearScreen false.
The directory from which .env files are loaded. Can be an absolute path, or a path relative to the project root.
See here for more about environment files.
Env variables starting with envPrefix will be exposed to your client source code via import.meta.env.
SECURITY NOTES
envPrefix should not be set as '', which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting ''.
If you would like to expose an unprefixed variable, you can use define to expose it:
Whether your application is a Single Page Application (SPA), a Multi Page Application (MPA), or Custom Application (SSR and frameworks with custom HTML handling):
Learn more in Vite's SSR guide. Related: server.middlewareMode.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
   
PostCSS Nesting lets you nest style rules inside each other, following the CSS Nesting specification.
If you want nested rules the same way Sass works\nyou might want to use PostCSS Nested instead.
Add PostCSS Nesting to your project:
Use it as a PostCSS plugin:
PostCSS Nesting runs in all Node environments, with special\ninstructions for:
Previous iterations of the CSS Nesting specification required using @nest for certain selectors.
@nest was removed from the specification completely.\nFuture versions of this plugin will error if you use @nest.
We advice everyone to migrate their codebase now to nested CSS without @nest.\nWe published a Stylelint Plugin to help you migrate.
example warning:
@nest was removed from the CSS Nesting specification and will be removed from PostCSS Nesting in the next major version.\nChange @nest foo & {} to foo & {} to migrate to the latest standard.
You can silence this warning with a new silenceAtNestWarning plugin option.
Before :
After without the option :
.beta:hover has specificity as if .beta where an id selector, matching the specification.
specificity: 1, 1, 0
After with the option :
.beta:hover has specificity as if .beta where a class selector, conflicting with the specification.
specificity: 0, 2, 0
Before :
After without the option :
After with the option :
this is a different selector than expected as .beta + .alpha matches .beta followed by .alpha.\navoid these cases when you disable :is()\nwriting the selector without nesting is advised here
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
Playground • Docs • Rust docs • npm • GitHub
Lightning CSS is over 100x faster than comparable JavaScript-based tools. It can minify over 2.7 million lines of code per second on a single thread.
Lightning CSS is written in Rust, a native systems programming language. It was built with performance in mind from the start, designed to make efficient use of memory, and limit AST passes.
Get started →
Lightning CSS lets you use modern CSS features and future syntax today. Features such as CSS nesting, custom media queries, high gamut color spaces, logical properties, and new selector features are automatically converted to more compatible syntax based on your browser targets.
Lightning CSS also automatically adds vendor prefixes for your browser targets, so you can keep your source code clean and repetition free.
Learn more →
Lightning CSS is not only fast when it comes to build time. It produces smaller output, so your website loads faster too.
The Lightning CSS minifier combines longhand properties into shorthands, removes unnecessary vendor prefixes, merges compatible adjacent rules, removes unnecessary default values, reduces calc() expressions, shortens colors, minifies gradients, and much more.
Details →
Lightning CSS supports CSS modules, which locally scope classes, ids, @keyframes, CSS variables, and more. This ensures that there are no unintended name clashes between different CSS files.
Lightning CSS generates a mapping of the original names to scoped names, which can be used from your JavaScript. This also enables unused classes and variables to be tree-shaken.
Documentation →
Lightning CSS is written in Rust, using the cssparser and selectors crates created by Mozilla and used by Firefox. These provide a solid CSS-parsing foundation on top of which Lightning CSS implements support for all specific CSS rules and properties.
Lightning CSS fully parses every CSS rule, property, and value just as a browser would. This reduces duplicate work for transformers, leading to improved performance and minification.
Custom transforms →
English
English
Appearance
Configuring Vite
Shared Options
Server Options
Build Options
Preview Options
Dep Optimization Options
SSR Options
Worker Options
Beyond Fast
ViteConf 2023
Watch the replay!
Project root directory (where index.html is located). Can be an absolute path, or a path relative to the current working directory.
See Project Root for more details.
Base public path when served in development or production. Valid values include:
See Public Base Path for more details.
Specifying this in config will override the default mode for both serve and build. This value can also be overridden via the command line --mode option.
See Env Variables and Modes for more details.
Define global constant replacements. Entries will be defined as globals during dev and statically replaced during build.
Vite uses esbuild defines to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with JSON.stringify.
Example:
NOTE
For TypeScript users, make sure to add the type declarations in the env.d.ts or vite-env.d.ts file to get type checks and Intellisense.
Example:
Array of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See Plugin API for more details on Vite plugins.
Directory to serve as plain static assets. Files in this directory are served at / during dev and copied to the root of outDir during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.
Defining publicDir as false disables this feature.
See The public Directory for more details.
Directory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use --force flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to .vite when no package.json is detected.
Will be passed to @rollup/plugin-alias as its entries option. Can either be an object, or an array of { find, replacement, customResolver } pairs.
When aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.
More advanced custom resolution can be achieved through plugins.
Using with SSR
If you have configured aliases for SSR externalized dependencies, you may want to alias the actual node_modules packages. Both Yarn and pnpm support aliasing via the npm: prefix.
If you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).
SSR + ESM
For SSR builds, deduplication does not work for ESM build outputs configured from build.rollupOptions.output. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.
Additional allowed conditions when resolving Conditional Exports from a package.
A package with conditional exports may have the following exports field in its package.json:
Here, import and require are "conditions". Conditions can be nested and should be specified from most specific to least specific.
Vite has a list of "allowed conditions" and will match the first condition that is in the allowed list. The default allowed conditions are: import, module, browser, default, and production/development based on current mode. The resolve.conditions config option allows specifying additional allowed conditions.
Resolving subpath exports
Export keys ending with "/" is deprecated by Node and may not work well. Please contact the package author to use * subpath patterns instead.
List of fields in package.json to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the exports field: if an entry point is successfully resolved from exports, the main field will be ignored.
List of file extensions to try for imports that omit extensions. Note it is NOT recommended to omit extensions for custom import types (e.g. .vue) since it can interfere with IDE and type support.
Enabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).
Configure CSS modules behavior. The options are passed on to postcss-modules.
This option doesn't have any effect when using Lightning CSS. If enabled, css.lightningcss.cssModules should be used instead.
Inline PostCSS config or a custom directory to search PostCSS config from (default is project root).
For inline PostCSS config, it expects the same format as postcss.config.js. But for plugins property, only array format can be used.
The search is done using postcss-load-config and only the supported config file names are loaded.
Note if an inline config is provided, Vite will not search for other PostCSS config sources.
Specify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:
Example:
This option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.
Example:
If this option is set, CSS preprocessors will run in workers when possible. true means the number of CPUs minus 1.
Whether to enable sourcemaps during dev.
Selects the engine used for CSS processing. Check out Lightning CSS for more information.
Configures Lightning CSS. Full transform options can be found in the Lightning CSS repo.
Whether to support named imports from .json files.
If set to true, imported JSON will be transformed into export default JSON.parse("...") which is significantly more performant than Object literals, especially when the JSON file is large.
Enabling this disables named imports.
ESBuildOptions extends esbuild's own transform options. The most common use case is customizing JSX:
By default, esbuild is applied to ts, jsx and tsx files. You can customize this with esbuild.include and esbuild.exclude, which can be a regex, a picomatch pattern, or an array of either.
In addition, you can also use esbuild.jsxInject to automatically inject JSX helper imports for every file transformed by esbuild:
When build.minify is true, all minify optimizations are applied by default. To disable certain aspects of it, set any of esbuild.minifyIdentifiers, esbuild.minifySyntax, or esbuild.minifyWhitespace options to false. Note the esbuild.minify option can't be used to override build.minify.
Set to false to disable esbuild transforms.
Specify additional picomatch patterns to be treated as static assets so that:
They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over fetch or XHR.
Importing them from JS will return their resolved URL string (this can be overwritten if you have a enforce: 'pre' plugin to handle the asset type differently).
The built-in asset type list can be found here.
Example:
Adjust console output verbosity. Default is 'info'.
Use a custom logger to log messages. You can use Vite's createLogger API to get the default logger and customize it to, for example, change the message or filter out certain warnings.
Set to false to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use --clearScreen false.
The directory from which .env files are loaded. Can be an absolute path, or a path relative to the project root.
See here for more about environment files.
Env variables starting with envPrefix will be exposed to your client source code via import.meta.env.
SECURITY NOTES
envPrefix should not be set as '', which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting ''.
If you would like to expose an unprefixed variable, you can use define to expose it:
Whether your application is a Single Page Application (SPA), a Multi Page Application (MPA), or Custom Application (SSR and frameworks with custom HTML handling):
Learn more in Vite's SSR guide. Related: server.middlewareMode.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
An extremely fast CSS parser, transformer, and minifier written in Rust. Use it with Parcel, as a standalone library or CLI, or via a plugin with any other tool.


Lightning CSS can be used from Parcel, as a standalone library from JavaScript or Rust, using a standalone CLI, or wrapped as a plugin within any other tool. See the Lightning CSS website for documentation.


For more benchmarks comparing more tools and input, see here. Note that some of the tools shown perform unsafe optimizations that may change the behavior of the original CSS in favor of smaller file size. Lightning CSS does not do this – the output CSS should always behave identically to the input. Keep this in mind when comparing file sizes between tools.
npm i lightningcss
Gitgithub.com/parcel-bundler/lightningcss
github.com/parcel-bundler/lightningcss#readme
573,046
1.23.0
MPL-2.0
477 kB
14
a month ago
English
English
Appearance
Configuring Vite
Shared Options
Server Options
Build Options
Preview Options
Dep Optimization Options
SSR Options
Worker Options
Beyond Fast
ViteConf 2023
Watch the replay!
Project root directory (where index.html is located). Can be an absolute path, or a path relative to the current working directory.
See Project Root for more details.
Base public path when served in development or production. Valid values include:
See Public Base Path for more details.
Specifying this in config will override the default mode for both serve and build. This value can also be overridden via the command line --mode option.
See Env Variables and Modes for more details.
Define global constant replacements. Entries will be defined as globals during dev and statically replaced during build.
Vite uses esbuild defines to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with JSON.stringify.
Example:
NOTE
For TypeScript users, make sure to add the type declarations in the env.d.ts or vite-env.d.ts file to get type checks and Intellisense.
Example:
Array of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See Plugin API for more details on Vite plugins.
Directory to serve as plain static assets. Files in this directory are served at / during dev and copied to the root of outDir during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.
Defining publicDir as false disables this feature.
See The public Directory for more details.
Directory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use --force flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to .vite when no package.json is detected.
Will be passed to @rollup/plugin-alias as its entries option. Can either be an object, or an array of { find, replacement, customResolver } pairs.
When aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.
More advanced custom resolution can be achieved through plugins.
Using with SSR
If you have configured aliases for SSR externalized dependencies, you may want to alias the actual node_modules packages. Both Yarn and pnpm support aliasing via the npm: prefix.
If you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).
SSR + ESM
For SSR builds, deduplication does not work for ESM build outputs configured from build.rollupOptions.output. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.
Additional allowed conditions when resolving Conditional Exports from a package.
A package with conditional exports may have the following exports field in its package.json:
Here, import and require are "conditions". Conditions can be nested and should be specified from most specific to least specific.
Vite has a list of "allowed conditions" and will match the first condition that is in the allowed list. The default allowed conditions are: import, module, browser, default, and production/development based on current mode. The resolve.conditions config option allows specifying additional allowed conditions.
Resolving subpath exports
Export keys ending with "/" is deprecated by Node and may not work well. Please contact the package author to use * subpath patterns instead.
List of fields in package.json to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the exports field: if an entry point is successfully resolved from exports, the main field will be ignored.
List of file extensions to try for imports that omit extensions. Note it is NOT recommended to omit extensions for custom import types (e.g. .vue) since it can interfere with IDE and type support.
Enabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).
Configure CSS modules behavior. The options are passed on to postcss-modules.
This option doesn't have any effect when using Lightning CSS. If enabled, css.lightningcss.cssModules should be used instead.
Inline PostCSS config or a custom directory to search PostCSS config from (default is project root).
For inline PostCSS config, it expects the same format as postcss.config.js. But for plugins property, only array format can be used.
The search is done using postcss-load-config and only the supported config file names are loaded.
Note if an inline config is provided, Vite will not search for other PostCSS config sources.
Specify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:
Example:
This option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.
Example:
If this option is set, CSS preprocessors will run in workers when possible. true means the number of CPUs minus 1.
Whether to enable sourcemaps during dev.
Selects the engine used for CSS processing. Check out Lightning CSS for more information.
Configures Lightning CSS. Full transform options can be found in the Lightning CSS repo.
Whether to support named imports from .json files.
If set to true, imported JSON will be transformed into export default JSON.parse("...") which is significantly more performant than Object literals, especially when the JSON file is large.
Enabling this disables named imports.
ESBuildOptions extends esbuild's own transform options. The most common use case is customizing JSX:
By default, esbuild is applied to ts, jsx and tsx files. You can customize this with esbuild.include and esbuild.exclude, which can be a regex, a picomatch pattern, or an array of either.
In addition, you can also use esbuild.jsxInject to automatically inject JSX helper imports for every file transformed by esbuild:
When build.minify is true, all minify optimizations are applied by default. To disable certain aspects of it, set any of esbuild.minifyIdentifiers, esbuild.minifySyntax, or esbuild.minifyWhitespace options to false. Note the esbuild.minify option can't be used to override build.minify.
Set to false to disable esbuild transforms.
Specify additional picomatch patterns to be treated as static assets so that:
They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over fetch or XHR.
Importing them from JS will return their resolved URL string (this can be overwritten if you have a enforce: 'pre' plugin to handle the asset type differently).
The built-in asset type list can be found here.
Example:
Adjust console output verbosity. Default is 'info'.
Use a custom logger to log messages. You can use Vite's createLogger API to get the default logger and customize it to, for example, change the message or filter out certain warnings.
Set to false to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use --clearScreen false.
The directory from which .env files are loaded. Can be an absolute path, or a path relative to the project root.
See here for more about environment files.
Env variables starting with envPrefix will be exposed to your client source code via import.meta.env.
SECURITY NOTES
envPrefix should not be set as '', which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting ''.
If you would like to expose an unprefixed variable, you can use define to expose it:
Whether your application is a Single Page Application (SPA), a Multi Page Application (MPA), or Custom Application (SSR and frameworks with custom HTML handling):
Learn more in Vite's SSR guide. Related: server.middlewareMode.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
Playground • Docs • Rust docs • npm • GitHub


By default, CSS identifiers are global. If two files define the same class names, ids, custom properties, @keyframes, etc., they will potentially clash and overwrite each other. To solve this, Lightning CSS supports CSS modules.
CSS modules treat the classes defined in each file as unique. Each class name or identifier is renamed to include a unique hash, and a mapping is exported to JavaScript to allow referencing them.
To enable CSS modules, provide the cssModules option when calling the Lightning CSS API. When using the CLI, enable the --css-modules flag.
This returns an exports object in addition to the compiled code and source map. Each property in the exports object maps from the original name in the source CSS to the compiled (i.e. hashed) name. You can use this mapping in your JavaScript or template files to reference the compiled classes and identifiers.
The exports object for the above example might look like this:
Style rules in CSS modules can reference other classes with the composes property. This causes the referenced class to be applied whenever the composed class is used, effectively providing a form of style mixins.
In the above example, whenever the indigo-white class is applied, the bg-indigo class will be applied as well. This is indicated in the exports object returned by Lightning CSS as follows:
Multiple classes can be composed at once by separating them with spaces.
You can also reference class names defined in a different CSS file using the from keyword:
This outputs an exports object with the dependency information. It is the caller's responsibility to resolve this dependency and apply the target class name when using the transform API. When using the bundle API, this is handled automatically.
Global (i.e. non-hashed) classes can also be composed using the global keyword:
Within a CSS module, all class and id selectors are local by default. You can also opt out of this behavior for a single selector using the :global pseudo class.
compiles to:
By default, class names, id selectors, and the names of @keyframes, @counter-style, and CSS grid lines and areas are scoped to the module they are defined in. Scoping for CSS variables and other <dashed-ident> names can also be enabled using the dashedIdents option when calling the Lightning CSS API. When using the CLI, enable the --css-modules-dashed-idents flag.
When enabled, CSS variables will be renamed so they don't conflict with variable names defined in other files. Referencing a variable uses the standard var() syntax, which Lightning CSS will update to match the locally scoped variable name.
becomes:
You can also reference variables defined in other files using the from keyword:
Global variables may be referenced using the from global syntax.
The same syntax also applies to other CSS values that use the <dashed-ident> syntax. For example, the @font-palette-values rule and font-palette property use the <dashed-ident> syntax to define and refer to custom font color palettes, and will be scoped and referenced the same way as CSS variables.
By default, Lightning CSS prepends the hash of the filename to each class name and identifier in a CSS file. You can configure this naming pattern using the pattern when calling the Lightning CSS API. When using the CLI, provide the --css-modules-pattern option.
A pattern is a string with placeholders that will be filled in by Lightning CSS. This allows you to add custom prefixes or adjust the naming convention for scoped classes.
The following placeholders are currently supported:
Note: CSS grid line names can be ambiguous due to automatic postfixing done by the browser, which generates line names ending with -start and -end for each grid template area. When using CSS grid, your "pattern" configuration must end with the [local] placeholder so that these references work correctly.
Lightning CSS does not currently implement all CSS modules features available in other implementations. Some of these may be added in the future.
English
English
Appearance
Configuring Vite
Shared Options
Server Options
Build Options
Preview Options
Dep Optimization Options
SSR Options
Worker Options
Beyond Fast
ViteConf 2023
Watch the replay!
Browser compatibility target for the final bundle. The default value is a Vite special value, 'modules', which targets browsers with native ES Modules, native ESM dynamic import, and import.meta support. Vite will replace 'modules' to ['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']
Another special value is 'esnext' - which assumes native dynamic imports support and will transpile as little as possible:
The transform is performed with esbuild and the value should be a valid esbuild target option. Custom targets can either be an ES version (e.g. es2015), a browser with version (e.g. chrome58), or an array of multiple target strings.
Note the build will fail if the code contains features that cannot be safely transpiled by esbuild. See esbuild docs for more details.
By default, a module preload polyfill is automatically injected. The polyfill is auto injected into the proxy module of each index.html entry. If the build is configured to use a non-HTML custom entry via build.rollupOptions.input, then it is necessary to manually import the polyfill in your custom entry:
Note: the polyfill does not apply to Library Mode. If you need to support browsers without native dynamic import, you should probably avoid using it in your library.
The polyfill can be disabled using { polyfill: false }.
The list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the base will be used when loading these dependencies. If the base is relative ('' or './'), import.meta.url is used at runtime to avoid absolute paths that depend on the final deployed base.
There is experimental support for fine grained control over the dependencies list and their paths using the resolveDependencies function. Give Feedback. It expects a function of type ResolveModulePreloadDependenciesFn:
The resolveDependencies function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The deps paths are relative to the build.outDir. Returning a relative path to the hostId for hostType === 'js' is allowed, in which case new URL(dep, import.meta.url) is used to get an absolute path when injecting this module preload in the HTML head.
The resolved dependency paths can be further modified using experimental.renderBuiltUrl.
Whether to automatically inject a module preload polyfill.
Specify the output directory (relative to project root).
Specify the directory to nest generated assets under (relative to build.outDir. This is not used in Library Mode).
Imported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to 0 to disable inlining altogether.
If a callback is passed, a boolean can be returned to opt-in or opt-out. If nothing is returned the default logic applies.
Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.
Note
If you specify build.lib, build.assetsInlineLimit will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.
Enable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.
If disabled, all CSS in the entire project will be extracted into a single CSS file.
Note
If you specify build.lib, build.cssCodeSplit will be false as default.
This option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.
It should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the #RGBA hexadecimal color notation in CSS. In this case, you need to set build.cssTarget to chrome61 to prevent vite from transform rgba() colors into #RGBA hexadecimal notations.
This option allows users to override CSS minification specifically instead of defaulting to build.minify, so you can configure minification for JS and CSS separately. Vite uses esbuild by default to minify CSS. Set the option to 'lightningcss' to use Lightning CSS instead. If selected, it can be configured using css.lightningcss.
Generate production source maps. If true, a separate sourcemap file will be created. If 'inline', the sourcemap will be appended to the resulting output file as a data URI. 'hidden' works like true except that the corresponding sourcemap comments in the bundled files are suppressed.
Directly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See Rollup options docs for more details.
Options to pass on to @rollup/plugin-commonjs.
Options to pass on to @rollup/plugin-dynamic-import-vars.
Build as a library. entry is required since the library cannot use HTML as entry. name is the exposed global variable and is required when formats includes 'umd' or 'iife'. Default formats are ['es', 'umd'], or ['es', 'cjs'], if multiple entries are used. fileName is the name of the package file output, default fileName is the name option of package.json, it can also be defined as function taking the format and entryAlias as arguments.
When set to true, the build will also generate a .vite/manifest.json file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links. When the value is a string, it will be used as the manifest file name.
When set to true, the build will also generate an SSR manifest for determining style links and asset preload directives in production. When the value is a string, it will be used as the manifest file name.
Produce SSR-oriented build. The value can be a string to directly specify the SSR entry, or true, which requires specifying the SSR entry via rollupOptions.input.
During the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step.
Set to false to disable minification, or specify the minifier to use. The default is esbuild which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. Benchmarks
Note the build.minify option does not minify whitespaces when using the 'es' format in lib mode, as it removes pure annotations and breaks tree-shaking.
Terser must be installed when it is set to 'terser'.
Additional minify options to pass on to Terser.
In addition, you can also pass a maxWorkers: number option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.
Set to false to disable writing the bundle to disk. This is mostly used in programmatic build() calls where further post processing of the bundle is needed before writing to disk.
By default, Vite will empty the outDir on build if it is inside project root. It will emit a warning if outDir is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as --emptyOutDir.
By default, Vite will copy files from the publicDir into the outDir on build. Set to false to disable this.
Enable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.
Limit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the JavaScript size itself is related to the execution time.
Set to {} to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.
Using Vite on Windows Subsystem for Linux (WSL) 2
There are cases that file system watching does not work with WSL2. See server.watch for more details.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Importing a static asset will return the resolved public URL when it is served:
For example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build.
The behavior is similar to webpack's file-loader. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.
url() references in CSS are handled the same way.
If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.
Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the assetsInclude option.
Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.
Assets smaller in bytes than the assetsInlineLimit option will be inlined as base64 data URLs.
Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.
TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include vite/client.
Assets that are not included in the internal list or in assetsInclude, can be explicitly imported as a URL using the ?url suffix. This is useful, for example, to import Houdini Paint Worklets.
Assets can be imported as strings using the ?raw suffix.
Scripts can be imported as web workers with the ?worker or ?sharedworker suffix.
Check out the Web Worker section for more details.
If you have assets that are:
Then you can place the asset in a special public directory under your project root. Assets in this directory will be served at root path / during dev, and copied to the root of the dist directory as-is.
The directory defaults to <root>/public, but can be configured via the publicDir option.
Note that:
import.meta.url is a native ESM feature that exposes the current module's URL. Combining it with the native URL constructor, we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:
This works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!
This pattern also supports dynamic URLs via template literals:
During the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if build.target does not support import.meta.url
Does not work with SSR
This pattern does not work if you are using Vite for Server-Side Rendering, because import.meta.url have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Importing a static asset will return the resolved public URL when it is served:
For example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build.
The behavior is similar to webpack's file-loader. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.
url() references in CSS are handled the same way.
If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.
Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the assetsInclude option.
Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.
Assets smaller in bytes than the assetsInlineLimit option will be inlined as base64 data URLs.
Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.
TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include vite/client.
Assets that are not included in the internal list or in assetsInclude, can be explicitly imported as a URL using the ?url suffix. This is useful, for example, to import Houdini Paint Worklets.
Assets can be imported as strings using the ?raw suffix.
Scripts can be imported as web workers with the ?worker or ?sharedworker suffix.
Check out the Web Worker section for more details.
If you have assets that are:
Then you can place the asset in a special public directory under your project root. Assets in this directory will be served at root path / during dev, and copied to the root of the dist directory as-is.
The directory defaults to <root>/public, but can be configured via the publicDir option.
Note that:
import.meta.url is a native ESM feature that exposes the current module's URL. Combining it with the native URL constructor, we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:
This works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!
This pattern also supports dynamic URLs via template literals:
During the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if build.target does not support import.meta.url
Does not work with SSR
This pattern does not work if you are using Vite for Server-Side Rendering, because import.meta.url have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Configuring Vite
Shared Options
Server Options
Build Options
Preview Options
Dep Optimization Options
SSR Options
Worker Options
Beyond Fast
ViteConf 2023
Watch the replay!
Project root directory (where index.html is located). Can be an absolute path, or a path relative to the current working directory.
See Project Root for more details.
Base public path when served in development or production. Valid values include:
See Public Base Path for more details.
Specifying this in config will override the default mode for both serve and build. This value can also be overridden via the command line --mode option.
See Env Variables and Modes for more details.
Define global constant replacements. Entries will be defined as globals during dev and statically replaced during build.
Vite uses esbuild defines to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with JSON.stringify.
Example:
NOTE
For TypeScript users, make sure to add the type declarations in the env.d.ts or vite-env.d.ts file to get type checks and Intellisense.
Example:
Array of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See Plugin API for more details on Vite plugins.
Directory to serve as plain static assets. Files in this directory are served at / during dev and copied to the root of outDir during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.
Defining publicDir as false disables this feature.
See The public Directory for more details.
Directory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use --force flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to .vite when no package.json is detected.
Will be passed to @rollup/plugin-alias as its entries option. Can either be an object, or an array of { find, replacement, customResolver } pairs.
When aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.
More advanced custom resolution can be achieved through plugins.
Using with SSR
If you have configured aliases for SSR externalized dependencies, you may want to alias the actual node_modules packages. Both Yarn and pnpm support aliasing via the npm: prefix.
If you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).
SSR + ESM
For SSR builds, deduplication does not work for ESM build outputs configured from build.rollupOptions.output. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.
Additional allowed conditions when resolving Conditional Exports from a package.
A package with conditional exports may have the following exports field in its package.json:
Here, import and require are "conditions". Conditions can be nested and should be specified from most specific to least specific.
Vite has a list of "allowed conditions" and will match the first condition that is in the allowed list. The default allowed conditions are: import, module, browser, default, and production/development based on current mode. The resolve.conditions config option allows specifying additional allowed conditions.
Resolving subpath exports
Export keys ending with "/" is deprecated by Node and may not work well. Please contact the package author to use * subpath patterns instead.
List of fields in package.json to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the exports field: if an entry point is successfully resolved from exports, the main field will be ignored.
List of file extensions to try for imports that omit extensions. Note it is NOT recommended to omit extensions for custom import types (e.g. .vue) since it can interfere with IDE and type support.
Enabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).
Configure CSS modules behavior. The options are passed on to postcss-modules.
This option doesn't have any effect when using Lightning CSS. If enabled, css.lightningcss.cssModules should be used instead.
Inline PostCSS config or a custom directory to search PostCSS config from (default is project root).
For inline PostCSS config, it expects the same format as postcss.config.js. But for plugins property, only array format can be used.
The search is done using postcss-load-config and only the supported config file names are loaded.
Note if an inline config is provided, Vite will not search for other PostCSS config sources.
Specify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:
Example:
This option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.
Example:
If this option is set, CSS preprocessors will run in workers when possible. true means the number of CPUs minus 1.
Whether to enable sourcemaps during dev.
Selects the engine used for CSS processing. Check out Lightning CSS for more information.
Configures Lightning CSS. Full transform options can be found in the Lightning CSS repo.
Whether to support named imports from .json files.
If set to true, imported JSON will be transformed into export default JSON.parse("...") which is significantly more performant than Object literals, especially when the JSON file is large.
Enabling this disables named imports.
ESBuildOptions extends esbuild's own transform options. The most common use case is customizing JSX:
By default, esbuild is applied to ts, jsx and tsx files. You can customize this with esbuild.include and esbuild.exclude, which can be a regex, a picomatch pattern, or an array of either.
In addition, you can also use esbuild.jsxInject to automatically inject JSX helper imports for every file transformed by esbuild:
When build.minify is true, all minify optimizations are applied by default. To disable certain aspects of it, set any of esbuild.minifyIdentifiers, esbuild.minifySyntax, or esbuild.minifyWhitespace options to false. Note the esbuild.minify option can't be used to override build.minify.
Set to false to disable esbuild transforms.
Specify additional picomatch patterns to be treated as static assets so that:
They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over fetch or XHR.
Importing them from JS will return their resolved URL string (this can be overwritten if you have a enforce: 'pre' plugin to handle the asset type differently).
The built-in asset type list can be found here.
Example:
Adjust console output verbosity. Default is 'info'.
Use a custom logger to log messages. You can use Vite's createLogger API to get the default logger and customize it to, for example, change the message or filter out certain warnings.
Set to false to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use --clearScreen false.
The directory from which .env files are loaded. Can be an absolute path, or a path relative to the project root.
See here for more about environment files.
Env variables starting with envPrefix will be exposed to your client source code via import.meta.env.
SECURITY NOTES
envPrefix should not be set as '', which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting ''.
If you would like to expose an unprefixed variable, you can use define to expose it:
Whether your application is a Single Page Application (SPA), a Multi Page Application (MPA), or Custom Application (SSR and frameworks with custom HTML handling):
Learn more in Vite's SSR guide. Related: server.middlewareMode.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
We read every piece of feedback, and take your input very seriously.

            To see all available qualifiers, see our documentation.
          

        🚀 It's a very fast and efficient glob library for Node.js
      
It's a very fast and efficient glob library for Node.js.
This package provides methods for traversing the file system and returning pathnames that matched a defined set of a specified pattern according to the rules used by the Unix Bash shell with some simplifications, meanwhile results are returned in arbitrary order. Quick, simple, effective.
⚠️ Always use forward-slashes in glob expressions (patterns and ignore option). Use backslashes for escaping characters.
There is more than one form of syntax: basic and advanced. Below is a brief overview of the supported features. Also pay attention to our FAQ.
📖 This package uses micromatch as a library for pattern matching.
📖 A few additional words about the basic matching behavior.
Some examples:
📖 A few additional words about the advanced matching behavior.
Some examples:
Returns a Promise with an array of matching entries.
Returns an array of matching entries.
Returns a ReadableStream when the data event will be emitted with matching entry.
Any correct pattern(s).
🔢 Pattern syntax
⚠️ This package does not respect the order of patterns. First, all the negative patterns are applied, and only then the positive patterns. If you want to get a certain order of records, use sorting or split calls.
See Options section.
Returns the internal representation of patterns (Task is a combining patterns by base directory).
Any correct pattern(s).
See Options section.
Returns true if the passed pattern is a dynamic pattern.
🔢 What is a static or dynamic pattern?
Any correct pattern.
See Options section.
Returns the path with escaped special characters depending on the platform.
Converts a path to a pattern depending on the platform, including special character escaping.
The current working directory in which to search.
Specifies the maximum depth of a read directory relative to the start directory.
For example, you have the following tree:
📖 If you specify a pattern with some base directory, this directory will not participate in the calculation of the depth of the found directories. Think of it as a cwd option.
Indicates whether to traverse descendants of symbolic link directories when expanding ** patterns.
📖 Note that this option does not affect the base directory of the pattern. For example, if ./a is a symlink to directory ./b and you specified ['./a**', './b/**'] patterns, then directory ./a will still be read.
📖 If the stats option is specified, the information about the symbolic link (fs.lstat) will be replaced with information about the entry (fs.stat) behind it.
Custom implementation of methods for working with the file system. Supports objects with enumerable properties only.
An array of glob patterns to exclude matches. This is an alternative way to use negative patterns.
By default this package suppress only ENOENT errors. Set to true to suppress any error.
📖 Can be useful when the directory has entries with a special level of access.
Throw an error when symbolic link is broken if true or safely return lstat call if false.
📖 This option has no effect on errors when reading the symbolic link directory.
Return the absolute path for entries.
📖 This option is required if you want to use negative patterns with absolute path, for example, !${__dirname}/*.js.
Mark the directory path with the final slash.
Returns objects (instead of strings) describing entries.
The object has the following fields:
📖 An object is an internal representation of entry, so getting it does not affect performance.
Return only directories.
📖 If true, the onlyFiles option is automatically false.
Return only files.
Enables an object mode with an additional field:
📖 Returns fs.stat instead of fs.lstat for symbolic links when the followSymbolicLinks option is specified.
Ensures that the returned entries are unique.
If true and similar entries are found, the result is the first found.
Enables Bash-like brace expansion.
🔢 Syntax description or more detailed description.
Enables a case-sensitive mode for matching files.
Allow patterns to match entries that begin with a period (.).
📖 Note that an explicit dot in a portion of the pattern will always match dot files.
Enables Bash-like extglob functionality.
🔢 Syntax description.
Enables recursively repeats a pattern containing **. If false, ** behaves exactly like *.
If set to true, then patterns without slashes will be matched against the basename of the path if it contains slashes.
All patterns can be divided into two types:
A pattern is considered dynamic if it contains the following characters (… — any characters or their absence) or options:
Always use forward-slashes in glob expressions (patterns and ignore option). Use backslashes for escaping characters. With the cwd option use a convenient format.
Bad
Good
📖 Use the .convertPathToPattern package to convert Windows-style path to a Unix-style path.
Read more about matching with backslashes.
Refers to Bash. You need to escape special characters:
Read more about matching special characters as literals. Or use the .escapePath.
You can use a negative pattern like this: !**/node_modules or !**/node_modules/**. Also you can use ignore option. Just look at the example below.
If you don't want to read the second directory, you must write the following pattern: !**/second or !**/second/**.
⚠️ When you write !**/second/**/* it means that the directory will be read, but all the entries will not be included in the results.
You have to understand that if you write the pattern to exclude directories, then the directory will not be read under any circumstances.
You cannot use Uniform Naming Convention (UNC) paths as patterns (due to syntax) directly, but you can use them as cwd directory or use the fg.convertPathToPattern method.
You can see results here for every commit into the main branch.
See the Releases section of our GitHub project for changelog for each release version.
This software is released under the terms of the MIT license.

        🚀 It's a very fast and efficient glob library for Node.js
      
We read every piece of feedback, and take your input very seriously.

            To see all available qualifiers, see our documentation.
          

        🚀 It's a very fast and efficient glob library for Node.js
      
It's a very fast and efficient glob library for Node.js.
This package provides methods for traversing the file system and returning pathnames that matched a defined set of a specified pattern according to the rules used by the Unix Bash shell with some simplifications, meanwhile results are returned in arbitrary order. Quick, simple, effective.
⚠️ Always use forward-slashes in glob expressions (patterns and ignore option). Use backslashes for escaping characters.
There is more than one form of syntax: basic and advanced. Below is a brief overview of the supported features. Also pay attention to our FAQ.
📖 This package uses micromatch as a library for pattern matching.
📖 A few additional words about the basic matching behavior.
Some examples:
📖 A few additional words about the advanced matching behavior.
Some examples:
Returns a Promise with an array of matching entries.
Returns an array of matching entries.
Returns a ReadableStream when the data event will be emitted with matching entry.
Any correct pattern(s).
🔢 Pattern syntax
⚠️ This package does not respect the order of patterns. First, all the negative patterns are applied, and only then the positive patterns. If you want to get a certain order of records, use sorting or split calls.
See Options section.
Returns the internal representation of patterns (Task is a combining patterns by base directory).
Any correct pattern(s).
See Options section.
Returns true if the passed pattern is a dynamic pattern.
🔢 What is a static or dynamic pattern?
Any correct pattern.
See Options section.
Returns the path with escaped special characters depending on the platform.
Converts a path to a pattern depending on the platform, including special character escaping.
The current working directory in which to search.
Specifies the maximum depth of a read directory relative to the start directory.
For example, you have the following tree:
📖 If you specify a pattern with some base directory, this directory will not participate in the calculation of the depth of the found directories. Think of it as a cwd option.
Indicates whether to traverse descendants of symbolic link directories when expanding ** patterns.
📖 Note that this option does not affect the base directory of the pattern. For example, if ./a is a symlink to directory ./b and you specified ['./a**', './b/**'] patterns, then directory ./a will still be read.
📖 If the stats option is specified, the information about the symbolic link (fs.lstat) will be replaced with information about the entry (fs.stat) behind it.
Custom implementation of methods for working with the file system. Supports objects with enumerable properties only.
An array of glob patterns to exclude matches. This is an alternative way to use negative patterns.
By default this package suppress only ENOENT errors. Set to true to suppress any error.
📖 Can be useful when the directory has entries with a special level of access.
Throw an error when symbolic link is broken if true or safely return lstat call if false.
📖 This option has no effect on errors when reading the symbolic link directory.
Return the absolute path for entries.
📖 This option is required if you want to use negative patterns with absolute path, for example, !${__dirname}/*.js.
Mark the directory path with the final slash.
Returns objects (instead of strings) describing entries.
The object has the following fields:
📖 An object is an internal representation of entry, so getting it does not affect performance.
Return only directories.
📖 If true, the onlyFiles option is automatically false.
Return only files.
Enables an object mode with an additional field:
📖 Returns fs.stat instead of fs.lstat for symbolic links when the followSymbolicLinks option is specified.
Ensures that the returned entries are unique.
If true and similar entries are found, the result is the first found.
Enables Bash-like brace expansion.
🔢 Syntax description or more detailed description.
Enables a case-sensitive mode for matching files.
Allow patterns to match entries that begin with a period (.).
📖 Note that an explicit dot in a portion of the pattern will always match dot files.
Enables Bash-like extglob functionality.
🔢 Syntax description.
Enables recursively repeats a pattern containing **. If false, ** behaves exactly like *.
If set to true, then patterns without slashes will be matched against the basename of the path if it contains slashes.
All patterns can be divided into two types:
A pattern is considered dynamic if it contains the following characters (… — any characters or their absence) or options:
Always use forward-slashes in glob expressions (patterns and ignore option). Use backslashes for escaping characters. With the cwd option use a convenient format.
Bad
Good
📖 Use the .convertPathToPattern package to convert Windows-style path to a Unix-style path.
Read more about matching with backslashes.
Refers to Bash. You need to escape special characters:
Read more about matching special characters as literals. Or use the .escapePath.
You can use a negative pattern like this: !**/node_modules or !**/node_modules/**. Also you can use ignore option. Just look at the example below.
If you don't want to read the second directory, you must write the following pattern: !**/second or !**/second/**.
⚠️ When you write !**/second/**/* it means that the directory will be read, but all the entries will not be included in the results.
You have to understand that if you write the pattern to exclude directories, then the directory will not be read under any circumstances.
You cannot use Uniform Naming Convention (UNC) paths as patterns (due to syntax) directly, but you can use them as cwd directory or use the fg.convertPathToPattern method.
You can see results here for every commit into the main branch.
See the Releases section of our GitHub project for changelog for each release version.
This software is released under the terms of the MIT license.

        🚀 It's a very fast and efficient glob library for Node.js
      
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
Web technology reference for developers
Structure of content on the web
Code used to describe document style
General-purpose scripting language
Protocol for transmitting web resources
Interfaces for building web applications
Developing extensions for web browsers
Web technology reference for developers
Learn web development
Learn web development
Learn to structure web content with HTML
Learn to style content using CSS
Learn to run scripts in the browser
Learn to make the web accessible to all
A customized MDN experience
Get real-time assistance and support
All browser compatibility updates at a glance
Learn how to use MDN Plus
Frequently asked questions about MDN Plus
A WebAssembly.Instance object is a stateful, executable instance of a WebAssembly.Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.
Creates a new Instance object.
Returns an object containing as its members all the functions exported from the WebAssembly module instance, to allow them to be accessed and used by JavaScript. Read-only.
The WebAssembly.Instance() constructor function can be called to synchronously instantiate a given WebAssembly.Module object, for example:
The preferred way to get an Instance is asynchronously, for example using the WebAssembly.instantiateStreaming() function like this:
This also demonstrates how the exports property is used to access exported functions.
BCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.
This page was last modified on Nov 20, 2023 by MDN contributors.
Your blueprint for a better internet.
Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation.Portions of this content are ©1998–2024 by individual mozilla.org contributors. Content available under a Creative Commons license.
Web technology reference for developers
Structure of content on the web
Code used to describe document style
General-purpose scripting language
Protocol for transmitting web resources
Interfaces for building web applications
Developing extensions for web browsers
Web technology reference for developers
Learn web development
Learn web development
Learn to structure web content with HTML
Learn to style content using CSS
Learn to run scripts in the browser
Learn to make the web accessible to all
A customized MDN experience
Get real-time assistance and support
All browser compatibility updates at a glance
Learn how to use MDN Plus
Frequently asked questions about MDN Plus

  The WebAssembly.instantiate() function allows you to
  compile and instantiate WebAssembly code. This function has two overloads:


Warning: This method is not the most efficient way of fetching and
    instantiating Wasm modules. If at all possible, you should use the newer
    WebAssembly.instantiateStreaming() method instead, which fetches,
    compiles, and instantiates a module all in one step, directly from the raw bytecode,
    so doesn't require conversion to an ArrayBuffer.
  

      A typed array or
      ArrayBuffer containing the binary code of the Wasm module you want to
      compile, or a WebAssembly.Module.
    

      An object containing the values to be imported into the newly-created
      Instance, such as functions or WebAssembly.Memory objects.
      There must be one matching property for each declared import of the compiled module or
      else a WebAssembly.LinkError is thrown.
    

  A Promise that resolves to a ResultObject which contains two
  fields:

The WebAssembly.Module object to be instantiated.

      An object containing the values to be imported into the newly-created
      Instance, such as functions or WebAssembly.Memory objects.
      There must be one matching property for each declared import of module or
      else a WebAssembly.LinkError is thrown.
    
A Promise that resolves to an WebAssembly.Instance object.
Note: You'll probably want to use WebAssembly.instantiateStreaming() in most cases, as it is more efficient than instantiate().

  After fetching some WebAssembly bytecode using fetch, we compile and instantiate the
  module using the WebAssembly.instantiate() function, importing a
  JavaScript function into the WebAssembly Module in the process. We then call an Exported WebAssembly function
  that is exported by the Instance.


Note: You can also find this example at index.html
    on GitHub (view it live also).
  

  The following example (see our index-compile.html
  demo on GitHub, and view it live also)
  compiles the loaded simple.wasm byte code using the
  WebAssembly.compileStreaming() method and then sends it to a worker using
  postMessage().


  In the worker (see
  wasm_worker.js)
  we define an import object for the module to use, then set up an event handler to
  receive the module from the main thread. When the module is received, we create an
  instance from it using the WebAssembly.instantiate() method and invoke an
  exported function from inside it.

BCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.
This page was last modified on Nov 20, 2023 by MDN contributors.
Your blueprint for a better internet.
Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation.Portions of this content are ©1998–2024 by individual mozilla.org contributors. Content available under a Creative Commons license.
We read every piece of feedback, and take your input very seriously.

            To see all available qualifiers, see our documentation.
          

        ECMAScript module integration
      

This repository is a clone of github.com/WebAssembly/spec/. It is meant for discussion, prototype specification and implementation of a proposal to add ES module integration to WebAssembly.
The specifics of the ES Module integration Proposal are found in this subfolder.
A formatted version of the spec, including this proposal, is available here: webassembly.github.io/esm-integration.
Note: It is possible to implement the Wasm-ESM integration in two stages. In the first stage only source phase imports of Wasm are supported (import source fibModule from "./fib.wasm"). In the second stage, evaluation phase imports would be supported too (import { fib } from "./fib.wasm"). If initially implementing just source phase imports, the GetExportedNames, ResolveExport, InitializeEnvironment, and ExecuteModule abstract operations can be implemented as abstract operations unconditionally throwing a SyntaxError exception. In this case, module fetch and CSP integration is still required to be implemented as specified in this proposal. Implementers are encouraged to ship both stages at once, but it is deemed OK for implementers to initially ship the first stage and then quickly follow up with the second stage, if this aids "time to ship" in implementations.
Original README from upstream repository follows...
This repository holds the sources for the WebAssembly draft specification
(to seed a future
WebAssembly Working Group),
a reference implementation, and the official testsuite.
A formatted version of the spec is available here:
webassembly.github.io/spec,
Participation is welcome. Discussions about new features, significant semantic
changes, or any specification change likely to generate substantial discussion
should take place in
the WebAssembly design repository
first, so that this spec repository can remain focused. And please follow the
guidelines for contributing.
For citing WebAssembly in LaTeX, use this bibtex file.

        ECMAScript module integration
      
We read every piece of feedback, and take your input very seriously.

            To see all available qualifiers, see our documentation.
          

        Add WebAssembly ESM integration (aka. Webpack's `asyncWebAssembly`) to Vite and support `wasm-pack` generated modules.
      





Add WebAssembly ESM integration (aka. Webpack's asyncWebAssembly) to Vite and support wasm-pack generated modules.
Now this plugin supports both Vite 2.x and 3.x. Just install it:
You also need the vite-plugin-top-level-await plugin unless you target very modern browsers only (i.e. set build.target to esnext).
If you are getting ESBuild errors of WASM files (In the format No loader is configured for ".wasm" files: node_modules/somepackage/somefile.wasm) with Vite < 3.0.3, please upgrade your Vite to >= 3.0.3 or upgrade this plugin to >= 3.1.0. A workaround is adding the corresponding imported module within node_modules to optimizeDeps.exclude, e.g.:
To use this plugin in Web Workers. Add it (and vite-plugin-top-level-await if necessary) to worker.plugins. To support Firefox, don't use ES workers. leave worker.format default and use vite-plugin-top-level-await >= 1.4.0 (see also here):
TypeScript typing is broken. Since we can't declare a module with Record<string, any> as its named export map. Your import ... from "./module.wasm"; will still got Vite's bulit-in typing, but the transformed code is fine. So just use an asterisk import import * as wasmModule from "./module.wasm" and type assertion (you have typing for your WASM files, right?).

        Add WebAssembly ESM integration (aka. Webpack's `asyncWebAssembly`) to Vite and support `wasm-pack` generated modules.
      
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Importing a static asset will return the resolved public URL when it is served:
For example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build.
The behavior is similar to webpack's file-loader. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.
url() references in CSS are handled the same way.
If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.
Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the assetsInclude option.
Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.
Assets smaller in bytes than the assetsInlineLimit option will be inlined as base64 data URLs.
Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.
TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include vite/client.
Assets that are not included in the internal list or in assetsInclude, can be explicitly imported as a URL using the ?url suffix. This is useful, for example, to import Houdini Paint Worklets.
Assets can be imported as strings using the ?raw suffix.
Scripts can be imported as web workers with the ?worker or ?sharedworker suffix.
Check out the Web Worker section for more details.
If you have assets that are:
Then you can place the asset in a special public directory under your project root. Assets in this directory will be served at root path / during dev, and copied to the root of the dist directory as-is.
The directory defaults to <root>/public, but can be configured via the publicDir option.
Note that:
import.meta.url is a native ESM feature that exposes the current module's URL. Combining it with the native URL constructor, we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:
This works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!
This pattern also supports dynamic URLs via template literals:
During the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if build.target does not support import.meta.url
Does not work with SSR
This pattern does not work if you are using Vite for Server-Side Rendering, because import.meta.url have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
We read every piece of feedback, and take your input very seriously.

            To see all available qualifiers, see our documentation.
          

Have a question about this project? Sign up for a free GitHub account to open an issue and contact its maintainers and the community.
  
By clicking “Sign up for GitHub”, you agree to our terms of service and
  privacy statement. We’ll occasionally send you account related emails.

    Already on GitHub?
    Sign in
    to your account
  
Currently, the wasm plugin usually get the .wasm file using fetch. This approach doesn't work in SSR. Even if fetch were available, fetching a relative path would not work. This results in errors such as ERR_INVALID_URL when in SSR.
By adding an extra if cause to the wasm helper, we could check the import.meta.env.SSR to see if we're in SSR mode. If we are, then we could load the file from disk instead of fetching it over the network. Something like this:
However, there might be problems to using import.meta that I'm not aware of. It seems to work fine for me when I'm testing it, but I've only tested it with SvelteKit.
If using the SSR environment variable isn't an option, then we could of course use some typeof window === "undefined" or perhaps process would be better. But there might be several pitfalls with that, mainly other plugins that polyfills window, process or whatever thing we might use. Perhaps a better approach would be to add the file system logic in a .catch block on the fetch itself, something like:
Another problem with loading from disk is that the URL provided is a URL, and not a file path. Fortunately it contains the file path, but I'm not sure if that would always be the case, or if it might be a better way of resolving the file path. Using the provided url string, it is possible to decode the path using something like url.replace("/@fs", "").
A workaround is to use another wasm plugin. I haven't found a vite wasm plugin that works with SSR, so currently we have created our own just to make it work (using the import.meta.env.SSR technique mentioned above). That works great with SvelteKit, but might not work with everything. If it's of any interest to someone else, just let me know and I can see if we could push it to NPM.
I've also raised an issue (Menci/vite-plugin-wasm#4) in the vite-pugin-wasm repo to make SSR work, but it has some challenges regarding ESM to utilize import.meta.
No response




              The text was updated successfully, but these errors were encountered:
            
If anyone finds this issue and needs a quick fix, we've created a vite plugin to use your WASM packages as regular ES modules that also supports SSR. Only supports wasm-pack generated modules at the moment.










    Sorry, something went wrong.
  
No branches or pull requests
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
Web technology reference for developers
Structure of content on the web
Code used to describe document style
General-purpose scripting language
Protocol for transmitting web resources
Interfaces for building web applications
Developing extensions for web browsers
Web technology reference for developers
Learn web development
Learn web development
Learn to structure web content with HTML
Learn to style content using CSS
Learn to run scripts in the browser
Learn to make the web accessible to all
A customized MDN experience
Get real-time assistance and support
All browser compatibility updates at a glance
Learn how to use MDN Plus
Frequently asked questions about MDN Plus
The Worker() constructor creates a Worker object that executes the script at the specified URL. This script must obey the same-origin policy.
Note: that there is a disagreement among browser manufacturers about whether a data URL is of the same origin or not. Though Firefox 10 and later accept data URLs, that's not the case in all other browsers.
A string representing the URL of the script the worker will execute. It must obey the same-origin policy.
An object containing option properties that can be set when creating the object instance. Available properties are as follows:
A string specifying the type of worker to create. The value can be classic or module. If not specified, the default used is classic.
A string specifying the type of credentials to use for the worker. The value can be omit, same-origin, or include. If not specified, or if type is classic, the default used is omit (no credentials required).
A string specifying an identifying name for the DedicatedWorkerGlobalScope representing the scope of the worker, which is mainly useful for debugging purposes.
Thrown if the document is not allowed to start workers, e.g. if the URL has an invalid syntax or if the same-origin policy is violated.

      Thrown if the MIME type of the worker script is incorrect. It should always be text/javascript
      (for historical reasons other JavaScript MIME types may be accepted).
    
Thrown if aURL cannot be parsed.
The following code snippet shows creation of a Worker object using the Worker() constructor and subsequent usage of the object:
For a full example, see our Basic dedicated worker example (run dedicated worker).
BCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.
The Worker interface it belongs to.
This page was last modified on Apr 8, 2023 by MDN contributors.
Your blueprint for a better internet.
Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation.Portions of this content are ©1998–2024 by individual mozilla.org contributors. Content available under a Creative Commons license.
Web technology reference for developers
Structure of content on the web
Code used to describe document style
General-purpose scripting language
Protocol for transmitting web resources
Interfaces for building web applications
Developing extensions for web browsers
Web technology reference for developers
Learn web development
Learn web development
Learn to structure web content with HTML
Learn to style content using CSS
Learn to run scripts in the browser
Learn to make the web accessible to all
A customized MDN experience
Get real-time assistance and support
All browser compatibility updates at a glance
Learn how to use MDN Plus
Frequently asked questions about MDN Plus

  The SharedWorker() constructor creates a
  SharedWorker object that executes the script at the specified URL. This
  script must obey the same-origin policy.


Note: there is disagreement among browser manufacturers about
    whether a data URL is of the same origin or not. Although Firefox 10.0
    and later accept data URLs, that's not the case in all other
    browsers.
  

      A string representing the URL of the script the worker will
      execute. It must obey the same-origin policy.
    

      A string specifying an identifying name for the
      SharedWorkerGlobalScope representing the scope of the worker, which is useful for creating new instances of the same SharedWorker and debugging.
    

      An object containing option properties that can set when creating the object
      instance. Available properties are as follows:
    

          A string specifying the type of worker to
          create. The value can be classic or module. If not
          specified, the default used is classic.
        

          A string specifying the type of
          credentials to use for the worker. The value can be omit,
          same-origin, or include. If not
specified, or if type is classic, the default used is
omit (no credentials required).


          A string specifying an
          identifying name for the SharedWorkerGlobalScope representing the
          scope of the worker, which is mainly useful for debugging purposes.
        
Thrown if the document is not allowed to start workers, for example if the URL has an invalid syntax or if the same-origin policy is violated.
Thrown if the MIME type of the worker script is incorrect. It should always be text/javascript (for historical reasons other JavaScript MIME types may be accepted).
Thrown if aURL cannot be parsed.

  The following code snippet shows creation of a SharedWorker object using
  the SharedWorker() constructor and subsequent usage of the object:

For a full example, see our Basic shared worker example (run shared worker.)
BCD tables only load in the browser with JavaScript enabled. Enable JavaScript to view data.
This page was last modified on Jul 11, 2023 by MDN contributors.
Your blueprint for a better internet.
Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation.Portions of this content are ©1998–2024 by individual mozilla.org contributors. Content available under a Creative Commons license.
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors



Browser support tables for modern web technologies
Created & maintained by @Fyrd, design by @Lensco.
Support data contributions by the GitHub community.
	
	
		Usage share statistics by StatCounter GlobalStats for January, 2024	
Location detection provided by ipinfo.io.
	

		Browser testing done via 
		





		Usage share statistics by StatCounter GlobalStats for January, 2024	
Location detection provided by ipinfo.io.
	

		Browser testing done via 
		



Become a caniuse Patron to support the site for only $1/month!

							or Log in

English
English
Appearance
Configuring Vite
Shared Options
Server Options
Build Options
Preview Options
Dep Optimization Options
SSR Options
Worker Options
Beyond Fast
ViteConf 2023
Watch the replay!
Options related to Web Workers.
Output format for worker bundle.
Vite plugins that apply to the worker bundles. Note that config.plugins only applies to workers in dev, it should be configured here instead for build. The function should return new plugin instances as they are used in parallel rollup worker builds. As such, modifying config.worker options in the config hook will be ignored.
Rollup options to build worker bundle.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
A flash of unstyled content (FOUC, or flash of unstyled text)[1][2] is an instance where a web page appears briefly with the browser's default styles prior to loading an external CSS stylesheet, due to the web browser engine rendering the page before all information is retrieved.[3] The page corrects itself as soon as the style rules are loaded and applied; however, the shift may be distracting. Related problems include flash of invisible text and flash of faux text.[1][2]

The issue was documented in an article named "Flash of Unstyled Content".[4] At first, FOUC appeared to be a browser problem unique to Internet Explorer but later became apparent in other browsers,[5][6] and has since been described as "a Safari epidemic".[7]

A flash of unstyled content is indifferent to changes in CSS or HTML versions. This problem, which leaves the core content unaffected, originates from a set of priorities programmed into the browser.[citation needed] As the browser collects HTML and all the ancillary files referenced in the markup, the browser builds the Document Object Model on-the-fly. The browser may choose to first display the text so that it can parse the quickest.

Flashes of unstyled content are more prevalent now that HTML pages are more apt to reference multiple style sheets. Web pages often include style references to media other than the browser screen, such as CSS rules for printers and mobile devices. Web pages may import layers of style files, and reference alternative style sheets. Online advertisements and other inserted offsite content, like videos and search engines, often dictate their own style rules within their code block. The cascading nature of CSS rules encourages some browsers to wait until all the style datasets have been collected before applying them.

With the advent of JavaScript libraries such as jQuery which can be employed to further define and apply the styling of a web page, flashes of unstyled content have also become more prominent. In an attempt to avoid unstyled content, front-end developers may choose to hide all content until it is fully loaded, at which point a load event handler is triggered and the content appears, though an interruption of loading might leave behind a blank page, to which unstyled content would be preferable.

To emulate a flash of unstyled content, developers can use browser add-ons that are capable of disabling a web page's CSS on the fly.  Firebug and Async CSS are such add-ons.  Other techniques include manually stopping a page from completing the loading of CSS components.  Another option entails using script-blocking tools.

While, by 2016, several different techniques had been developed to avoid undesired display behaviours,[2] a change in rendering behaviour in Google Chrome version 50, whereby stylesheets injected by JavaScript are prevented from blocking page loading, as required by the HTML5 specification, brought the situation to website creators' attentions again, particularly affecting users of Typekit, a web typography product from Adobe Systems.[1] Within 2 months, Adobe had changed the way in which their fonts were included into third-party websites in order to avoid the undesired rendering behaviour.[8]

English
English
Appearance
Configuring Vite
Shared Options
Server Options
Build Options
Preview Options
Dep Optimization Options
SSR Options
Worker Options
Beyond Fast
ViteConf 2023
Watch the replay!
Browser compatibility target for the final bundle. The default value is a Vite special value, 'modules', which targets browsers with native ES Modules, native ESM dynamic import, and import.meta support. Vite will replace 'modules' to ['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']
Another special value is 'esnext' - which assumes native dynamic imports support and will transpile as little as possible:
The transform is performed with esbuild and the value should be a valid esbuild target option. Custom targets can either be an ES version (e.g. es2015), a browser with version (e.g. chrome58), or an array of multiple target strings.
Note the build will fail if the code contains features that cannot be safely transpiled by esbuild. See esbuild docs for more details.
By default, a module preload polyfill is automatically injected. The polyfill is auto injected into the proxy module of each index.html entry. If the build is configured to use a non-HTML custom entry via build.rollupOptions.input, then it is necessary to manually import the polyfill in your custom entry:
Note: the polyfill does not apply to Library Mode. If you need to support browsers without native dynamic import, you should probably avoid using it in your library.
The polyfill can be disabled using { polyfill: false }.
The list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the base will be used when loading these dependencies. If the base is relative ('' or './'), import.meta.url is used at runtime to avoid absolute paths that depend on the final deployed base.
There is experimental support for fine grained control over the dependencies list and their paths using the resolveDependencies function. Give Feedback. It expects a function of type ResolveModulePreloadDependenciesFn:
The resolveDependencies function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The deps paths are relative to the build.outDir. Returning a relative path to the hostId for hostType === 'js' is allowed, in which case new URL(dep, import.meta.url) is used to get an absolute path when injecting this module preload in the HTML head.
The resolved dependency paths can be further modified using experimental.renderBuiltUrl.
Whether to automatically inject a module preload polyfill.
Specify the output directory (relative to project root).
Specify the directory to nest generated assets under (relative to build.outDir. This is not used in Library Mode).
Imported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to 0 to disable inlining altogether.
If a callback is passed, a boolean can be returned to opt-in or opt-out. If nothing is returned the default logic applies.
Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.
Note
If you specify build.lib, build.assetsInlineLimit will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.
Enable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.
If disabled, all CSS in the entire project will be extracted into a single CSS file.
Note
If you specify build.lib, build.cssCodeSplit will be false as default.
This option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.
It should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the #RGBA hexadecimal color notation in CSS. In this case, you need to set build.cssTarget to chrome61 to prevent vite from transform rgba() colors into #RGBA hexadecimal notations.
This option allows users to override CSS minification specifically instead of defaulting to build.minify, so you can configure minification for JS and CSS separately. Vite uses esbuild by default to minify CSS. Set the option to 'lightningcss' to use Lightning CSS instead. If selected, it can be configured using css.lightningcss.
Generate production source maps. If true, a separate sourcemap file will be created. If 'inline', the sourcemap will be appended to the resulting output file as a data URI. 'hidden' works like true except that the corresponding sourcemap comments in the bundled files are suppressed.
Directly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See Rollup options docs for more details.
Options to pass on to @rollup/plugin-commonjs.
Options to pass on to @rollup/plugin-dynamic-import-vars.
Build as a library. entry is required since the library cannot use HTML as entry. name is the exposed global variable and is required when formats includes 'umd' or 'iife'. Default formats are ['es', 'umd'], or ['es', 'cjs'], if multiple entries are used. fileName is the name of the package file output, default fileName is the name option of package.json, it can also be defined as function taking the format and entryAlias as arguments.
When set to true, the build will also generate a .vite/manifest.json file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links. When the value is a string, it will be used as the manifest file name.
When set to true, the build will also generate an SSR manifest for determining style links and asset preload directives in production. When the value is a string, it will be used as the manifest file name.
Produce SSR-oriented build. The value can be a string to directly specify the SSR entry, or true, which requires specifying the SSR entry via rollupOptions.input.
During the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step.
Set to false to disable minification, or specify the minifier to use. The default is esbuild which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. Benchmarks
Note the build.minify option does not minify whitespaces when using the 'es' format in lib mode, as it removes pure annotations and breaks tree-shaking.
Terser must be installed when it is set to 'terser'.
Additional minify options to pass on to Terser.
In addition, you can also pass a maxWorkers: number option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.
Set to false to disable writing the bundle to disk. This is mostly used in programmatic build() calls where further post processing of the bundle is needed before writing to disk.
By default, Vite will empty the outDir on build if it is inside project root. It will emit a warning if outDir is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as --emptyOutDir.
By default, Vite will copy files from the publicDir into the outDir on build. Set to false to disable this.
Enable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.
Limit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the JavaScript size itself is related to the execution time.
Set to {} to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.
Using Vite on Windows Subsystem for Linux (WSL) 2
There are cases that file system watching does not work with WSL2. See server.watch for more details.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
At the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.
Native ES imports do not support bare module imports like the following:
The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:
Pre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.
Rewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.
Dependencies are Strongly Cached
Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.
Vite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.
Note you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.
Vite supports importing .ts files out of the box.
Note that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.
The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.
Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.
For production builds, you can run tsc --noEmit in addition to Vite's build command.
During development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.
Vite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.
Use the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:
Some configuration fields under compilerOptions in tsconfig.json require special attention.
Should be set to true.
It is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.
You must set "isolatedModules": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.
However, some libraries (e.g. vue) don't work well with "isolatedModules": true. You can use "skipLibCheck": true to temporarily suppress the errors until it is fixed upstream.
Starting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.
Other TypeScript targets will default to false.
But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.
If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.
Most libraries expect "useDefineForClassFields": true, such as MobX.
But a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.
Vite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.
The esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.
useDefineForClassFields
If target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.
As such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.
skipLibCheck
Vite starter templates have "skipLibCheck": "true" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.
Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:
Alternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:
This will provide the following type shims:
TIP
To override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.
For example, to make the default import of *.svg a React component:
Vite provides first-class Vue support:
.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.
Vue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.
If using JSX without React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:
More details in esbuild docs.
You can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:
Importing .css files will inject its content to the page via a <style> tag with HMR support.
Vite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.
@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).
If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.
Note that CSS minification will run after PostCSS and will use build.cssTarget option.
Any CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:
CSS modules behavior can be configured via the css.modules option.
If css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:
Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.
That said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:
If using Vue single file components, this also automatically enables <style lang="sass"> et al.
Vite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.
@import alias and url rebasing are not supported for Stylus due to its API constraints.
You can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.
The automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.
NOTE
Default and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.
Starting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:
If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightningcss config option.
To configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).
By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.
NOTE
CSS Pre-processors aren't supported when using Lightning CSS.
Importing a static asset will return the resolved public URL when it is served:
Special queries can modify how assets are loaded:
More details in Static Asset Handling.
JSON files can be directly imported - named imports are also supported:
Vite supports importing multiple modules from the file system via the special import.meta.glob function:
The above will be transformed into the following:
You can then iterate over the keys of the modules object to access the corresponding modules:
Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:
The above will be transformed into the following:
The first argument can be an array of globs, for example
Negative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:
It's possible to only import parts of the modules with the import options.
When combined with eager it's even possible to have tree-shaking enabled for those modules.
Set import to default to import the default export.
You can also use the query option to provide queries to imports, for example, to import assets as a string or as a url:
You can also provide custom queries for other plugins to consume:
Note that:
Similar to glob import, Vite also supports dynamic import with variables.
Note that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.
Pre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:
The init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:
In the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.
NOTE
ES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.
If you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:
In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.
Here is an alternative, assuming the project base is the current directory:
A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.
The worker constructor also accepts options, which can be used to create "module" workers:
The worker detection will only work if the new URL() constructor is used directly inside the new Worker() declaration. Additionally, all options parameters must be static values (i.e. string literals).
A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:
The worker script can also use ESM import statements instead of importScripts(). Note: During development this relies on browser native support, but for the production build it is compiled away.
By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:
If you wish to retrieve the worker as a URL, add the url query:
See Worker Options for details on configuring the bundling of all workers.
Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.
If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.
Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML.
In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:
In the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:
Vite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:
It is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors

 
Sign in with a passkey




            New to GitHub?
              Create an account

English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
When it is time to deploy your app for production, simply run the vite build command. By default, it uses <root>/index.html as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the Deploying a Static Site for guides about popular services.
The production bundle assumes support for modern JavaScript. By default, Vite targets browsers which support the native ES Modules, native ESM dynamic import, and import.meta:
You can specify custom targets via the build.target config option, where the lowest target is es2015.
Note that by default, Vite only handles syntax transforms and does not cover polyfills. You can check out Polyfill.io which is a service that automatically generates polyfill bundles based on the user's browser UserAgent string.
Legacy browsers can be supported via @vitejs/plugin-legacy, which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.
If you are deploying your project under a nested public path, simply specify the base config option and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. vite build --base=/my/public/path/.
JS-imported asset URLs, CSS url() references, and asset references in your .html files are all automatically adjusted to respect this option during build.
The exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected import.meta.env.BASE_URL variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. import.meta.env['BASE_URL'] won't work).
For advanced base path control, check out Advanced Base Options.
The build can be customized via various build config options. Specifically, you can directly adjust the underlying Rollup options via build.rollupOptions:
For example, you can specify multiple Rollup outputs with plugins that are only applied during build.
You can configure how chunks are split using build.rollupOptions.output.manualChunks (see Rollup docs). Until Vite 2.8, the default chunking strategy divided the chunks into index and vendor. It is a good strategy for some SPAs, but it is hard to provide a general solution for every Vite target use case. From Vite 2.9, manualChunks is no longer modified by default. You can continue to use the Split Vendor Chunk strategy by adding the splitVendorChunkPlugin in your config file:
This strategy is also provided as a splitVendorChunk({ cache: SplitVendorChunkCache }) factory, in case composition with custom logic is needed. cache.reset() needs to be called at buildStart for build watch mode to work correctly in this case.
WARNING
You should use build.rollupOptions.output.manualChunks function form when using this plugin. If the object form is used, the plugin won't have any effect.
Vite emits vite:preloadError event when it fails to load dynamic imports. event.payload contains the original import error. If you call event.preventDefault(), the error will not be thrown.
When a new deployment occurs, the hosting service may delete the assets from previous deployments. As a result, a user who visited your site before the new deployment might encounter an import error. This error happens because the assets running on that user's device are outdated and it tries to import the corresponding old chunk, which is deleted. This event is useful for addressing this situation.
You can enable rollup watcher with vite build --watch. Or, you can directly adjust the underlying WatcherOptions via build.watch:
With the --watch flag enabled, changes to the vite.config.js, as well as any files to be bundled, will trigger a rebuild.
Suppose you have the following source code structure:
During dev, simply navigate or link to /nested/ - it works as expected, just like for a normal static file server.
During build, all you need to do is to specify multiple .html files as entry points:
If you specify a different root, remember that __dirname will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your root entry to the arguments for resolve.
Note that for HTML files, Vite ignores the name given to the entry in the rollupOptions.input object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.
When you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your index.html for that purpose to get the smooth development experience.
When it is time to bundle your library for distribution, use the build.lib config option. Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. vue or react:
The entry file would contain exports that can be imported by users of your package:
Running vite build with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats: es and umd (configurable via build.lib):
Recommended package.json for your lib:
Or, if exposing multiple entry points:
File Extensions
If the package.json does not contain "type": "module", Vite will generate different file extensions for Node.js compatibility. .js will become .mjs and .cjs will become .js.
Environment Variables
In library mode, all import.meta.env.* usage are statically replaced when building for production. However, process.env.* usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use define: { 'process.env.NODE_ENV': '"production"' } for example to statically replace them, or use esm-env for better compatibility with bundlers and runtimes.
Advanced Usage
Library mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use Rollup or esbuild directly.
WARNING
This feature is experimental. Give Feedback.
For advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:
A single static base isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using experimental.renderBuiltUrl.
If the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset type included in the second context param given to the function.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Configuring Vite
Shared Options
Server Options
Build Options
Preview Options
Dep Optimization Options
SSR Options
Worker Options
Beyond Fast
ViteConf 2023
Watch the replay!
When running vite from the command line, Vite will automatically try to resolve a config file named vite.config.js inside project root (other JS and TS extensions are also supported).
The most basic config file looks like this:
Note Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. type: "module" in package.json. In this case, the config file is auto pre-processed before load.
You can also explicitly specify a config file to use with the --config CLI option (resolved relative to cwd):
Since Vite ships with TypeScript typings, you can leverage your IDE's intellisense with jsdoc type hints:
Alternatively, you can use the defineConfig helper which should provide intellisense without the need for jsdoc annotations:
Vite also directly supports TS config files. You can use vite.config.ts with the defineConfig helper as well.
If the config needs to conditionally determine options based on the command (serve or build), the mode being used, if it's an SSR build (isSsrBuild), or is previewing the build (isPreview), it can export a function instead:
It is important to note that in Vite's API the command value is serve during dev (in the cli vite, vite dev, and vite serve are aliases), and build when building for production (vite build).
isSsrBuild and isPreview are additional optional flags to differentiate the kind of build and serve commands respectively. Some tools that load the Vite config may not support these flags and will pass undefined instead. Hence, it's recommended to use explicit comparison against true and false.
If the config needs to call async functions, it can export an async function instead. And this async function can also be passed through defineConfig for improved intellisense support:
Environmental Variables can be obtained from process.env as usual.
Note that Vite doesn't load .env files by default as the files to load can only be determined after evaluating the Vite config, for example, the root and envDir options affect the loading behaviour. However, you can use the exported loadEnv helper to load the specific .env file if needed.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors
English
English
Appearance
Why Vite
Getting Started
Features
CLI
Using Plugins
Dependency Pre-Bundling
Static Asset Handling
Building for Production
Deploying a Static Site
Env Variables and Modes
Server-Side Rendering (SSR)
Backend Integration
Comparisons
Troubleshooting
Performance
Philosophy
Migration from v4
Plugin API
HMR API
JavaScript API
Vite Runtime API
Config Reference
Beyond Fast
ViteConf 2023
Watch the replay!
Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:
A dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).
A build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.
Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.
Vite is also highly extensible via its Plugin API and JavaScript API with full typing support.
You can learn more about the rationale behind the project in the Why Vite section.
During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.
For the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.
You can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.
The supported template presets are:
Compatibility Note
Vite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.
Then follow the prompts!
You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:
See create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.
create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks.
For a template at https://github.com/user/project, you can try it out online using https://github.stackblitz.com/user/project (adding .stackblitz after github to the URL of the project).
You can also use a tool like degit to scaffold your project with one of the templates. Assuming the project is on GitHub and uses main as the default branch, you can create a local copy using:
One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.
Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
Vite also supports multi-page apps with multiple .html entry points.
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:
You can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.
Learn more about the Command Line Interface
If you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):
Then go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!
If you have questions or need help, reach out to the community at Discord and GitHub Discussions.
Released under the MIT License. (7b9e927a)
Copyright © 2019-present Evan You & Vite Contributors

 
Sign in with a passkey




            New to GitHub?
              Create an account

Colab paid products - Cancel contracts here
